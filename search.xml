<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C#本质论笔记目录]]></title>
    <url>%2F2017%2F12%2F18%2FCSharp%E6%9C%AC%E8%B4%A8%E8%AE%BA%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[CSharp本质论笔记 第1章 CSharp概述 C#本质论笔记 第2章 数据类型 C#本质论笔记 第3章 操作符和控制流 C#本质论笔记 第4章 方法和参数 C#本质论笔记 第5章 C#本质论笔记 第6章 C#本质论笔记 第7章 C#本质论笔记 第8章]]></content>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#本质论笔记 第3章 操作符和控制流]]></title>
    <url>%2F2017%2F12%2F17%2FCSharp%E6%9C%AC%E8%B4%A8%E8%AE%BA%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E6%8E%A7%E5%88%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[操作符 Operators操作符，也叫运算符，英文：Operrators，见 Microsoft Docs C# 运算符。 名称 含义 例子 一元运算符 接受一个操作数的运算符 ++ 或 new 二元运算符 接受两个操作数的运算符 + - * / 三元运算符 接受三个操作数，C#中唯一的条件运算符 ?: 一元操作符 表达式 描述 说明 +x 标识 +5 ，正号，无意义，出于对 - 操作符的对称才加进来的 -x 求反 -5 ，负号，等价于从零减去操作数 ! 逻辑求反 它针对 bool 定义，当且仅当其操作数为 false 时返回 true。 ~x 按位求反 影响操作数的每一个位(bit) ++x 前递增 操作的结果是操作数递增后的值。 x++ 后递增 操作的结果是操作数递增前的值。 --x 前递减 操作的结果是操作数递减后的值。 x-- 后递减 操作的结果是操作数递减前的值。 (T)x 将 x 显式转换为类型 T 指定强制转换或类型转换。 递增和递减操作符 ++ --递增运算符（Post-Increment）++ 按 1 递增其操作数。 递增运算符可以在其操作数之前或之后出现： ++variable 和 variable++。第一种形式是前缀递增操作。 操作的结果是操作数递增后的值。 第二种形式是后缀递增操作。 操作的结果是操作数递增前的值。 递减运算符 (Post-Decrement） -- 按 1 递减其操作数。 减量运算符可以在其操作数之前或之后出现：–variable 和 variable–。 第一种形式是前缀递减操作。 操作的结果是操作数递减后的值。 第二种形式是后缀递减操作。 操作的结果是操作数递减前的值。 123456int x = 123;int y = 123;// 输出 123,124,125System.Console.WriteLine ("&#123;0&#125;,&#123;1&#125;,&#123;2&#125;", x++, x++, x);// 输出 124,125,125System.Console.WriteLine ("&#123;0&#125;,&#123;1&#125;,&#123;2&#125;", ++y, ++y, y); 选择语句if-else 下列中，如果 m &gt; 10 不成立，后面代码全部不执行 12345678910111213// Try with m = 12 and then with m = 8.int m = 12;int n = 18;if (m &gt; 10) if (n &gt; 20) &#123; Console.WriteLine("Result1"); &#125; else &#123; Console.WriteLine("Result2"); &#125; 下列中，如果 m &gt; 10 不成立，则执行 else 部分代码 1234567891011121314// Try with m = 12 and then with m = 8.int m = 12;int n = 18;// Try with m = 12 and then with m = 8.if (m &gt; 10)&#123; if (n &gt; 20) Console.WriteLine("Result1");&#125;else&#123; Console.WriteLine("Result2");&#125; 可以将 if 语句嵌套到 else 块中，如以下部分代码所示。 1234567891011121314151617181920212223242526272829// Change the values of these variables to test the results.bool Condition1 = true;bool Condition2 = true;bool Condition3 = true;bool Condition4 = true;if (Condition1)&#123; // Condition1 is true.&#125;else if (Condition2)&#123; // Condition1 is false and Condition2 is true.&#125;else if (Condition3)&#123; if (Condition4) &#123; // Condition1 and Condition2 are false. Condition3 and Condition4 are true. &#125; else &#123; // Condition1, Condition2, and Condition4 are false. Condition3 is true. &#125;&#125;else&#123; // Condition1, Condition2, and Condition3 are false.&#125; switch针对 3 个或更多条件测试单个表达式，switch 语句通常用作 if-else 结构的替代项。 示例 123456789101112131415161718192021222324using System;public class Example&#123; public static void Main() &#123; int caseSwitch = 1; switch (caseSwitch) &#123; case 1: Console.WriteLine("Case 1"); break; case 2: Console.WriteLine("Case 2"); break; default: Console.WriteLine("Default case"); break; &#125; &#125;&#125;// The example displays the following output:// Case 1 开关部分C# 不允许从一个开关部分继续执行到下一个开关部分。 因此，以下代码将生成编译器错误。 error CS0163: 控制不能从一个 case 标签(“case 1:”)贯穿到另一个 case 标签 12345678910switch (caseSwitch)&#123; // The following switch section causes an error. case 1: Console.WriteLine("Case 1..."); // Add a break or other jump statement here. case 2: Console.WriteLine("... and/or Case 2"); break;&#125; default casedefault case 可以在 switch 语句中以任何顺序显示。 无论其在源代码中的顺序如何，都将在对所有 case 标签进行计算之后，最后对其进行计算。 匹配表达式匹配表达式提供与 case 标签中的模式相匹配的值。 语法为： switch (expr) 在 C# 6 中，匹配表达式必须是返回以下类型值的表达式： 字符型。 字符串。 bool。 整数值，例如 int 或 long。 枚举值。 从 C# 7 开始，匹配表达式可以是任何非 null 表达式。 switch 语句的 模式匹配每个 case 语句定义一个模式，如果它与匹配表达式相匹配，则会导致执行其包含的开关部分。 所有版本的 C# 都支持常量模式。 其余模式从 C# 7 开始支持。 常量模式常量模式测试匹配表达式是否等于指定常量。 语法为： case constant: 其中 constant 是要测试的值。 constant 可以是以下任何常数表达式： bool 文本，为 true 或 false。 任何整数常量，例如 int、long 或字节。 已声明 const 变量的名称。 一个枚举常量。 字符型文本。 字符串文本。 示例 使用常量模式来确定特定日期是否为周末、工作周的第一天、工作周的最后一天或工作周的中间日期。 它根据 DayOfWeek 枚举的成员计算当前日期的 DateTime.DayOfWeek 属性。 1234567891011121314151617181920212223242526using System;class Program&#123; static void Main() &#123; switch (DateTime.Now.DayOfWeek) &#123; case DayOfWeek.Sunday: case DayOfWeek.Saturday: Console.WriteLine("The weekend"); break; case DayOfWeek.Monday: Console.WriteLine("The first day of the work week."); break; case DayOfWeek.Friday: Console.WriteLine("The last day of the work week."); break; default: Console.WriteLine("The middle of the work week."); break; &#125; &#125;&#125;// The example displays output like the following:// The middle of the work week. 类型模式类型模式可启用简洁类型计算和转换。 使用 switch 语句执行模式匹配时，会测试表达式是否可转换为指定类型，如果可以，则将其转换为该类型的一个变量。 语法为： case type varname 示例 使用类型模式来提供有关各种集合类型的信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Collections;using System.Collections.Generic;using System.Linq;class Example&#123; static void Main(string[] args) &#123; int[] values = &#123; 2, 4, 6, 8, 10 &#125;; ShowCollectionInformation(values); var names = new List&lt;string&gt;(); names.AddRange( new string[] &#123; "Adam", "Abigail", "Bertrand", "Bridgette" &#125; ); ShowCollectionInformation(names); List&lt;int&gt; numbers = null; ShowCollectionInformation(numbers); &#125; private static void ShowCollectionInformation(object coll) &#123; switch (coll) &#123; case Array arr: Console.WriteLine($"An array with &#123;arr.Length&#125; elements."); break; case IEnumerable&lt;int&gt; ieInt: Console.WriteLine($"Average: &#123;ieInt.Average(s =&gt; s)&#125;"); break; case IList list: Console.WriteLine($"&#123;list.Count&#125; items"); break; case IEnumerable ie: string result = ""; foreach (var item in ie) result += "$&#123;e&#125; "; Console.WriteLine(result); break; case null: // Do nothing for a null. break; default: Console.WriteLine($"A instance of type &#123;coll.GetType().Name&#125;"); break; &#125; &#125;&#125;// The example displays the following output:// An array with 5 elements.// 4 items case 语句和 when 子句从 C# 7 开始，因为 case 语句不需要互相排斥，因此可以添加 when 子句来指定必须满足的附加条件使 case 语句计算为 true。 when 子句可以是返回布尔值的任何表达式。 when 子句的更常见用法之一是防止在匹配表达式的值为 null 时执行开关部分。 据提参见 Microsoft Docs : swittch 关键字 -&gt; case 语句和 when 子句 高级主题：switch case 和 枚举值 直接利用枚举值例子 123456789101112131415161718192021222324252627282930using System;public class EnumSwitchCase&#123; enum Days &#123; Sunday = 6, Monday = 3, Tuesday, Wednesday, Thursday, Friday, Saturday &#125;; static void Main() &#123; Days Day = Days.Tuesday; switch (Day) &#123; case Days.Sunday: Console.WriteLine(Days.Sunday); break; case Days.Monday: Console.WriteLine(Days.Monday); break; case Days.Tuesday: Console.WriteLine(Days.Tuesday); break; default: break; &#125; Console.ReadKey(); &#125;&#125;/* 输出Tuesday*/ 枚举值显式显式转换例子 12345678910111213141516171819202122232425262728293031using System;public class EnumTest&#123; enum Day &#123; Sunday = 6, Monday = 3, Tuesday, Wednesday, Thursday, Friday, Saturday &#125;; static void Main() &#123; int ienum = 4; switch (ienum) &#123; case (int)Day.Sunday: Console.WriteLine(Day.Sunday); break; case (int)Day.Monday: Console.WriteLine(Day.Monday); break; case (int)Day.Tuesday: Console.WriteLine(Day.Tuesday); break; default: break; &#125; Console.ReadKey(); &#125;&#125;/* 输出Tuesday*/ 迭代语句dodo 语句重复执行一个语句或语句块，直到指定的表达式计算为 false 值。 循环体必须括在大括号 {} 内，除非它由单个语句组成。 在这种情况下，大括号是可选的。 在下面的示例中，只要变量 x 小于 5，do-while 循环语句就开始执行。 1234567891011121314151617181920public class TestDoWhile&#123; public static void Main () &#123; int x = 0; do &#123; Console.WriteLine(x); x++; &#125; while (x &lt; 5); &#125;&#125;/* Output: 0 1 2 3 4*/ 与 while 语句不同的是，do-while 循环会在计算条件表达式之前执行一次。 在 do-while 块中的任何点，都可使用 ==break== 语句跳出循环。 可通过使用 ==continue== 语句直接步入 while 表达式计算语句。 如果 while 表达式计算结果为 true，则继续执行循环中的第一个语句。 如果表达式的计算结果为 false，则继续执行 do-while 循环后的第一个语句。 do-while 循环还可以通过 goto、return 或 throw 语句退出。 whilewhile 语句执行一条语句或一个语句块，直到指定的表达式的计算结果为 false 为止。 示例 1234567891011121314151617181920class WhileTest&#123; static void Main() &#123; int n = 1; while (n &lt; 6) &#123; Console.WriteLine("Current value of n is &#123;0&#125;", n); n++; &#125; &#125;&#125;/* Output: Current value of n is 1 Current value of n is 2 Current value of n is 3 Current value of n is 4 Current value of n is 5 */ 因为 while 表达式的测试在每次执行循环之前开始，所以 while 循环执行零次或多次。 这不同于 do 循环，该循环执行一次或多次。 break、goto、return 或 throw 语句将控制转移到循环外时，while 循环可能终止。 若要将控制传递到下一个迭代，而不退出循环，则使用 continue 语句。 for使用 for 循环，可以重复运行一个语句或语句块，直到指定的表达式的计算结果为 false 为止。 这种类型的循环可用于循环==访问数组==，以及==事先知道==循环要在其中进行==循环访问的次数==的其他应用程序。 在下面的示例中，i 的值被写入控制台，并在循环的每次迭代过程中递增 1。 123456789101112131415161718class ForLoopTest&#123; static void Main() &#123; for (int i = 1; i &lt;= 5; i++) &#123; Console.WriteLine(i); &#125; &#125;&#125;/*Output:12345*/ 因为 while 表达式的测试在每次执行循环之前开始，所以 while 循环执行零次或多次。 这不同于 do 循环，该循环执行一次或多次。 break、goto、return 或 throw 语句将控制转移到循环外时，while 循环可能终止。 若要将控制传递到下一个迭代，而不退出循环，则使用 continue 语句。 下面的示例阐释了几种不太常见的选择：为初始化表达式部分中的外部循环变量赋值、同时在初始化表达式部分和迭代器部分中调用 Console.WriteLine 方法，以及更改迭代器部分中的两个变量的值。 12345678910111213141516static void Main() &#123; int i; int j = 10; for (i = 0, Console.WriteLine("Start: &#123;0&#125;",i); i &lt; j; i++, j--, Console.WriteLine("i=&#123;0&#125;, j=&#123;1&#125;", i, j)) &#123; // Body of the loop. &#125; &#125; // Output: // Start: 0 // i=1, j=9 // i=2, j=8 // i=3, j=7 // i=4, j=6 // i=5, j=5 定义 for 语句的所有表达式都是可选的。 例如，以下语句创建一个无限循环。 1234for (; ; )&#123; // ...&#125; foreach inforeach 语句针对实现 System.Collections.IEnumerable 或 System.Collections.Generic.IEnumerable 接口的数组或集合中的每个元素重复一组嵌入语句。 在 foreach 块中的任何点上，可以使用 break 中断关键字中断该循环，或者可以使用 continue 继续关键字单步执行到循环中的下一次迭代。 显示整数数组内容的典型 foreach 循环 123456789101112131415int[] fibarray = new int[] &#123; 0, 1, 1, 2, 3, 5, 8, 13 &#125;;foreach (int element in fibarray)&#123; System.Console.WriteLine(element);&#125;System.Console.WriteLine();// Output:// 0// 1// 1// 2// 3// 5// 8// 13 执行相同操作的 for 循环 12345678910111213141516int[] fibarray = new int[] &#123; 0, 1, 1, 2, 3, 5, 8, 13 &#125;;// Compare the previous loop to a similar for loop.for (int i = 0; i &lt; fibarray.Length; i++)&#123; System.Console.WriteLine(fibarray[i]);&#125;System.Console.WriteLine();// Output:// 0// 1// 1// 2// 3// 5// 8// 13 维护数组中元素数计数的 foreach 循环 12345678910111213141516171819int[] fibarray = new int[] &#123; 0, 1, 1, 2, 3, 5, 8, 13 &#125;;// You can maintain a count of the elements in the collection.int count = 0;foreach (int element in fibarray)&#123; count += 1; System.Console.WriteLine("Element #&#123;0&#125;: &#123;1&#125;", count, element);&#125;System.Console.WriteLine("Number of elements in the array: &#123;0&#125;", count);// Output:// Element #1: 0// Element #2: 1// Element #3: 1// Element #4: 2// Element #5: 3// Element #6: 5// Element #7: 8// Element #8: 13// Number of elements in the array: 8 因为 while 表达式的测试在每次执行循环之前开始，所以 while 循环执行零次或多次。 这不同于 do 循环，该循环执行一次或多次。 跳转语句使用跳转语句执行分支，这将立即转移程序控制。 事实上，可以用跳转语句退出循环，或者跳过以此循环的剩余部分并开始下一次循环–即使当前循环条件仍然为true。跳转语句中使用下列关键字： break continue goto return breakC#使用brek语句退出循环或者switch语句。任何时候遇到break语句，控制都会立即离开循环或者switch。 break 语句将终止其所在位置的最接近封闭循环或 switch 语句。 控制权将传递给已终止语句后面的语句（若有）。 示例 在此示例中，条件语句包含一个应从 1 计数到 100 的计数器；但 break 语句在计数器计数到 4 后终止了循环。 12345678910111213141516171819202122232425class BreakTest&#123; static void Main() &#123; for (int i = 1; i &lt;= 100; i++) &#123; if (i == 5) &#123; break; &#125; Console.WriteLine(i); &#125; // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;/* Output: 1 2 3 4*/ 示例 在此示例中，break 语句用于中断内层嵌套循环，并将控制权返回给外层循环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class BreakInNestedLoops&#123; static void Main(string[] args) &#123; int[] numbers = &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; char[] letters = &#123; 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' &#125;; // Outer loop for (int x = 0; x &lt; numbers.Length; x++) &#123; Console.WriteLine("num = &#123;0&#125;", numbers[x]); // Inner loop for (int y = 0; y &lt; letters.Length; y++) &#123; if (y == x) &#123; // Return control to outer loop break; &#125; Console.Write(" &#123;0&#125; ", letters[y]); &#125; Console.WriteLine(); &#125; // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;/* * Output: num = 0 num = 1 a num = 2 a b num = 3 a b c num = 4 a b c d num = 5 a b c d e num = 6 a b c d e f num = 7 a b c d e f g num = 8 a b c d e f g h num = 9 a b c d e f g h i */ continuecontinue 语句将控制传递到其中出现的封闭 while、do、for 或 foreach 语句的下一次迭代。如果循环条件仍然为 true，循环将继续执行。 示例 在本示例中，计数器最初是从 1 到 10 进行计数。 通过结合使用 continue 语句和表达式 (i &lt; 9)，跳过 continue 和 for 主体末尾之间的语句。 1234567891011121314151617181920212223class ContinueTest&#123; static void Main() &#123; for (int i = 1; i &lt;= 10; i++) &#123; if (i &lt; 9) &#123; continue; &#125; Console.WriteLine(i); &#125; // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;/*Output:910*/ gotoC# 确实支持 goto ，并且，不仅仅可以用在 switch 语句中。 goto 语句将程序控制直接传递给标记语句。 goto 的一个通常用法是将控制传递给特定的 switch-case 标签或 switch 语句中的默认标签。 goto 语句还用于跳出深嵌套循环。 示例 下面的示例演示了 goto 在 switch 语句中的使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class SwitchTest&#123; static void Main() &#123; Console.WriteLine("Coffee sizes: 1=Small 2=Medium 3=Large"); Console.Write("Please enter your selection: "); string s = Console.ReadLine(); int n = int.Parse(s); int cost = 0; switch (n) &#123; case 1: cost += 25; break; case 2: cost += 25; goto case 1; case 3: cost += 50; goto case 1; default: Console.WriteLine("Invalid selection."); break; &#125; if (cost != 0) &#123; Console.WriteLine("Please insert &#123;0&#125; cents.", cost); &#125; Console.WriteLine("Thank you for your business."); // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;/*Sample Input: 2Sample Output:Coffee sizes: 1=Small 2=Medium 3=LargePlease enter your selection: 2Please insert 50 cents.Thank you for your business.*/ 示例 下面的示例演示了使用 goto 跳出嵌套循环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class GotoTest1&#123; static void Main() &#123; int x = 200, y = 4; int count = 0; string[,] array = new string[x, y]; // Initialize the array: for (int i = 0; i &lt; x; i++) for (int j = 0; j &lt; y; j++) array[i, j] = (++count).ToString(); // Read input: Console.Write("Enter the number to search for: "); // Input a string: string myNumber = Console.ReadLine(); // Search: for (int i = 0; i &lt; x; i++) &#123; for (int j = 0; j &lt; y; j++) &#123; if (array[i, j].Equals(myNumber)) &#123; goto Found; &#125; &#125; &#125; Console.WriteLine("The number &#123;0&#125; was not found.", myNumber); goto Finish; Found: Console.WriteLine("The number &#123;0&#125; is found.", myNumber); Finish: Console.WriteLine("End of search."); // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;/*Sample Input: 44Sample OutputEnter the number to search for: 44The number 44 is found.End of search.*/ returnreturn 语句可终止它所在的方法的执行，并将控制权返回给调用方法。 它还可以返回可选值。 如果方法是 void 类型，则 return 语句可以省略。 示例 在下面的示例中，该方法CalculateArea()返回局部变量area作为double值 1234567891011121314151617181920class ReturnTest&#123; static double CalculateArea(int r) &#123; double area = r * r * Math.PI; return area; &#125; static void Main() &#123; int radius = 5; double result = CalculateArea(radius); Console.WriteLine("The area is &#123;0:0.00&#125;", result); // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;// Output: The area is 78.54 C# 预处理指令控制流语句中的表达式是在运行时求值。相反，C#预处理器在编译时调用。 #define 和 #undef使用 #define 来定义符号。 将符号用作传递给 #if 指令的表达式时，该表达式的计算结果为 true，如以下示例所示： #define DEBUG 还可以通过 /define 编译器选项来定义符号。 可以通过 #undef 取消定义符号。 #undef 允许你定义一个符号，这样一来，通过将该符号用作 #if 指令中的表达式，表达式将计算为 false。 #if, #elif, #else, 和 #endif以 #if 指令开头的条件指令必须以 #endif 指令显式终止 12345678910111213141516171819// preprocessor_if.cs#define DEBUG#define MYTESTusing System;public class MyClass&#123; static void Main() &#123;#if (DEBUG &amp;&amp; !MYTEST) Console.WriteLine("DEBUG is defined");#elif (!DEBUG &amp;&amp; MYTEST) Console.WriteLine("MYTEST is defined");#elif (DEBUG &amp;&amp; MYTEST) Console.WriteLine("DEBUG and MYTEST are defined");#else Console.WriteLine("DEBUG and MYTEST are not defined");#endif &#125;&#125; #warning 和 #error #warning 可从代码中的特定位置生成一个级别的警告。 #error 可从代码中的特定位置生成错误。 编译器遇到 #warning 指令，会显示 #warning 指令后面的文本，然后继续编译。 编译器遇到 #error 指令，会显示后面的文本，然后立即退出编译，不会生成IL代码。 #region 和 #endregion利用 #region 和 #endregion，可以指定在使用 Visual Studio 编辑器的大纲功能时可展开或折叠的代码块。 #region 块必须通过 #endregion 指令终止。 #region 块不能与 #if 块重叠。 但是，可以将 #region 块嵌套在 #if 块内，或将 #if 块嵌套在 #region 块内。 #line #line 可修改编译器的行号及（可选）用于错误和警告的文件名输出。 此示例演示如何报告与行号相关联的两个警告。 #line 200 指令将行号强制设为 200（尽管默认值为 #7），直到下一个 #line 指令前，文件名都将报告为“特殊”。 #line 默认指令将行号返回至其默认行号，默认行号对由上个指令重新编号的行进行计数。 123456789101112131415class MainClass&#123; static void Main() &#123;#line 200 "Special" int i; // CS0168 on line 200 int j; // CS0168 on line 201#line default char c; // CS0168 on line 9 float f; // CS0168 on line 10#line hidden // numbering not affected string s; double d; // CS0168 on line 13 &#125;&#125; #line hidden 指令能对调试程序隐藏连续行，当开发者逐行执行代码时，介于 #line hidden 和下一 #line 指令（假设它不是其他 #line hidden 指令）间的任何行都将被跳过。 意思是，调试器会执行 #hidden 后面代码，只是不会在 #hidden 后面代码调试停留。即便设置了断点，也会被调试器忽略。 示例 下列示例演示调试程序如何忽略代码中的隐藏行。 运行示例时，它将显示三行文本。 但是，如果按照示例所示设置断点、并按 F10 逐行执行代码，可观察到调试程序忽略隐藏行。 另请注意，即使在隐藏行设置断点，调试程序仍将忽略它。C# 12345678910111213// preprocessor_linehidden.csusing System;class MainClass&#123; static void Main() &#123; Console.WriteLine("Normal line #1."); // Set break point here.#line hidden Console.WriteLine("Hidden line.");#line default Console.WriteLine("Normal line #2."); &#125;&#125; 运行时输出结果： Normal line #1. Hidden line. Normal line #2. #pragam #pragma 指令可以启用或者禁用特定的编译警告。 下面例子禁止“字段未使用”警告，然后在编译MyClass类后还原该警告。 123456#pragma warning disable 169public class MyClass&#123; int neverUsedField;&#125;#pragma warning restore 169 若要查找警告编号，请在 Visual Studio 中生成项目，然后在“输出”窗口中查找警告编号。这是要干嘛？😥 结尾]]></content>
      <tags>
        <tag>C#</tag>
        <tag>C#本质论</tag>
        <tag>Essential C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio Code VSCode 常用 插件 扩展]]></title>
    <url>%2F2017%2F12%2F14%2FVisual-Studio-Code-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[界面主题 Monokai : VSCcode 内置主题 Agila : 包含多个主题 Dark-Dracula Theme : Dracula 风格主题里面比较好的 Nosferatu : Dracula 风格主题 monokai light : 白色，背景色类色默认的vs亮色主题背景 FlatUI : 包含多个主题 Flatland Monokai Theme : theme-dark-monokai : Monokai Dark Soda : Monokai Light : 图标主题 vscode-icons：Icons : 主要推荐 material icon theme : 备选 功能插件 C# : VSCode 开发 C# 必备 C# FixFormat : 格式化代码，好用 C# Extensions : 提高开发效率的扩展工具 Bracket Pair Colorizer ：对括号对进行着色，再也不会眼晕了。 Markdown All in One : All in One ，好用 markdownlint : 编写 Markdown 文件时智能提示，有助于养成好习惯。 Markdown Table Prettifier : Markdown 文件中，对表格进行强制格式化，看起来更整齐，舒服。 XML Tools ：作者 Josh Johnson - XML 格式化/Tree View XML Tools （备选） : 作者 Qub - 格式化XML文档 Alt+Shift+F Output Colorizer : 可以终端日志输出着色，实用 vscode-fileheader: 添加头header comment Setting Sync: 同步你的设置和插件]]></content>
      <tags>
        <tag>VSCode</tag>
        <tag>插件</tag>
        <tag>Visual Studio</tag>
        <tag>Visual Studio Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NumLock灯在多个linux版本中的不同设置方法]]></title>
    <url>%2F2017%2F12%2F14%2FNumLock%E7%81%AF%E5%9C%A8%E5%A4%9A%E4%B8%AAlinux%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[elementary OS第一步：安装numlockx，输入命令 sudo apt-get install numlockx 第二步：用 vim 打开 /etc/lightdm/pantheon-greeter.conf 文件，取消numlock行前面的 # # activate-numlock=true. 结果如下图： 最后：重启或者注销后。小键盘就可以自动启动了 Tips: vim怎么插入内容呢？ 快捷键 i 切换到插入模式 方向键调整光标到插入位置 复制粘贴代码 Esc键退出插入模式，回到默认的命令模式 输入命令 :wq 表示保存并退出 ferenOS，Linux Mint第一步：安装numlockx，输入命令 sudo apt-get install numlockx 第二步：用 vim 打开 /etc/lightdm/lightdm.conf文件，最后一行添加 greeter-setup-script=/usr/bin/numlockx on Tips: 敲入下面命令编辑文件 sudo vi /etc/lightdm/lightdm.conf 结果如下图： 同样的，重启或者注销后，生效。 CentOS ，Scientific Linux，Fedora and other rpm based 先安装numlockx,可以去opensuse的软件中心里找rpm包进行安装 下载地址：https://pkgs.org/download/numlockx/ 安装命令： sudo rpm -i numlockx-1.2-6.el7.nux.x86_64.rpm 或者：sudo yum install numlockx 先备份 cp /etc/gdm/Init/Default /etc/gdm/Init/Default_backup 再修改 vim /etc/gdm/Init/Default 在exit 0之前加上/usr/bin/numlockx on,重启就会发现小键盘已经打开了！ Ubuntu and other debian based基于 gdm安装 numlockx ,在终端中输入命令： sudo apt-get install numlockx 配置 numlockx sudo gedit /etc/gdm/Init/Default 在 exit 0 之前，添加如下内容： #set numlock on if [ -x /usr/bin/numlockx ]; then /usr/bin/numlockx on fi 结果如下图： 基于 lightdmsudo gedit /etc/lightdm/lightdm.conf 最后一行添加下面语句： greeter-setup-script=/usr/bin/numlockx on 结果如下图： 重启或者注销后，生效。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>NumLock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#本质论笔记 第2章 数据类型]]></title>
    <url>%2F2017%2F12%2F13%2FCSharp%E6%9C%AC%E8%B4%A8%E8%AE%BA%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型预定义类型(predefined type)/基元类型(primitive type)，也翻译为基本类型、基础类型或者原始类型。 类型 Size Range BCL name Signed 精度 后缀 例子 sbyte 8 bits -128 to 127 System.SByte 是 byte 8 bits 0 to 255 System.Byte 否 short 16 bits -32,768 to 32,767 System.Int16 是 ushort 16 bits 0 to 65,535 System.UInt16 否 int 32 bits -2,147,483,648 to 2,147,483,647 System.Int32 是 uint 32 bits 0 到 4,294,967,295 System.UInt32 否 U或u long 64 bits -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 System.Int64 是 L或l ulong 64 bits -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 System.UInt64 否 UL或ul float 32 bits ±1.5e−45 到 ±3.4e38 System.Single 7 F或f double 64 bits ±5.0e−324 到 ±1.7e308 System.Double 15-16 D或d decimal 128 bits ±1.0e−28 到 ±7.9e28 System.Decimal 28-29 M或m bool bits System.Boolean char 16 bits Unicode 字符 U+0000 到 U+ffff System.Char char test; test = ‘A’ string System.String string test; test = “A” object System.Object dynamic 无相应.NET类型 类型关键字和BCL name效果相同，规范建议指定数据类型时使用C#关键字，而不是BCL名称（例如，使用==string==而不是System.String或者==String==）。 后缀不区分大小写，一般建议采用大写。但对于long ，强烈建议使用大写字母Ｌ，因为小写字母ｌ和数字１不好区分。 关于指数记数法，需要使用 e 或者 E 中缀，在中缀字母后添加正整数或者负整数，并在字面量的最后添加恰当的数据类型后缀。例如将阿伏加德罗常熟作为float输出，代码如下： 1System.Console.WriteLine(6.023E23F); 输出结果 6.023E+23 经常用到的数字格式化输出例子1234567891011121314151617class hello &#123; static void Main () &#123; double dValue = 12345.6789; //几种格式转换输出方式 System.Console.WriteLine (dValue); //原值输出 输出 12345.6789 System.Console.WriteLine ("&#123;0&#125;", dValue); System.Console.WriteLine (string.Format ("&#123;0&#125;", dValue)); System.Console.WriteLine (dValue.ToString ()); System.Console.WriteLine ("以下几种方法在数据有效范围内效果相同："); System.Console.WriteLine ("WriteLine (dValue);"); System.Console.WriteLine ("WriteLine (\"&#123;0&#125;\", dValue);"); System.Console.WriteLine ("WriteLine (string.Format (\"&#123;0&#125;\", dValue));"); System.Console.WriteLine ("WriteLine (dValue.ToString ());"); &#125;&#125; 输出结果 12345.6789 12345.6789 12345.6789 12345.6789 以下几种方法在数据有效范围内效果相同： WriteLine (dValue); WriteLine (&quot;{0}&quot;, dValue); WriteLine (string.Format (&quot;{0}&quot;, dValue)); WriteLine (dValue.ToString ()); 基本数值类型C#基本数值类型包括整数类型、浮点类型以及decimal类型。 浮点数的精度是可变的。例如浮点数 0.1，可以表示成 0.0999999999 或者 0.100000001（或者任何非常接近0.1的数）。 decimal是一种特殊的浮点类型，是128位精度的10进制浮点类型，能够存书大数字而无表示错误，适合大而精确的计算。 与==二进制==浮点数不同，decimal类型保证范围内所有的==十进制==数都是精确的，0.1就是0.1。 ==关于浮点精度理解==，目前计算机是2进制（只有0，1状态）的运算机器，所有小于1的数，只能用除法计算得到结果，计算机中的除法就是移位。 例如0.1，表示成分数是1/10，分母10不是2的整数次幂，因此1/10不能用有限的二进制小数表示。 字面值或字面量(literal value) literal value 表示源代码中的固定值，就是数据值本身。Microsoft Docs 将 literal 翻译作 文本。 个人理解，字面量可以叫做常数，常数值，固定值等等，可以是用户自己定义的或者系统定义的常数、符号等（例如：==123==、==’A’==、==\n== 等）。 例如，下面代码中的数字值： 12System.Console.WriteLine(42);System.Console.WriteLine(1.618034); 输出结果 42 1.618034 用变量定义来实现上面的效果，定义int 类型变量 x 并赋值 42 ，定义 double 类型变量 y 并赋值 1.618034 。 1234int x = 42;double y = 1.618034;System.Console.WriteLine(x);System.Console.WriteLine(y); 输出结果 42 1.618034 初学者主题:使用硬编码要慎重直接将值放到源代码中成为硬编码（==hardcoding==），如果以后需要更改值，就必须重新编译代码。给予方便维护考虑，可以考虑从外部获取值，比如从一个配置文件中，这样以后修改值的时候，不需要重新编译代码。 带小数点的字面值，编译器自动解释成 double 类型。 整数值（没有小数点）通常默认为 int，前提是值在 int 类型存储范围内。如果值太大，编译器会把它解释成 long 。 C# 允许想非 int 类型赋值，前提是字面值对于目标数据类型来说是合法的。例如，short s = 42和byte b = 77都是允许的。但值一点进队字面值成立。如果不使用额外语法，b = s就是非法的。 数据精度相关代码示例12System.Console.WriteLine(1.234567890123456);System.Console.WriteLine(1.012345678901234); 输出结果 1.23456789012346 1.01234567890123 受限于 double 类型的精度，超过精度的遵循==四舍五入==原则截取。 要显示具有完整精度的数字，必须将字面值显示生命为 decimal 类型，知识通过追加一个M（或者m）后缀来实现的。 下面代码指定一个 decimal 字面值 12System.Console.WriteLine(1.234567890123456M);System.Console.WriteLine(1.012345678901234m); 输出结果 1.234567890123456 1.012345678901234 初学者主题:十六进制表示法 Hexadecimal NotationC#允许指定十六进制值，需要附加 0x 或者 0X 前缀（效果一样），如下示例： 12345//用16进制字面量显示数值10System.Console.WriteLine(0x000A);System.Console.WriteLine(0x000a);System.Console.WriteLine(0X000A);System.Console.WriteLine(0X000a); 输出结果 10 10 10 10 注意，代码输出结果是10，而不是0x000A 或者 0x000a 。 高级主题:将数格式化成十六进制要以十六进制形式格式化输出一个数值，必须使用==x==或者==X==数值格式说明符。==大小写==决定了十六进制字母的大小写，数值字面量可采用十进制或者十六进制形式，结果一样。如下示例： 1234567891011121314//显示数值 "0xA" 或者 “0xa”//字面量为十进制数值，格式化为十六进制，大写System.Console.WriteLine("0x&#123;0:X&#125;", 10);//字面量为十进制数值，格式化为十六进制，小写System.Console.WriteLine("0x&#123;0:x&#125;", 10);//字面量为十六进制大写数值，格式化为十六进制，小写System.Console.WriteLine("0x&#123;0:x&#125;", 0X000A);//字面量为十六进制小写数值，格式化为十六进制，大写System.Console.WriteLine("0x&#123;0:X&#125;", 0X000a);int value;value = 0X000a;System.Console.WriteLine(value.ToString("X"));System.Console.WriteLine("0x&#123;0&#125;", value.ToString("X")); 输出结果 0xA 0xa 0xa 0xA A 0xA 高级主题:round-trip （往返过程）格式化在格式化字符串时，使用round-trip格式说明符(R 或者 r)，用于确保转换为字符串的数值将再次分析为相同的数值。只有 Single、 Double 和 BigInteger 类型支持此格式。 例如，string.Format(“{0}”,0.1234567890123125) 结果是 0.123456789012313 而， string.Format(“{0:R}”,0.1234567890123125) 结果是 0.1234567890123125 。 123456789101112131415161718192021222324252627282930public class Program&#123; public static void Main() &#123; const double number = 0.1234567890123125; double result; string text; text = string.Format("&#123;0&#125;",number); //double.Parase 将数字的字符串表示形式转换为它的等效双精度浮点数。 result = double.Parse(text); System.Console.WriteLine(number); System.Console.WriteLine("text = &#123;0&#125;" , text); System.Console.WriteLine(result); //double.ToSring() 将此实例的数值转换为其等效的字符串表示形式。 System.Console.WriteLine(number.ToString()); System.Console.WriteLine("&#123;0&#125;: text = number", text == number.ToString()); System.Console.WriteLine("&#123;0&#125;: result = number", result != number); text = string.Format("&#123;0:R&#125;",number); System.Console.WriteLine("text = &#123;0&#125;" , text); result = double.Parse(text); System.Console.WriteLine("&#123;0&#125;: result = number", result == number); System.Console.ReadKey(); &#125;&#125; 输出结果 0.123456789012313 text = 0.123456789012313 0.123456789012313 0.123456789012313 True: text = number True: result = number text = 0.1234567890123125 True: result = number 标准数字格式字符串(Numeric Format Strings) 标准数字格式字符串用于格式化通用数值类型。 标准数字格式字符串采用 Axx 的形式，其中： A 是称为格式说明符的单个字母字符。任何包含一个以上字母字符（包括空白）的数字格式字符串都被解释为自定义数字格式字符串。 xx 是称为精度说明符的可选整数。 精度说明符的范围从 0 到 99，并且影响结果中的位数。请注意，精度说明符控制数字的字符串表示形式中的数字个数。 它不舍入该数字。若要执行舍入运算，请使用 Math.Ceiling、 Math.Floor 或 Math.Round 方法。 当精度说明符控制结果字符串中的小数位数时，结果字符串反映远离零的一侧舍入的数字（即，使用 MidpointRounding.AwayFromZero）。 所有数字类型的 ToString 方法的某些重载支持标准数字格式字符串。 例如，可将数字格式字符串提供给 ToString(String) 类型的 ToString(String, IFormatProvider) 方法和 Int32 方法。 .NET Framework 复合格式化功能也支持标准数字格式字符串，该功能由 Write 和 WriteLine 类的某些 Console 和 StreamWriter 方法、 String.Format 方法以及 StringBuilder.AppendFormat 方法使用。复合格式功能允许你将多个数据项的字符串表示形式包含在单个字符串中，以指定字段宽度，并在字段中对齐数字。 下表描述标准的数字格式说明符并显示由每个格式说明符产生的示例输出。 格式说明符 名称 描述 示例 “C”或“c” 货币 结果：货币值。受以下类型支持：所有数值类型。精度说明符：小数位数。默认值精度说明符：由 NumberFormatInfo.CurrencyDecimalDigits 定义。更多信息： 货币（“C”）格式说明符。 123.456 (“C”, en-US) -&gt; $123.46 123.456 (“C”, fr-FR) -&gt; 123,46 € 123.456 (“C”, ja-JP) -&gt; ¥123 -123.456 (“C3”, en-US) -&gt; ($123.456)-123.456 (“C3”, fr-FR) -&gt; -123,456 €-123.456 (“C3”, ja-JP) -&gt; -¥123.456 “D”或“d” Decimal 结果：整型数字，负号可选。受以下类型支持：==仅整型==。精度说明符：最小位数。默认值精度说明符：所需的最小位数。更多信息： 十进制（“D”）格式说明符。 1234 (“D”) -&gt; 1234 -1234 (“D6”) -&gt; -001234 “E”或“e” 指数(科学型) 结果：指数记数法。受以下类型支持：所有数值类型。精度说明符：小数位数。默认值精度说明符：6。更多信息： 指数（“E”）格式说明符。 1052.0329112756 (“E”, en-US) -&gt; 1.052033E+0031052.0329112756 (“e”, fr-FR) -&gt; 1,052033e+003-1052.0329112756 (“e2”, en-US) -&gt; -1.05e+003-1052.0329112756 (“E2”, fr_FR) -&gt; -1,05E+003 “F”或“f” 定点 结果：整数和小数，负号可选。受以下类型支持：所有数值类型。精度说明符：小数位数。默认值精度说明符：由 NumberFormatInfo.NumberDecimalDigits 定义。更多信息： 定点（“F”）格式说明符。 1234.567 (“F”, en-US) -&gt; 1234.571234.567 (“F”, de-DE) -&gt; 1234,571234 (“F1”, en-US) -&gt; 1234.01234 (“F1”, de-DE) -&gt; 1234,0-1234.56 (“F4”, en-US) -&gt; -1234.5600-1234.56 (“F4”, de-DE) -&gt; -1234,5600 “G”或“g” 常规 结果：最紧凑的定点表示法或科学记数法。受以下类型支持：所有数值类型。精度说明符：有效位数。默认值精度说明符：取决于数值类型。更多信息：常规（“G”）格式说明符。 -123.456 (“G”, en-US) -&gt; -123.456-123.456 (“G”, sv-SE) -&gt; -123,456123.4546 (“G4”, en-US) -&gt; 123.5123.4546 (“G4”, sv-SE) -&gt; 123,5-1.234567890e-25 (“G”, en-US) -&gt; -1.23456789E-25-1.234567890e-25 (“G”, sv-SE) -&gt; -1,23456789E-25 “N”或“n” 数字 结果：整数和小数、组分隔符和小数分隔符，负号可选。受以下类型支持：所有数值类型。精度说明符：所需的小数位数。默认值精度说明符：由 NumberFormatInfo.NumberDecimalDigits 定义。更多信息： 数字（“N”）格式说明符。 1234.567 (“N”, en-US) -&gt; 1,234.571234.567 (“N”, ru-RU) -&gt; 1 234,571234 (“N1”, en-US) -&gt; 1,234.01234 (“N1”, ru-RU) -&gt; 1 234,0-1234.56 (“N3”, en-US) -&gt; -1,234.560-1234.56 (“N3”, ru-RU) -&gt; -1 234,560 “P”或“p” 百分比 结果：乘以 100 并显示百分比符号的数字。受以下类型支持：所有数值类型。 精度说明符：所需的小数位数。默认值精度说明符：由 NumberFormatInfo.PercentDecimalDigits 定义。更多信息： 百分比（“P”）格式说明符。 1 (“P”, en-US) -&gt; 100.00 %1 (“P”, fr-FR) -&gt; 100,00 %-0.39678 (“P1”, en-US) -&gt; -39.7 %-0.39678 (“P1”, fr-FR) -&gt; -39,7 % “R”或“r” 往返过程 结果：可以往返至相同数字的字符串。受以下类型支持： Single、 Double 和 BigInteger。精度说明符：忽略。更多信息： 往返过程（“R”）格式说明符。 123456789.12345678 (“R”) -&gt; 123456789.12345678-1234567890.12345678 (“R”) -&gt; -1234567890.1234567 “X”或“x” 十六进制 结果：十六进制字符串。受以下类型支持：仅整型。精度说明符：结果字符串中的位数。更多信息： 十六进制（“X”）格式说明符。 255 (“X”) -&gt; FF-1 (“x”) -&gt; ff255 (“x4”) -&gt; 00ff-1 (“X4”) -&gt; 00FF 任何其他单个字符 未知说明符 结果：在运行时引发 FormatException。 自定义数字格式字符串 你可以创建自定义数字格式字符串，这种字符串由一个或多个自定义数字说明符组成，用于定义设置数值数据格式的方式。 自定义数字格式字符串是任何不属于 ==标准数字格式字符串== 的格式字符串。 所有数字类型的 ToString 方法的某些重载支持自定义数字格式字符串。 例如，可将数字格式字符串提供给 Int32 类型的 ToString(String) 方法和 ToString(String, IFormatProvider) 方法。 .NET Framework 复合格式化功能也支持自定义数字格式字符串，该功能由 Console 和 StreamWriter 类的某些 Write 和 WriteLine 方法、 String.Format 方法以及 StringBuilder.AppendFormat 方法所使用。 下表描述自定义数字格式说明符并显示由每个格式说明符产生的示例输出。 格式说明符 名称 描述 示例 “0” 零占位符 用对应的数字（如果存在）替换零；否则，将在结果字符串中显示零。 1234.5678 (“00000”) -&gt;012350.45678 (“0.00”, en-US) -&gt; 0.460.45678 (“0.00”, fr-FR) -&gt; 0,46 “#” 数字占位符 用对应的数字（如果存在）替换“#”符号；否则，不会在结果字符串中显示任何数字。 1234.5678 (“#####”) -&gt; 12350.45678 (“#.##”, en-US) -&gt; .460.45678 (“#.##”, fr-FR) -&gt; ,46 “.” 小数点 确定小数点分隔符在结果字符串中的位置。 0.45678 (“0.00”, en-US) -&gt; 0.460.45678 (“0.00”, fr-FR) -&gt; 0,46 “,” 组分隔符和数字比例换算 用作组分隔符和数字比例换算说明符。作为组分隔符时，它在各个组之间插入本地化的组分隔符字符。作为数字比例换算说明符，对于每个指定的逗号，它将数字除以1000。 组分隔符说明符：2147483647 (“##,#”, en-US) -&gt; 2,147,483,6472147483647 (“##,#”, es-ES) -&gt; 2.147.483.647比例换算说明符：2147483647 (“#,#,,”, en-US) -&gt; 2,1472147483647 (“#,#,,”, es-ES) -&gt; 2.147 “%” 百分比占位符 将数字乘以 100，并在结果字符串中插入本地化的百分比符号。 0.3697 (“%#0.00”, en-US) -&gt; %36.970.3697 (“%#0.00”, el-GR) -&gt; %36,970.3697 (“##.0 %”, en-US) -&gt; 37.0 %0.3697 (“##.0 %”, el-GR) -&gt; 37,0 % “‰” 千分比占位符 将数字乘以 1000，并在结果字符串中插入本地化的千分比符号。 0.03697 (“#0.00‰”, en-US) -&gt; 36.97‰0.03697 (“#0.00‰”, ru-RU) -&gt; 36,97‰ “E0”“E+0”“E-0”“e0”“e+0”“e-0” 指数表示法 如果后跟至少一个0（零），则使用指数表示法设置结果格式。“E”或“e”指示指数符号在结果字符串中是大写还是小写。跟在“E”或“e”字符后面的零的数目确定指数中的最小位数。 加号 (+)指示符号字符总是置于指数前面。减号(-)指示符号字符仅置于负指数前面。 987654 (“#0.0e0”) -&gt; 98.8e41503.92311 (“0.0##e+00”) -&gt; 1.504e+031.8901385E-16 (“0.0e+00”) -&gt; 1.9e-16 \ 转义符 使下一个字符被解释为文本而不是自定义格式说明符。 987654 (“###00#“) -&gt; #987654# ‘string’“string” 文本字符串分隔符 指示应复制到未更改的结果字符串的封闭字符。 68 (“# ‘ degrees’”) -&gt; 68 degrees68 (“# ‘ degrees’”) -&gt; 68 degrees ; 部分分隔符 通过分隔格式字符串定义正数、负数和零各部分。 12.345 (“#0.0#;(#0.0#);-\0-“) -&gt; 12.350 (“#0.0#;(#0.0#);-\0-“) -&gt; -0--12.345 (“#0.0#;(#0.0#);-\0-“) -&gt; (12.35)12.345 (“#0.0#;(#0.0#)”) -&gt; 12.350 (“#0.0#;(#0.0#)”) -&gt; 0.0-12.345 (“#0.0#;(#0.0#)”) -&gt; (12.35) 其他 所有其他字符 字符将复制到未更改的结果字符串。 68 (“# °”) -&gt; 68 ° 标准数字格式化字符串 简单例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Globalization;using System.Threading;public class NumericFormats &#123; public static void Main () &#123; // Display string representations of numbers for en-us culture CultureInfo ci = new CultureInfo ("en-us"); // Output floating point values double floating = 10761.937554; Console.WriteLine ("原始数字：10761.937554"); Console.WriteLine ("C: &#123;0&#125;", floating.ToString ("C", ci)); // Displays "C: $10,761.94" Console.WriteLine ("E: &#123;0&#125;", floating.ToString ("E03", ci)); // Displays "E: 1.076E+004" Console.WriteLine ("F: &#123;0&#125;", floating.ToString ("F04", ci)); // Displays "F: 10761.9376" Console.WriteLine ("G: &#123;0&#125;", floating.ToString ("G", ci)); // Displays "G: 10761.937554" Console.WriteLine ("N: &#123;0&#125;", floating.ToString ("N03", ci)); // Displays "N: 10,761.938" Console.WriteLine ("P: &#123;0&#125;", (floating / 10000).ToString ("P02", ci)); // Displays "P: 107.62 %" Console.WriteLine ("R: &#123;0&#125;", floating.ToString ("R", ci)); // Displays "R: 10761.937554" Console.WriteLine (); // Output integral values int integral = 8395; Console.WriteLine ("原始数字：8395"); Console.WriteLine ("C: &#123;0&#125;", integral.ToString ("C", ci)); // Displays "C: $8,395.00" Console.WriteLine ("D: &#123;0&#125;", integral.ToString ("D6", ci)); // Displays "D: 008395" Console.WriteLine ("E: &#123;0&#125;", integral.ToString ("E03", ci)); // Displays "E: 8.395E+003" Console.WriteLine ("F: &#123;0&#125;", integral.ToString ("F01", ci)); // Displays "F: 8395.0" Console.WriteLine ("G: &#123;0&#125;", integral.ToString ("G", ci)); // Displays "G: 8395" Console.WriteLine ("N: &#123;0&#125;", integral.ToString ("N01", ci)); // Displays "N: 8,395.0" Console.WriteLine ("P: &#123;0&#125;", (integral / 10000.0).ToString ("P02", ci)); // Displays "P: 83.95 %" Console.WriteLine ("X: 0x&#123;0&#125;", integral.ToString ("X", ci)); // Displays "X: 0x20CB" Console.WriteLine (); &#125;&#125; 输出结果 原始数字：10761.937554 C: $10,761.94 E: 1.076E+004 F: 10761.9376 G: 10761.937554 N: 10,761.938 P: 107.62% R: 10761.937554 原始数字：8395 C: $8,395.00 D: 008395 E: 8.395E+003 F: 8395.0 G: 8395 N: 8,395.0 P: 83.95% X: 0x20CB 标准数字格式化字符串 详细例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128using System;using System.Globalization;class hello &#123; static void Main () &#123; double dValue = 12345.6789; int iValue = 12345; //几种格式转换输出方式 System.Console.WriteLine (dValue); //原值输出 输出 12345.6789 System.Console.WriteLine ("&#123;0&#125;", dValue); System.Console.WriteLine (string.Format ("&#123;0&#125;", dValue)); System.Console.WriteLine (dValue.ToString ()); System.Console.WriteLine ("以下几种方法在数据有效范围内效果相同："); System.Console.WriteLine ("WriteLine (dValue);"); System.Console.WriteLine ("WriteLine (\"&#123;0&#125;\", dValue);"); System.Console.WriteLine ("WriteLine (string.Format (\"&#123;0&#125;\", dValue));"); System.Console.WriteLine ("WriteLine (dValue.ToString ());"); System.Console.WriteLine ("======================================"); //■■ 货币 "C" 格式说明符 ■■// Console.WriteLine ("&#123;0:c&#125;", dValue); //货币格式 默认两位小数 输出 ￥12,345.68 Console.WriteLine ("&#123;0:c2&#125;", dValue); //货币格式 输出 指定两位小数 ￥12,345.68 Console.WriteLine (dValue.ToString ("C")); //货币格式 输出 ￥12,345.68KT Console.WriteLine (dValue.ToString ("C2")); //货币格式 输出 ￥12,345.68 Console.WriteLine (dValue.ToString ("C3")); //货币格式 指定三位小数 输出 ￥12,345.679 //货币格式 当前国家 默认位小数 输出 ￥12,345.68 //System.Globalization. CultureInfo.CurrentCulture Console.WriteLine (dValue.ToString ("C", CultureInfo.CurrentCulture)); //货币格式 当前国家 指定两位小数 输出 ￥12,345.68 Console.WriteLine (dValue.ToString ("C2", CultureInfo.CurrentCulture)); //货币格式 中国货币 指定三位小数 输出 ￥12,345.679 Console.WriteLine (dValue.ToString ("C3", CultureInfo.CreateSpecificCulture ("zh-CN"))); //货币格式 丹麦货币 指定三位小数 输出 12.345,679 kr. Console.WriteLine (dValue.ToString ("C3", CultureInfo.CreateSpecificCulture ("da-DK"))); //■■ 十进制 "D" 格式例子 ■■// Console.WriteLine (iValue.ToString ("D")); //输出 12345 Console.WriteLine (iValue.ToString ("D8")); //输出 00012345 iValue = -12345; Console.WriteLine (iValue.ToString ("D")); //输出 -12345 Console.WriteLine (iValue.ToString ("D8")); //输出 -00012345 //错误示例 “D”只接受整型 其他编译不通过 //Console.WriteLine(dValue.ToString("D8")); //■■ 指数 "E" 格式说明符 ■■// Console.WriteLine (dValue.ToString ("E")); //输出 1.234568E+004 Console.WriteLine (dValue.ToString ("E10")); //输出 1.2345678900E+004 //■■ 定点 “F” 格式说明符 ■■// iValue = 12345; Console.WriteLine (iValue.ToString ("F")); //输出 12345.00 iValue = -12345; Console.WriteLine (iValue.ToString ("F3")); //输出 12345.000 dValue = 12345.6789; Console.WriteLine (dValue.ToString ("F")); //输出 12345.68 Console.WriteLine (dValue.ToString ("F0")); //输出 12345 //■■ 常规 “G” 格式说明符 ■■// dValue = 12345.6789; Console.WriteLine (dValue.ToString ("G")); // Displays 12345.6789 Console.WriteLine (dValue.ToString ("G", CultureInfo.CreateSpecificCulture ("fr-FR"))); // Displays 12345,6789 Console.WriteLine (dValue.ToString ("G7")); // Displays 12345.68 dValue = .0000023; Console.WriteLine (dValue.ToString ("G")); // Displays 2.3E-06 Console.WriteLine (dValue.ToString ("G", CultureInfo.CreateSpecificCulture ("fr-FR"))); // Displays 2,3E-06 dValue = .0023; Console.WriteLine (dValue.ToString ("G")); // Displays 0.0023 dValue = 1234; Console.WriteLine (dValue.ToString ("G2")); // Displays 1.2E+03 dValue = Math.PI; Console.WriteLine (dValue.ToString ("G5")); // Displays 3.1416 //■■ 数字 “N” 格式说明符 ■■// dValue = -12345.6789; Console.WriteLine (dValue.ToString ("G")); // Displays 12345.6789N Console.WriteLine (dValue.ToString ("N1", CultureInfo.CreateSpecificCulture ("sv-SE"))); // Displays -12 445,7 iValue = 123456789; Console.WriteLine (iValue.ToString ("N1", CultureInfo.InvariantCulture)); // Displays 123,456,789.0 //■■ 数字 “N” 格式说明符 ■■// dValue = -.2468013; Console.WriteLine (dValue.ToString ("P")); // Displays -24.68 % Console.WriteLine (dValue.ToString ("P1", CultureInfo.CreateSpecificCulture ("sv-SE"))); // Displays -24,68% Console.WriteLine (dValue.ToString ("P1", CultureInfo.InvariantCulture)); // Displays -24.7 % //■■ 数字 “R” 格式说明符 ■■// dValue = Math.PI; Console.WriteLine (dValue.ToString ("r")); // Displays 3.1415926535897931 Console.WriteLine (dValue.ToString ("r", CultureInfo.CreateSpecificCulture ("fr-FR"))); // Displays 3,1415926535897931 dValue = 1.623e-21; Console.WriteLine (dValue.ToString ("r")); // Displays 1.623E-21 //■■ 十六进制 “X” 格式说明符 ■■// iValue = 0x2045e; Console.WriteLine (iValue.ToString ("x")); // Displays 2045e Console.WriteLine (iValue.ToString ("X")); // Displays 2045E Console.WriteLine (iValue.ToString ("X8")); // Displays 0002045E iValue = 123456789; Console.WriteLine (iValue.ToString ("X")); // Displays 75BCD15 Console.WriteLine (iValue.ToString ("X2")); // Displays 75BCD15 Console.ReadKey (); &#125;&#125; 自定义数字格式化字符串例子 下面的示例演示两个自定义数字格式字符串。 在这两个示例中，数字占位符 (#) 显示数值数据，且所有其他字符被复制到结果字符串。 1234567891011121314151617using System;using System.Globalization;public class Example &#123; public static void Main () &#123; double number1 = 1234567890; string value1 = number1.ToString ("(###) ###-####"); Console.WriteLine (value1); int number2 = 42; string value2 = number2.ToString ("My Number = #"); Console.WriteLine (value2); // The example displays the following output: // (123) 456-7890 // My Number = 42 &#125;&#125; 更多基本类型char （字符）类型 char 关键字用于声明 System.Char 结构的实例，.NET Framework 使用该结构来表示 Unicode 字符。 Char 对象的值为 16 位的==数字（序号）值==（见Microsoft Docs C# 参考 char）。 Unicode 字符用于表示世界各地大多数的书面语言。 类型 范围 大小 .NET Framwork char U+0000 到 U+FFFF Unicode 16 位字符 System.char 后面经常用到的 \uxxxx 转义序列，XXXX是代表某个Unicode字符的16进制编码值。通过System.Text.Encoding.UTF8.GetBytes(char[])和System.Text.UnicodeEncoding.GetBytes(String)这些方法得到的值是10进制的，需要（通过 ==标准数字格式字符串== 中的 ==X2== ）转换成16进制，就是相应的Unicode编码了。 char 可以隐式转换为 ushort、 int、 uint、 long、 ulong、 float、 double 或 decimal。 但是，不存在从其他类型到 char 类型的隐式转换。 char 类型的常数可以写成==字符==（例如 ‘x’）、==十六进制换码序列==（例如 ‘\t’）或 ==Unicode== （例如 ‘\u02C0’）表示形式。 您也可以显式转换整数字符代码。 在下面的示例中，几个 char 变量使用同一字符 X 初始化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System;using System.Text;class charType&#123; static void Main() &#123; char[] chars = new char[7]; chars[0] = 'X'; // Character literal chars[1] = '\x0058'; // Hexadecimal chars[2] = '\u0058'; // Unicode chars[3] = (char)88; // Cast from integral type chars[4] = (char)0x0058; // 转换自16进制整型 chars[5] = '\x5927'; //汉字 大 的Unicode编码 chars[6] = '大'; //汉字 大 foreach (char c in chars) &#123; Console.Write(c + " "); &#125; Console.WriteLine(); //获取汉字“大”的编码。保存为一个字节序列 byte[] bytes = Encoding.Unicode.GetBytes("大"); //得到编码的10进制字节数据 [39][89] Console.WriteLine("[&#123;0&#125;][&#123;1&#125;]", bytes[0], bytes[1]); //得到编码的16进制字节数据 [27][59] ,显示是litte-Endian方式 Console.WriteLine("[&#123;0:X2&#125;][&#123;1:X2&#125;]", bytes[0], bytes[1]); //判断 大端 Big-Endian 小端 Little-Endian if (BitConverter.IsLittleEndian) Array.Reverse(bytes); // 转换为 大端模式 结果为 [59][27] //输出 [59][27] Console.WriteLine("[&#123;0:X2&#125;][&#123;1:X2&#125;]", bytes[0], bytes[1]); Console.ReadKey(); &#125; //得到字符串中个字符(char)的Unicode编码 protected static string GetUnicode(string text) &#123; string result = ""; for (int i = 0; i &lt; text.Length; i++) &#123; if ((int)text[i] &gt; 32 &amp;&amp; (int)text[i] &lt; 127) &#123; result += text[i].ToString(); &#125; else result += string.Format("\\u&#123;0:x4&#125;", (int)text[i]); &#125; return result; &#125;&#125; 输出结果 X X X X X 大 大 [39][89] [27][59] [59][27] 高级主题：解析字符串中字符的16进制编码（Unicode）123456789101112131415using System;public class Program &#123; static void Main (string[] args) &#123; string input = "你好 大世界！Hello World!"; for (int i = 0; i &lt; input.Length; i++) &#123; // 占位符 方式 Console.Write ("&#123;0&#125; &#123;1&#125; ", input[i], ((int) input[i]).ToString ("X")); // 字符串内插 $ 方式 Console.Write ($"&#123;input[i]&#125; &#123;((int)input[i]).ToString("X")&#125; "); &#125; System.Console.WriteLine (); Console.ReadKey (); &#125;&#125; 输出结果 你 4F60 好 597D 20 大 5927 世 4E16 界 754C ！ FF01 H 48 e 65 l 6C l 6C o 6F 20 W 57 o 6F r 72 l 6C d 64 ! 21 高级主题：大端 Big-Endian 小端 Little-Endian不同的计算机结构采用不同的字节顺序存储数据。” Big-endian”表示最大的有效字节位于单词的左端。” Little-endian”表示最大的有效字节位于单词的右端。 另以一种解释 Little-Endian 就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。 Big-Endian 就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。 例子，比如数字0x12 34 56 78在内存中的表示形式为： 大端模式： 低地址 -----------------&gt; 高地址 0x12 | 0x34 | 0x56 | 0x78 小端模式： 低地址 ------------------&gt; 高地址 0x78 | 0x56 | 0x34 | 0x12 可见，大端模式和字符串的存储模式类似。 具体例子：汉字“大”（\u5927）的Unicode编码在 Little-endian 模式（以及 Big-endian 模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为： 内存地址 小端模式存放内容 大端模式存放内容 0x4000 0x27 0x59 0x4001 0x59 0x27 转义序列 escape sequence 由反斜杠 ( \ ) 后接字母或数字组合构成的字符组合称为“转义序列”。要在字符常量中表示换行符，单引号或某些其他字符，你必须使用转义序列。 转义序列被视为单个字符，因此，它是有效的字符常量。 转义序列通常用于指定操作，例如终端和打印机上的回车和制表符移动。它们还用于提供非打印字符的文本表现形式和通常具有特殊意义的字符，例如双引号 ( “ )。 下表列出 ANSI 转义序列以及它们所表示的内容。 请注意，在字符序列将被错误解释为三元组的情况下，前接反斜杠的问号 ( \?) 指定文本问号。 转义序列 含义（字符名称） Unicode Encoding（Unicode 编码） \’ 单引号 0x0027 \” 双引号 0x0022 \\ 反斜杠 0x005C \? 文本问号 \0 Null 0x0000 \a Alert 或 Bell 铃声(提醒) 0x0007 \b Backspace 退格 0x0008 \f 换页 0x000C \n 换行 0x000A \r 回车 0x000D \t 水平制表符 0x0009 \v 垂直制表符 0x000B \ ooo 在八进制表示法的 ASCII 字符 \uxxxx 16进制Unicode字符，Unicode 转义序列 \u0041 = “A” \x [h][h][h]h 16进制Unicode字符，（前三个占位符可选），\uxxxx的长度可变版本。除长度可变外，Unicode 转义序列与“\u”类似。 \u3A \x hh 以十六进制表示法的 ASCII 字符 \x hhhh 十六进制表示法的 Unicode 字符（如果此转义序列用于宽字符常量或 Unicode 字符串文本）。以十六进制表示法，则此转义序列用于常量宽字符或 Unicode 字符串的 Unicode 字符。例如，WCHAR f = L’\x4e00’ 或 WCHAR b[] = L”The Chinese character for one is \x4e00”。 \x0041 = “A” \Unnnnnnnn U代理项对的 Unicode 转义序列。 \Unnnnnnnn 字符串常规 regular 和逐字 verbatim 字符串 常规字符串 123456789101112string columns = "Column 1\tColumn 2\tColumn 3";//Output: Column 1 Column 2 Column 3string rows = "Row 1\r\nRow 2\r\nRow 3";/* Output: Row 1 Row 2 Row 3*/string title = "\"The \u00C6olean Harp\", by Samuel Taylor Coleridge";//Output: "The Æolean Harp", by Samuel Taylor Coleridge 逐字字符串 12345678910111213141516171819202122232425262728293031string filePath = @"C:\Users\scoleridge\Documents\";//Output: C:\Users\scoleridge\Documents\string text = @"My pensive SARA ! thy soft cheek reclined Thus on mine arm, most soothing sweet it is To sit beside our Cot,...";/* Output:My pensive SARA ! thy soft cheek reclined Thus on mine arm, most soothing sweet it is To sit beside our Cot,... */System.Console.Write (@"begin /\ / \ / \ / \ /________\end");/*输出begin /\ / \ / \ / \ /________\end */string quote = @"Her name was ""Sara.""";//Output: Her name was "Sara." C# 中的字符串内插（$） 借助==字符串内插==，可以将字符串中的占位符替换成字符串变量的值。 在 C# 6 中，我们最终实现了这种样式的字符串内插。 可以在字符串前面使用 $，以指明应使用变量/表达式替换相应的值。 在低于 C# 6 的版本中，使用 System.String.Format 实现字符串内插。 虽然这样做是可行的，但由于要用到编号占位符，因此加大了读取难度且过程更为冗长。 先决条件 使用==字符串内插==，必须将计算机设置为运行 ==.Net Core==。 字符串内插简介 使用 System.String.Format在字符串中指定要被字符串后面的参数替换的“==占位符==”。 例如： 1234var firstName = "Matt";var lastName = "Groves";var str = String.Format("My name is &#123;0&#125; &#123;1&#125;", firstName, lastName);Console.WriteLine(str); 输出结果 “My name is Matt Groves” 在 C# 6 中，定义内插字符串的方式为，在内插字符串前面添加 ==$== 符号，然后直接在字符串中使用变量，而不使用 String.Format。 例如： 1234var firstName = "Matt";var lastName = "Groves";var str = $"My name is &#123;firstName&#125; &#123;lastName&#125;";Console.WriteLine(str); 输出结果 “My name is Matt Groves” 不必局限于变量。 ==可以在括号内使用任意表达式==。 例如： 123for(var i = 0; i &lt; 5; i++) &#123; Console.WriteLine($"This is line number &#123;i + 1&#125;");&#125; 输出结果 This is line number 1 This is line number 2 This is line number 3 This is line number 4 This is line number 5 字符串内插的工作方式 在后台，编译器将此类字符串内插语法转换成 String.Format。 因此，可以执行之前使用 String.Format 执行的相同操作。 例如，可以添加填充和数值格式： 123456var rand = new Random();for(var i = 998; i &lt; 1005; i++)&#123; var randomDecimal = rand.NextDouble() * 10000; Console.WriteLine($"&#123;i, -10&#125; &#123;randomDecimal, 6:N2&#125;");&#125; 输出结果 998 5,177.67 999 6,719.30 1000 9,910.61 1001 529.34 1002 1,349.86 1003 2,660.82 1004 6,227.77 字符串转字符数组123456789101112131415161718192021using System;class TestRef &#123; static void Main () &#123; string a = "Hello World! 你好 大世界"; char[] b = a.ToCharArray (); for (int i = 0; i &lt; b.Length; i++) &#123; Console.Write (b[i]); &#125; // 输出 Hello World! 你好 大世界 Console.WriteLine (); Array.Reverse (b); for (int i = 0; i &lt; b.Length; i++) &#123; Console.Write (b[i]); &#125; // 输出 界世大 好你 !dlroW olleH System.Console.ReadKey (); &#125;&#125; 字符串数组123456//只有在使用字符串数组初始化字符串时，才能使用 new 运算符串讲字符串对象string[] xx = new string[8];xx[0] = "aaaa";xx[1] = "bbbb";System.Console.WriteLine(xx[0]); //输出 aaaaSystem.Console.WriteLine(xx[1]); //输出 bbbb 字符串对象的不可变性123456789string text;System.Console.Write ("Enter text: ");text = System.Console.ReadLine ();// UNEXPECTED: Does not convert text to uppercasetext.ToUpper ();System.Console.WriteLine (text); 输出结果 Enter text: This is a test of the emergency broadcast system. This is a test of the emergency broadcast system. 字符串对象是“==不可变的==”：它们在创建后无法更改。 看起来是在修改字符串的所有 String 方法和 C# 运算符实际上都是在新的字符串对象中返回结果。 因此，text.ToUpper()不会改变 text 的内容为大写，而是返回了一个新的字符串，它需要保存到变量中，或者直接传给System.Console.WriteLine()。下面代码是改进后的： 12345string text, uppercase;System.Console.Write ("Enter text: ");text = System.Console.ReadLine (); // Return a new string in uppercaseuppercase = text.ToUpper ();System.Console.WriteLine (uppercase); 输出结果 Enter text: This is a test of the emergency broadcast system. THIS IS A TEST OF THE EMERGENCY BROADCAST SYSTEM. 访问单个字符 可以使用包含索引值的数组表示法来获取对单个字符的只读访问权限，如下面的示例中所示： 1234567string s5 = "Printing backwards";for (int i = 0; i &lt; s5.Length; i++)&#123; System.Console.Write(s5[s5.Length - i - 1]);&#125;// Output: "sdrawkcab gnitnirP" 如果 String 方法不提供修改字符串中的各个字符所需的功能，可以使用 ==StringBuilder== 对象“就地”修改各个字符，再新建字符串来使用 StringBuilder 方法存储结果。 在下面的示例中，假定必须以特定方式修改原始字符串，然后存储结果以供未来使用： 1234567891011121314string question = "hOW DOES mICROSOFT wORD DEAL WITH THE cAPS lOCK KEY?";System.Text.StringBuilder sb = new System.Text.StringBuilder(question);for (int j = 0; j &lt; sb.Length; j++)&#123; if (System.Char.IsLower(sb[j]) == true) sb[j] = System.Char.ToUpper(sb[j]); else if (System.Char.IsUpper(sb[j]) == true) sb[j] = System.Char.ToLower(sb[j]);&#125;// Store the new string.string corrected = sb.ToString();System.Console.WriteLine(corrected);// Output: How does Microsoft Word deal with the Caps Lock key? 使用 StringBuilder 快速创建字符串 .NET 中的字符串操作进行了高度的优化，在大多数情况下不会显著影响性能。 但是，在某些情况下（例如，执行数百次或数千次的紧密循环），字符串操作可能影响性能。 StringBuilder 类创建字符串缓冲区，用于在程序执行多个字符串操控时提升性能。 使用 StringBuilder 字符串，还可以重新分配各个字符，而内置字符串数据类型则不支持这样做。 例如，此代码更改字符串的内容，而无需创建新的字符串： 123456System.Text.StringBuilder sb = new System.Text.StringBuilder("Rat: the ideal pet");sb[0] = 'C';System.Console.WriteLine(sb.ToString());System.Console.ReadLine();//Outputs Cat: the ideal pet 在以下示例中，StringBuilder 对象用于通过一组数字类型创建字符串： 12345678910111213141516171819class TestStringBuilder&#123; static void Main() &#123; System.Text.StringBuilder sb = new System.Text.StringBuilder(); // Create a string composed of numbers 0 - 9 for (int i = 0; i &lt; 10; i++) &#123; sb.Append(i.ToString()); &#125; System.Console.WriteLine(sb); // displays 0123456789 // Copy one character of the string (not possible with a System.String) sb[0] = sb[9]; System.Console.WriteLine(sb); // displays 9123456789 &#125;&#125; Null 字符串和空字符串 空字符串是包含零个字符的 System.String 对象实例。 空字符串常用在各种编程方案中，表示空文本字段。 可以对空字符串调用方法，因为它们是有效的 System.String 对象。 对空字符串进行了初始化，如下所示： 1string s = String.Empty; 相比较而言，null 字符串并不指 System.String 对象实例，只要尝试对 null 字符串调用方法，都会引发 NullReferenceException。 但是，可以在串联和与其他字符串的比较操作中使用 null 字符串。 以下示例说明了对 null 字符串的引用会引发和不会引发意外的某些情况： 12345678910111213141516171819202122232425262728293031323334static void Main()&#123; string str = "hello"; string nullStr = null; string emptyStr = String.Empty; string tempStr = str + nullStr; // Output of the following line: hello Console.WriteLine(tempStr); bool b = (emptyStr == nullStr); // Output of the following line: False Console.WriteLine(b); // The following line creates a new empty string. string newStr = emptyStr + nullStr; // Null strings and empty strings behave differently. The following // two lines display 0. Console.WriteLine(emptyStr.Length); Console.WriteLine(newStr.Length); // The following line raises a NullReferenceException. //Console.WriteLine(nullStr.Length); // The null character can be displayed and counted, like other chars. string s1 = "\x0" + "abc"; string s2 = "abc" + "\x0"; // Output of the following line: * abc* Console.WriteLine("*" + s1 + "*"); // Output of the following line: *abc * Console.WriteLine("*" + s2 + "*"); // Output of the following line: 4 Console.WriteLine(s2.Length);&#125; 比较字符串1234567string sCompare = "h";int result = string.Compare (sCompare, "a");System.Console.WriteLine (result); //输出 1 "h" &gt; "a" result = string.Compare (sCompare, "h", true);System.Console.WriteLine (result); //输出 0 "h" = "h" result = string.Compare (sCompare, "x", true);System.Console.WriteLine (result); //输出 -1 "h" &lt; "x" 子字符串12345678string s3 = "Visual C# Express";System.Console.WriteLine (s3.Substring (7, 2)); // Output: "C#"System.Console.WriteLine (s3.Replace ("C#", "Basic")); // Output: "Visual Basic Express"// Index values are zero-basedint index = s3.IndexOf ("C"); // index = 7 null 和 void、 null 值表明变量不引用任何有效的对象。void 表示没有类型、或者没有任何值。 null null 可以作为字符串类型的字面量。null 值只能赋给引用类型、指针类型和可空类型。变量设为null，会显式地设置引用，使它不指向任何位置。 null 不等于 “” 。”” 意味变量有一个叫做“空字符串”的值。null 以为这变量无任何值。 void 指定为 void 类型就无需传递任何数据了。void 本质上并不是一个数据类型，知识用于指出没有数据类型这一事实。 高级主题：隐式类型的局部变量 C# 3.0增加了上下文关键字 var 来声明隐式类型的局部变量。该变量在编译时仍然会接收一个类型，但该类型是由编译器提供的。 虽然允许使用 var 取代显示的数据类型，但是在数据类型已知的情况下，最好不要使用 var。 C# 3.0添加 var 的目的是支持匿名类型。匿名类型是在方法内部动态声明数据类型，而不是通过显式的类定义来生命的，如下例： 12345678910111213141516171819202122232425262728using System;using System.Text;public class SamplesString &#123; public static void Main () &#123; var patent1 = new &#123; Title = "Bifocals", YearOfPublication = "1784" &#125;; var patent2 = new &#123; Title = "Phonograph", YearOfPublication = "1877" &#125;; System.Console.WriteLine ("&#123;0&#125; (&#123;1&#125;)", patent1.Title, patent1.YearOfPublication); System.Console.WriteLine ("&#123;0&#125; (&#123;1&#125;)", patent2.Title, patent2.YearOfPublication); Console.ReadKey (); &#125;&#125; 输出结果 Bifocals (1784) Phonograph (1877) var 声明局部变量的各种方式 123456789101112131415161718192021// i is compiled as an intvar i = 5;// s is compiled as a stringvar s = "Hello";// a is compiled as int[]var a = new[] &#123; 0, 1, 2 &#125;;// expr is compiled as IEnumerable&lt;Customer&gt;// or perhaps IQueryable&lt;Customer&gt;var expr = from c in customers where c.City == "London" select c;// anon is compiled as an anonymous typevar anon = new &#123; Name = "Terry", Age = 34 &#125;;// list is compiled as List&lt;int&gt;var list = new List&lt;int&gt;(); 在以下上下文中，使用 var 关键字 在 for 初始化语句中。 1for(var x = 1; x &lt; 10; x++) 在 foreach 初始化语句中。 1foreach(var item in list)&#123;...&#125; 在 using 域间中。 1using (var file = new StreamReader("C:\\myfile.txt")) &#123;...&#125; 可空修饰符 可以为null的类型 ?C# 2.0 开始引入的这个特性，没有值表示“未定义”的意思。 可通过以下两种方式之一声明可为 null 的类型： System.Nullable&lt;T&gt; variable T? variable T 是可以为 null 的类型的基础类型。 T 可以是包括 struct 在内的任意值类型；它不能是引用类型。 可为 null 的类型示例 int? 任何值类型都可用作 作为null的类型 的基础。例如： 12345int? i = 10;double? d1 = 3.14;bool? flag = null;char? letter = 'a';int?[] arr = new int?[10]; 可为 null 的类型的成员 可以为 null 的类型的每个实例都有两个公共只读属性： ==HasValue== 类型为 bool。 如果该变量包含非 null 值，则将其设置为 true。 ==Value== 与基础类型相同。 如果 HasValue 为 true，则 Value 包含有意义的值。 如果 HasValue 是 false，则访问 Value 将引发 InvalidOperationException。 将 null 赋给值类型，在数据库编程中尤其有用。在数据表中，经常出现值类型的列允许为空的情况。除非允许包含 null 值，否则在C#代码中检索这些列并将他们的值赋给对应的字段会出现问题。可控修饰符妥善地解决了这个问题。 高级主题：null 合并运算符 ?? ?? 运算符定义一个默认值，若将一个可为 null 的类型赋给不可为 null 的类型，则会返回该值。 ?? 运算符称作 null 合并运算符 (空接合操作符)。 如果此运算符的左操作数不为 null，则此运算符将返回左操作数；否则返回右操作数。 12345int? x = null;// Set y to the value of x if x is NOT null; otherwise,// if x == null, set y to -1.int y = x ?? -1; 空接合操作符可以“链接”。例如，对于表达式 x ?? y ?? z ,如果 x 不为 null 则返回 x ；否则，如果 y 不为 null 则返回 y；否则返回 z。 高级主题：NULL条件运算符 ?. ?[用于在执行成员访问 ==(?.)== 或索引 ==(?[)== ==操作之前==，测试是否存在 NULL。 这些运算符可帮助编写更少的代码来处理 null 检查，尤其是对于下降到数据结构。 12345678int? length = customers?.Length; // null if customers is null Customer first = customers?[0]; // null if customers is null // null if customers, the first customer, or Orders is nullint? count = customers?[0]?.Orders?.Count(); // ?. 结合 ??int? len = customers?.Length ?? 0; 高级主题：条件运算符 ?:条件运算符 ?: 根据 Boolean 表达式的值返回两个值之一。下面是条件运算符的语法。 condition ? first_expression : second_expression; condition 的计算结果必须为 true 或 false。 如果 condition 为 true，则将计算 first_expression 并使其成为结果。 如果 condition 为 false，则将计算 second_expression 并使其成为结果。 只计算两个表达式之一。first_expression 和 second_expression 的类型必须相同，或者必须存在从一种类型到另一种类型的隐式转换。 你可通过使用条件运算符表达可能更确切地要求 if-else 构造的计算。 例如，以下代码首先使用 if 语句，然后使用条件运算符将整数分类为正整数或负整数。 1234567891011int input = Convert.ToInt32(Console.ReadLine());string classify;// if-else construction.if (input &gt; 0) classify = "positive";else classify = "negative";// ?: conditional operator.classify = (input &gt; 0) ? "positive" : "negative"; 条件运算符为右联运算符。 表达式 a ? b : c ? d : e 作为 a ? b : (c ? d : e) 而非 (a ? b : c) ? d : e 进行计算。 无法重载条件运算符。 类型的分类值类型C# 中有两种类型：==引用类型==和==值类型==。 引用类型的变量存储对其数据（对象）的引用，而值类型的变量直接包含其数据。 对于引用类型，两种变量可引用同一对象；因此，对一个变量执行的操作会影响另一个变量所引用的对象。 对于值类型，每个变量都具有其自己的数据副本，对一个变量执行的操作不会影响另一个变量（ref 和 out 参数变量除外，请参阅 ref 和 out 参数修饰符）。 值类型直接包含值，变量引用的位置就是值在内存中的实际存储位置。 将一个变量的值赋给另一个变量会导致在新变量的位置创建原始变量值的一个内存副本。 类似的，将值类型的示例传给方法，如 Console.WriteLine(),也会产生一个内存副本。 由于值类型需要创建内存副本，因此定义时不要让它们占用太多内存（通常应该给小于16字节）。 引用类型 引用类型的变量存储的时对数据存储位置的引用，而不是直接存储数据。 数据类型 转换显式转换（explicit conversions | casts | 强制转换） 显式转换需要强制转换运算符。在==转换中可能丢失信息时或在出于其他原因转换可能不成功==时，必须进行强制转换。 典型的示例包括从数值到精度较低或范围较小的类型的转换和从基类实例到派生类的转换。 如果进行转换可能会导致信息丢失，则编译器会要求执行显式转换，显式转换也称为强制转换。 强制转换是显式告知编译器你打算进行转换且你知道可能会发生数据丢失的一种方式。 若要执行强制转换，请在要转换的值或变量前面的括号中指定要强制转换到的类型。下面的程序将 double 强制转换为 int。==如不强制转换则该程序不会进行编译==。 123456789101112class Test&#123; static void Main() &#123; double x = 1234.7; int a; // Cast double to int. a = (int)x; System.Console.WriteLine(a); &#125;&#125;// Output: 1234 有关支持的显式数值转换的列表，请参阅显式数值转换表。 高级主题：checked 和 unchecked 转换 在 cheecked 块内，如果在运行时发生一次溢出的赋值，就会引发异常。 123456789101112131415using System;using System.Text;public class Program &#123; public static void Main () &#123; checked &#123; // int.MaxValue equals 2147483647 int n = int.MaxValue; n = n + 1; System.Console.WriteLine (n); &#125; Console.ReadKey (); &#125;&#125; 输出结果 未经处理的异常: System.OverflowException: 算术运算导致溢出。 在 Program.Main() unchecked 块，强制不进行一处检查，不会为块中溢出的赋值引发异常。 123456789101112131415using System;using System.Text;public class Program &#123; public static void Main () &#123; unchecked &#123; // int.MaxValue equals 2147483647 int n = int.MaxValue; n = n + 1; System.Console.WriteLine (n); &#125; Console.ReadKey (); &#125;&#125; 输出结果 -2147483648 隐式转换（implicit conversions） 由于该转换是一种类型==安全的转换，不会导致数据丢失==，因此不需要任何特殊的语法。 对于内置数值类型，如果要存储的值==无需截断或四舍五入==即可适应变量，则可以进行隐式转换。 例如，long 类型的变量（8 字节整数）能够存储 int（在 32 位计算机上为 4 字节）可存储的任何值。 隐式转换无需使用转换操作符 12int intNumber = 31416;long longNumber = intNumber; 隐式转换 也可以强制添加转换操作符 12int intNumber = 31416;long longNumber = (long) intNumber; 不使用转型操作符的类型转换 ==字符串到数值类型== 转换，需要使用 Parse()/TryParse() 这样的方法。每个数值类型都包含 Parse()/TryParse() 方法，它允许将字符串还换成对应的数值类型。 例子 12string text = "9.11E-31";float kgElectronMass = float.Parse(text); 还可以利用 ==特殊类型System.Convert== 将一种类型转换成另一种类型。不过，System.Convert只支持预定义类型，而且是不可扩展的。它允许从任何==基元(基本)类型==（bool, char, sbyte, short, int, long, ushort, uint, ulong, float, double, decimal, DateTime, and string）转换到任何其它基元(基本)类型。参考 MSDN Convert.aspx) 类。 例子 123string middleCText = "261.626";double middleC = System.Convert.ToDouble(middleCText);bool boolean = System.Convert.ToBoolean(middleC); 除了以上方法，所有类型都支持==ToString()方法== 转换，可以用它得到一个类型的值的字符串表示。 例子 1234567bool boolean = true;string text = boolean.ToString();System.Console.WriteLine(text); // Display "True"double dVal = -1.123456;text=dVal.ToString();System.Console.WriteLine(dVal);// Display "-1.123456" 高级主题：TryParse()从 C# 2.0 开始，所有基元数据数据类型都包含静态 TryParse() 方法。该方法与 Parse() 非常相似，知识在缓缓失败的清康熙，它不引发异常，而是返回 false ，如下示例： 12345678910111213141516double number;string input;System.Console.Write("Enter a number: ");input = System.Console.ReadLine();if (double.TryParse(input, out number))&#123; // Converted correctly, now use number // ...&#125;else&#123; System.Console.WriteLine( "The text entered was not a valid number.");&#125; 高级主题：字符串转换为数字 字符串转数字的几种方法： Parse 转换对象必须是组成合适数值类型（int、long、ulong、float、decimal 等）的字符。(例如：Int32.Parse(“-15”)) TryParse 转换对象必须是组成合适数值类型（int、long、ulong、float、decimal 等）的字符。（例如：Int32.TryParse(“-15”, out j)） Convert.ToInt32 针对各种数值类型(int、long、float等，例如：Convert.ToInt32(“-15”)) 如果你具有字符串，则调用 TryParse 方法（例如 int.TryParse(“11”)）会稍微更加高效且简单。 使用 Convert 方法对于实现 IConvertible 的常规对象更有用。 可以对预期字符串会包含的数值类型（如 ==System.Int32== 类型）使用 Parse 或 TryParse 方法。 Convert.ToUInt32 方法在内部使用 Parse。 如果字符串的格式无效，则 Parse 会引发异常，而 TryParse 会返回 false。 示例 Parse 和 TryParse 例：System.Int32.Parse ==Parse 和 TryParse== 方法会忽略字符串开头和末尾的空格，但所有其他字符必须是组成合适数值类型（int、long、ulong、float、decimal 等）的字符。 组成数字的字符中的任何空格都会导致错误。 例如，可以使用 decimal.TryParse 分析“10”、“10.3”、“ 10 ”，但不能使用此方法分析从“10X”、“1 0”（注意空格）、“10 .3”（注意空格）、“10e1”（float.TryParse 在此处适用）等中分析出 10。 下面的示例演示了对 Parse 和 TryParse 的成功调用和不成功的调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections;using System.Collections.Generic;using System.Linq;public class Program &#123; public static void Main () &#123; int numVal = Int32.Parse ("-105"); Console.WriteLine (numVal); // Output: -105 double dVal = Double.Parse("105.12345"); Console.WriteLine(dVal); // 输出 105.12345 // TryParse returns true if the conversion succeeded // and stores the result in j. int j; if (Int32.TryParse ("-105", out j)) Console.WriteLine (j); else Console.WriteLine ("String could not be parsed."); // Output: -105 try &#123; int m = Int32.Parse ("abc"); &#125; catch (FormatException e) &#123; Console.WriteLine (e.Message); &#125; // Output: Input string was not in a correct format. string inputString = "abc"; int numValue; bool parsed = Int32.TryParse (inputString, out numValue); if (!parsed) Console.WriteLine ("Int32.TryParse could not parse '&#123;0&#125;' to an int.\n", inputString); // Output: Int32.TryParse could not parse 'abc' to an int. Console.ReadKey (); &#125;&#125; 示例 Convert 例：System.Convert.ToInt32 下表列出了 Convert 类中可使用的一些方法。 数值类型 方法 decimal ToDecimal(String) float ToSingle(String) double ToDouble(String) short ToInt16(String) int ToInt32(String) long ToInt64(String) ushort ToUInt16(String) uint ToUInt32(String) ulong ToUInt64(String) 此示例调用 Convert.ToInt32(String) 方法将输入的 string 转换为 int。 代码将捕获此方法可能引发的最常见的两个异常：FormatException 和 OverflowException。 如果该数字可以递增而不溢出整数存储位置，则程序使结果加上 1 并打印输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System;using System.Collections;using System.Collections.Generic;using System.Linq;public class Program &#123; static void Main (string[] args) &#123; int numVal = -1; bool repeat = true; while (repeat) &#123; Console.WriteLine ("Enter a number between −2,147,483,648 and +2,147,483,647 (inclusive)."); string input = Console.ReadLine (); // ToInt32 can throw FormatException or OverflowException. try &#123; numVal = Convert.ToInt32 (input); &#125; catch (FormatException e) &#123; Console.WriteLine ("Input string is not a sequence of digits."); &#125; catch (OverflowException e) &#123; Console.WriteLine ("The number cannot fit in an Int32."); &#125; finally &#123; if (numVal &lt; Int32.MaxValue) &#123; Console.WriteLine ("The new value is &#123;0&#125;", numVal + 1); &#125; else &#123; Console.WriteLine ("numVal cannot be incremented beyond its current value"); &#125; &#125; Console.WriteLine ("Go again? Y/N"); string go = Console.ReadLine (); if (go == "Y" || go == "y") &#123; repeat = true; &#125; else &#123; repeat = false; &#125; &#125; // Keep the console open in debug mode. Console.WriteLine ("Press any key to exit."); Console.ReadKey (); &#125; // Sample Output: // Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive). // 473 // The new value is 474 // Go again? Y/N // y // Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive). // 2147483647 // numVal cannot be incremented beyond its current value // Go again? Y/N // Y // Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive). // -1000 // The new value is -999 // Go again? Y/N // n // Press any key to exit.&#125; 高级主题：字节数组转换为数字 BitConverter 此示例演示如何使用 BitConverter 类将字节数组转换为 int 然后又转换回字节数组。 例如，在从网络读取字节之后，可能需要将字节转换为内置数据类型。 除了示例中的 ToInt32(Byte[],Int32) 方法之外，下表还列出了 BitConverter 类中将字节（来自字节数组）转换为其他内置类型的方法。 返回类型 方法 bool ToBoolean(Byte[],Int32) char ToChar(Byte[],Int32) double ToDouble(Byte[],Int32) short ToInt16(Byte[],Int32) int ToInt32(Byte[],Int32) long ToInt64(Byte[],Int32) float ToSingle(Byte[],Int32) ushort ToUInt16(Byte[],Int32) uint ToUInt32(Byte[],Int32) ulong ToUInt64(Byte[],Int32) Returns a 32-bit signed integer converted from four bytes at a specified position in a byte array. 1public static int ToInt32 (byte[] value, int startIndex); 示例 BitConverter.ToInt32 此示例初始化字节数组，并在计算机体系结构为 ==little-endian==（即首先存储最低有效字节）的情况下==反转数组==，然后调用 ToInt32(Byte[],Int32) 方法以将数组中的四个字节转换为 int。 ToInt32(Byte[],Int32) 的第二个参数指定字节数组的起始索引。 12345678910byte[] bytes = &#123; 0, 0, 0, 25 &#125;;// If the system architecture is little-endian (that is, little end first),// reverse the byte array.if (BitConverter.IsLittleEndian) Array.Reverse(bytes);int i = BitConverter.ToInt32(bytes, 0);Console.WriteLine("int: &#123;0&#125;", i);// Output: int: 25 示例 BitConverter.GetBytes 在本示例中，将调用 BitConverter 类的 GetBytes(Int32) 方法，将 int 转换为字节数组。 123byte[] bytes = BitConverter.GetBytes(201805978);Console.WriteLine("byte array: " + BitConverter.ToString(bytes));// Output: byte array: 9A-50-07-0C 高级主题：十六进制字符串与数值类型之间转换 以下示例演示如何执行下列任务： 获取字符串中每个字符的十六进制值。 获取与十六进制字符串中的每个值对应的 char。 将十六进制 string 转换为 int。 将十六进制 string 转换为 float。 将字节数组转换为十六进制 string。&gt; - 示例 解析字符得到16进制值此示例输出 string 中每个字符的十六进制值。 123456789101112131415using System;public class Program &#123; static void Main (string[] args) &#123; string input = "你好 大世界！Hello World!"; for (int i = 0; i &lt; input.Length; i++) &#123; // 占位符 方式 //Console.Write ("&#123;0&#125; &#123;1&#125; ", input[i], ((int) input[i]).ToString ("X")); // 字符串内插 $ 方式 Console.Write ($"&#123;input[i]&#125; &#123;((int)input[i]).ToString("X")&#125; "); &#125; System.Console.WriteLine (); Console.ReadKey (); &#125;&#125; 你 4F60 好 597D 20 大 5927 世 4E16 界 754C ！ FF01 H 48 e 65 l 6C l 6C o 6F 20 W 57 o 6F r 72 l 6C d 64 ! 21 示例 从16进制值得到对应字符此示例分析十六进制值的 string 并输出对应于每个十六进制值的字符。 首先，调用 Split(Char[]) 方法以获取每个十六进制值作为数组中的单个 string。 然后，调用 ToInt32(String, Int32)将十六进制值转换为表示为 int 的十进制值。示例中演示了 2 种不同方法，用于获取对应于该字符代码的字符。 第 1 种方法是使用 ConvertFromUtf32(Int32)，它将对应于整型参数的字符作为 string 返回。 第 2 种方法是将 int 显式转换为 char。 1234567891011121314151617181920212223using System;public class Program &#123; static void Main (string[] args) &#123; //将指定的 Unicode 码位转换为 UTF-16 编码字符串。 string hexValues = "5927 20 48 65 6C 6C 6F 20 57 6F 72 6C 64 21"; // 大 Hello World！ string[] hexValuesSplit = hexValues.Split(' '); for (int i = 0; i &lt; hexValuesSplit.Length; i++) &#123; // 将 16 进制数值 转换为 整型（10进制） int value = Convert.ToInt32(hexValuesSplit[i], 16); // 得到 编码值对应的 字符 | 将指定的 Unicode 码位转换为 UTF-16 编码字符串。 string stringValule = char.ConvertFromUtf32(value); System.Console.Write(stringValule); //一句话表示，有点难于解读 //System.Console.Write(char.ConvertFromUtf32(Convert.ToInt32(hexValuesSplit[i],16))); &#125; System.Console.WriteLine (); Console.ReadKey (); &#125;&#125; 输出结果 大 Hello World! 数组可以将同一类型的多个变量存储在一个数组数据结构中。 通过指定数组的元素类型来声明数组。 type[] arrayName; 数组具有以下属性： 数组可以是一维(==Single-Dimesional==)、多维(==Multidimesional==)或交错(==Jagged==)的。 创建数组实例时，将建立纬度数量和每个纬度的长度。这些值在实例的生存期内无法更改。 交错数组是数组的数组,因此其元素为引用类型且被初始化为null。 数组从零开始编制索引：包含 n 元素的数组从 0 索引到 n-1。 数组元素可以是任何类型，其中包括数组类型。 数组的维数使用 Rank 属性显示数组的维数。 1234// Declare and initialize an array:int[,] theArray = new int[5, 10];// 输出 这是一个 2 维数组。System.Console.WriteLine("这是一个 &#123;0&#125; 维数组。", theArray.Rank); 一维数组数组声明 一维 声明五个整数的一维数组，如以下示例所示： 1int[] array = new int[5]; 此数组包含从 array[0] 到 array[4] 的元素。 new 运算符用于创建数组并将数组元素初始化为其默认值。在此示例中，所有数组元素都将被==初始化为零==。 声明字符串数组 1string[] stringArray = new string[6]; 数组初始化 一维12int[] array1 = new int[] &#123; 1, 3, 5, 7, 9 &#125;;string[] weekDays = new string[] &#123; "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" &#125;; 声明初始化的缩写(快捷)方式 12int[] array1 = &#123; 1, 3, 5, 7, 9 &#125;;string[] weekDays = &#123; "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" &#125;; 可以在不初始化的情况下声明数组变量，但必须使用 new 运算符向此变量分配数组。 例如: 123int[] array3;array3 = new int[] &#123; 1, 3, 5, 7, 9 &#125;; // OK//array3 = &#123;1, 3, 5, 7, 9&#125;; // Error 多维数组 多为数组的每一维的大小都必须一致。而 ==交错数组== （jagged array）则不需要。 得到多维数组中某一维的长度，不是使用Length属性，而是使用数组的GetLength()示例方法。 123bool[,,] cells;cells = new bool[2,3,3];System.Console.WriteLine(cells.GetLength(0)); // Displays 2 数组声明 多维1234// 声明创建一个具有四行两列的二维数组。int[,] array = new int[4, 2];// 声明创建一个具有三个维度（4、2 和 3）的数组。int[, ,] array1 = new int[4, 2, 3]; 数组初始化 多维 声明后即可初始化数组，如以下示例所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243// Two-dimensional array.int[,] array2D = new int[,] &#123; &#123; 1, 2 &#125;, &#123; 3, 4 &#125;, &#123; 5, 6 &#125;, &#123; 7, 8 &#125; &#125;;// The same array with dimensions specified.int[,] array2Da = new int[4, 2] &#123; &#123; 1, 2 &#125;, &#123; 3, 4 &#125;, &#123; 5, 6 &#125;, &#123; 7, 8 &#125; &#125;;// A similar array with string elements.string[,] array2Db = new string[3, 2] &#123; &#123; "one", "two" &#125;, &#123; "three", "four" &#125;, &#123; "five", "six" &#125; &#125;;// Three-dimensional array.int[, ,] array3D = new int[,,] &#123; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125; &#125;, &#123; &#123; 7, 8, 9 &#125;, &#123; 10, 11, 12 &#125; &#125; &#125;;// The same array with dimensions specified.int[, ,] array3Da = new int[2, 2, 3] &#123; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125; &#125;, &#123; &#123; 7, 8, 9 &#125;, &#123; 10, 11, 12 &#125; &#125; &#125;;// Accessing array elements.System.Console.WriteLine(array2D[0, 0]);System.Console.WriteLine(array2D[0, 1]);System.Console.WriteLine(array2D[1, 0]);System.Console.WriteLine(array2D[1, 1]);System.Console.WriteLine(array2D[3, 0]);System.Console.WriteLine(array2Db[1, 0]);System.Console.WriteLine(array3Da[1, 0, 1]);System.Console.WriteLine(array3D[1, 1, 2]);// Getting the total count of elements or the length of a given dimension.var allLength = array3D.Length;var total = 1;for (int i = 0; i &lt; array3D.Rank; i++) &#123; total *= array3D.GetLength(i);&#125;System.Console.WriteLine("&#123;0&#125; equals &#123;1&#125;", allLength, total);// Output:// 1// 2// 3// 4// 7// three// 8// 12// 12 equals 12 交错数组 jagged array 交错数组是元素为数组的数组。 交错数组元素的维度和大小可以不同。 交错数组有时称为“数组的数组”。 123456int[][] cells = &#123; new int[]&#123;1, 0, 2, 0&#125;, new int[]&#123;1, 2, 0&#125;, new int[]&#123;1, 2&#125;, new int[]&#123;1&#125;&#125;; 声明一个具有三个元素的一维数组，其中每个元素都是一维整数数组： 1int[][] jaggedArray = new int[3][]; 必须初始化 jaggedArray 的元素后才可使用它。 可按下方操作初始化元素： 123jaggedArray[0] = new int[5];jaggedArray[1] = new int[4];jaggedArray[2] = new int[2]; 每个元素都是一维整数数组。 第一个元素是由 5 个整数组成的数组，第二个是由 4 个整数组成的数组，而第三个是由 2 个整数组成的数组。 也可使用初始化表达式通过值来填充数组元素，这种情况下不需要数组大小。 例如: 123jaggedArray[0] = new int[] &#123; 1, 3, 5, 7, 9 &#125;;jaggedArray[1] = new int[] &#123; 0, 2, 4, 6 &#125;;jaggedArray[2] = new int[] &#123; 11, 22 &#125;; 还可在声明数组时将其初始化，如： 12345int[][] jaggedArray2 = new int[][] &#123; new int[] &#123; 1, 3, 5, 7, 9 &#125;, new int[] &#123; 0, 2, 4, 6 &#125;, new int[] &#123; 11, 22 &#125;&#125;; 可以使用下面的缩写形式。 请注意：不能从元素初始化中省略 new 运算符，因为不存在元素的默认初始化： 12345int[][] jaggedArray3 = &#123; new int[] &#123; 1, 3, 5, 7, 9 &#125;, new int[] &#123; 0, 2, 4, 6 &#125;, new int[] &#123; 11, 22 &#125;&#125;; 可以混合使用交错数组和多维数组。 下面声明和初始化一个包含大小不同的三个二维数组元素的一维交错数组。 123456int[][,] jaggedArray4 = new int[3][,] &#123; new int[,] &#123; &#123;1,3&#125;, &#123;5,7&#125; &#125;, new int[,] &#123; &#123;0,2&#125;, &#123;4,6&#125;, &#123;8,10&#125; &#125;, new int[,] &#123; &#123;11,22&#125;, &#123;99,88&#125;, &#123;0,9&#125; &#125; &#125;; 可以如本例所示访问个别元素，示例显示第一个数组的元素 [1,0] 的值（值为 5）： 1System.Console.Write("&#123;0&#125;", jaggedArray4[0][1, 0]); 方法 Length 返回包含在交错数组中的数组的数目。例如，假定已声明了前一个数组，则下行返回值 3。 1System.Console.WriteLine(jaggedArray4.Length); 隐式类型的数组 可以创建隐式类型化的数组，其中数组实例的类型通过数组初始值设定项中指定的元素来推断。 针对隐式类型化变量的任何规则也适用于隐式类型化数组。 12345678910111213141516171819202122class ImplicitlyTypedArraySample&#123; static void Main() &#123; var a = new[] &#123; 1, 10, 100, 1000 &#125;; // int[] var b = new[] &#123; "hello", null, "world" &#125;; // string[] // single-dimension jagged array var c = new[] &#123; new[]&#123;1,2,3,4&#125;, new[]&#123;5,6,7,8&#125; &#125;; // jagged array of strings var d = new[] &#123; new[]&#123;"Luca", "Mads", "Luke", "Dinesh"&#125;, new[]&#123;"Karen", "Suma", "Frances"&#125; &#125;; &#125;&#125; 在上个示例中，请注意对于隐式类型化数组，初始化语句的左侧没有使用方括号。 另请注意，和一维数组一样，通过使用 new [] 来初始化交错数组。 对数组使用循环 for foreach 一维数组 123456int[] numbers = &#123; 4, 5, 6, 1, 2, 3, -2, -1, 0 &#125;;foreach (int i in numbers)&#123; System.Console.Write("&#123;0&#125; ", i);&#125;// Output: 4 5 6 1 2 3 -2 -1 0 多维数组 123456789int[,] numbers2D = new int[3, 2] &#123; &#123; 9, 99 &#125;, &#123; 3, 33 &#125;, &#123; 5, 55 &#125; &#125;;// Or use the short form:// int[,] numbers2D = &#123; &#123; 9, 99 &#125;, &#123; 3, 33 &#125;, &#123; 5, 55 &#125; &#125;;foreach (int i in numbers2D)&#123; System.Console.Write("&#123;0&#125; ", i);&#125;// Output: 9 99 3 33 5 55 交错数组 123456789101112int[][] jaggedArray3 = &#123; new int[] &#123; 1, 3, 5, 7, 9 &#125;, new int[] &#123; 0, 2, 4, 6 &#125;, new int[] &#123; 11, 22 &#125;&#125;;foreach (var item in jaggedArray3) &#123; for (int i = 0; i &lt; item.Length; i++) &#123; System.Console.Write ("&#123;0&#125; ", item[i]); &#125;&#125;// 输出：1 3 5 7 9 0 2 4 6 11 22 常见数组编码错误代码中包含双重大括号，hexo无法编译，用转义的话Markdown文件不利阅读，所以采用图片替代。 枚举类型声明定义enum 关键字用于声明枚举，一种包含一组被称为枚举数列表的已命名常数的不同类型。通常最好是直接在命名空间内定义枚举，以便命名空间中的所有类都可以同样方便地访问它。 但是，也可能会在类或结构中嵌套枚举。默认情况下，枚举中每个元素的==基础类型都为 int==。默认情况下，==第一个枚举数具有值 0==，并且每个连续枚举数的值将增加 1。 例如，在以下枚举中， Sat 的值为 0， Sun 的值为 1， Mon 的值为 2，依次类推。 1enum Days &#123;Sat, Sun, Mon, Tue, Wed, Thu, Fri&#125;; 枚举数可以使用初始值设定项来替代默认值，如下面的示例中所示。 1enum Days &#123;Sat=1, Sun, Mon, Tue, Wed, Thu, Fri&#125;; 在此枚举中，强制元素的序列从 1 开始，而不是 0。 但建议包括一个值为 0 的常量。 有关详细信息，请参阅枚举类型。 每个枚举类型都有一个基础类型，该基础类型可以是除 char 外的任何整型类型。 枚举元素的默认基础类型是 int。若要声明另一整型的枚举（如 byte），则请在后跟该类型的标识符后使用冒号，如以下示例所示。 1enum Days : byte &#123;Sat=1, Sun, Mon, Tue, Wed, Thu, Fri&#125;; 枚举的已批准类型有 byte、 sbyte、 short、 ushort、 int、 uint、 long或 ulong。有关可能的类型的完整列表，请参阅 enum（C# 参考）。 基础类型指定为每个枚举数分配多少存储空间。 但要将 enum 类型转换为整型，==则必须使用显示转换==。 例如，以下语句通过使用转换将 Sun 转换为 ，从而将枚举数 赋值为 enum int int类型的变量。 1int x = (int)Days.Sun; 可以为枚举类型的枚举器列表中的元素分配任何值，也==可以使用计算值==，计算因子必须是已经有确定的值的枚举元素，不能包含后面的值未确定的元素： 12345678910111213141516171819202122232425262728293031using System;public class EnumTest&#123; enum Day &#123; Sunday=6, Monday=3, Tuesday = Sunday + Monday, Wednesday, Thursday, Friday, Saturday &#125;; static void Main() &#123; Console.WriteLine(Day.Sunday); Console.WriteLine(Day.Friday); Console.WriteLine((int)Day.Sunday); Console.WriteLine((int)Day.Monday); Console.WriteLine((int)Day.Tuesday); Console.WriteLine((int)Day.Wednesday); Console.WriteLine((int)Day.Thursday); Console.WriteLine((int)Day.Friday); Console.WriteLine((int)Day.Saturday); Console.ReadKey(); &#125;&#125;/* 输出SundayFriday63910111213*/ 使用 System.Enum 方法来发现和操作枚举值12345678910string s = Enum.GetName(typeof(Days), 16);Console.WriteLine(s);Console.WriteLine("The values of the Day Enum are:");foreach (int i in Enum.GetValues(typeof(Days))) Console.WriteLine(i);Console.WriteLine("The names of the Day Enum are:");foreach (string str in Enum.GetNames(typeof(Days))) Console.WriteLine(str); 输出结果 Thursday The values of the Day Enum are: 0 1 2 4 8 16 32 64 The names of the Day Enum are: None Sunday Monday Tuesday Wednesday Thursday Friday Saturday 高级主题：作为位标志的枚举类型创建==位标志枚举==的方法是，应用 FlagsAttribute 属性并适当定义一些值，以便可以对这些值执行 AND、OR、NOT 和 XOR 按位运算。 在位标志枚举中，包括一个值为零（表示“未设置任何标志”）的命名常量。 如果零值不表示“未设置任何标志”，请勿为标志指定零值。 在以下示例中，定义了名为 Days 枚举的另一个版本。 Days 具有 Flags 属性，且它的每个值都是 2 的若干次幂，指数依次递增。 这样，你就能够创建值为 Days.Tuesday | Days.Thursday 的 Days 变量。 12345678910111213141516[Flags]enum Days&#123; None = 0x0, Sunday = 0x1, Monday = 0x2, Tuesday = 0x4, Wednesday = 0x8, Thursday = 0x10, Friday = 0x20, Saturday = 0x40&#125;class MyClass&#123; Days meetingDays = Days.Tuesday | Days.Thursday;&#125; 若要在枚举上设置标志，请使用按位 OR 运算符，如以下示例所示： 12345678910111213// Initialize with two flags using bitwise OR.meetingDays = Days.Tuesday | Days.Thursday;// Set an additional flag using bitwise OR.meetingDays = meetingDays | Days.Friday;Console.WriteLine("Meeting days are &#123;0&#125;", meetingDays);// Output: Meeting days are Tuesday, Thursday, Friday// Remove a flag using bitwise XOR.meetingDays = meetingDays ^ Days.Tuesday;Console.WriteLine("Meeting days are &#123;0&#125;", meetingDays);// Output: Meeting days are Thursday, Friday 若要确定是否设置了特定标志，请使用按位 AND 运算，如以下示例所示： 1234// Test value of flags using bitwise AND.bool test = (meetingDays &amp; Days.Thursday) == Days.Thursday;Console.WriteLine("Thursday &#123;0&#125; a meeting day.", test == true ? "is" : "is not");// Output: Thursday is a meeting day. 结尾]]></content>
      <tags>
        <tag>C#</tag>
        <tag>C#本质论</tag>
        <tag>Essential C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#本质论笔记 第1章 C#概述]]></title>
    <url>%2F2017%2F12%2F13%2FCSharp%E6%9C%AC%E8%B4%A8%E8%AE%BA%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0-CSharp%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[HelloWorld本书中的例子1234567class HelloWorld&#123; static void Main() &#123; System.Console.WriteLine("Hello World!"); &#125;&#125; 其他例子123456789using System;class Hello&#123; static void Main() &#123; Console.WriteLine("Hello World!"); &#125;&#125; VS IDE自动生成例子12345678910111213141516using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace HelloWorld&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("Hello World!"); &#125; &#125;&#125; 语法基础标识符大小写风格Pacal风格 (PascalCase/Pascal case) 每个单词首字母大写，例如：ComponentModel, Configuration, and HttpFileCollection. 注意在 HttpFileCollection中，由于首字母缩写词HTTP的长度超过两个字母，所以仅首字母大写。 camel风格 (camelCase/camel Case) 除了第一个字母小写，其他约定与Pascal大小写放个一样，例如：quotient, firstName, httpFileCollection, ioStream, and theDreadPirateRoberts. 形参与实参12345678910111213141516namespace ConsoleApplication&#123; class Program &#123; static void Main(string[] args) &#123; int a = 5; abc(a); //a就是实参 &#125; static int abc(int c) //c就是形参 &#123; return 5; &#125; &#125;&#125; Main Main 方法是 C# 控制台应用程序或窗口应用程序的入口点。 （库和服务不要求将 Main 方法作为入口点。） 应用程序启动时，Main 方法是第一个调用的方法。 C# 程序中只能有一个入口点。 如果您有多个类都包含 Main 方法，则必须使用 /main 编译器选项编译您的程序，以指定用作入口点的 Main 方法。 不带参数的Main12345678class Hello&#123; static void Main() &#123; System.Console.WriteLine("Hello World!"); System.Console.ReadKey(); &#125;&#125; 带参数的Main12345678class Hello&#123; static void Main(string[] args) &#123; System.Console.WriteLine("Hello World!"); System.Console.ReadKey(); &#125;&#125; Main 概述 Main 方法是 .exe 程序的入口点，程序控制流在该处开始和结束。 Main 在类或结构内声明。 Main 必须是静态的，且不应该是 公用的。 （在前面的示例中，它接受默认访问级别 private。）但不要求封闭类或结构是静态的。 Main 的返回类型有两种：void 或 int。 所声明的 Main 方法可以具有包含命令行实参的 string[] 形参，也可以不具有这样的形参。 使用 Visual Studio 创建 Windows 窗体应用程序时，可以手动添加形参，也可以使用 Environment 类获取命令行实参。 形参读取为从零开始编制索引的命令行实参。 与 C 和 C++ 不同，不会将程序名称视为第一个命令行实参。 Main 例子12345678910111213class Hello&#123; static void Main(string[] args) &#123; System.Console.WriteLine("Hello World!"); System.Console.WriteLine(args.Length); System.Console.WriteLine(System.Environment.CommandLine); System.Console.WriteLine(System.Environment.CurrentDirectory); System.Console.WriteLine(System.Environment.MachineName); System.Console.WriteLine(System.Environment.UserName); System.Console.ReadKey(); &#125;&#125; 编译上面代码，在控制台输入 ==HelloWorld.exe== 输出结果 Hello World! 0 helloworld.exe D:\WaProj\Essential C#5.0, 4th Edition\第一章 DESKTOP-D10TF3C ihome 编译上面代码，在控制台输入 ==HelloWorld== 输出结果 Hello World! 0 helloworld D:\WaProj\Essential C#5.0, 4th Edition\第一章 DESKTOP-D10TF3C ihome 单行多行语句一行包含多条语句1System.Console.WriteLine("1");System.Console.WriteLine("2"); 输出结果 1 2 一条语句跨越多行12System.Console.WriteLine( "Hello World!"); 输出结果 Hello World! 错误示例12System.Console.WriteLine("Hello World!"); 错误提示 HelloWorld.cs(5,31): error CS1010: 常量中有换行符 HelloWorld.cs(6,12): error CS1010: 常量中有换行符 缩进和空白 例子1 12345678class Hello&#123; static void Main() &#123; System.Console.WriteLine("Hello World!"); System.Console.ReadKey(); &#125;&#125; 例子2 1class Hello&#123;static void Main()&#123;System.Console.WriteLine("Hello World!");System.Console.ReadKey();&#125;&#125; 上面两个例子输出结果相同，对编译器来说无差别。 变量声明与赋值1234567891011121314151617181920212223242526class Hello&#123; static void Main() &#123; string valerie; //定义变量并赋值 string max = "Have fun storming the castle!"; valerie = "Think it will work?"; System.Console.WriteLine(max); System.Console.WriteLine(valerie); //重新赋值 max = "It would take a miracle."; System.Console.WriteLine(max); string boys,girls; //多赋值操作 boys = girls = "We Are Young."; System.Console.WriteLine(boys); System.Console.WriteLine(girls); System.Console.ReadKey(); &#125;&#125; 输出结果 Have fun storming the castle! Think it will work? It would take a miracle. We Are Young. We Are Young. 高级主题：字符串不可变所有string类型数据，都是不可变的（或者说不可修改的），例如：不可能将字符串“We Are Yong.”修改为“We Are Old.”。也就是说，不能修改变量最初引用的数据，只能重新赋值，让它指向内存中的新位置。 控制台输入输出从控制台获取输入使用System.Console.ReadLine()1234567891011121314151617class Hello&#123; static void Main() &#123; string firstName; string lastName; System.Console.Write("Enter your first name: "); firstName = System.Console.ReadLine(); System.Console.Write("Enter your last name: "); lastName = System.Console.ReadLine(); System.Console.WriteLine("Hello " + firstName + " " + lastName); System.Console.ReadKey(); &#125;&#125; 输出结果 Enter your first name: Jon Enter your last name: Snow Hello Jon Snow 高级主题：System.Console.Read() System.Console.Read()方法返回的是与读取的字符值对应的证书，如果没有更多的字符可用，就返回-1。为了获取实际字符，需要先将证书转型为字符，代码如下： 代码示例 11234567891011121314class Hello&#123; static void Main() &#123; int readValue; char character; readValue = System.Console.Read(); character = (char) readValue; System.Console.WriteLine(character); System.Console.ReadKey(); &#125;&#125; System.Console.Read() 从标准输入流读取下一个字符。 System.Console.ReadKey() 获取用户按下的下一个字符或功能键。 按下的键显示在控制台窗口中。 按回车键之前，System.Console.Read()方法不会返回输入，即使用户输入了多个字符。 输入 123，按回车，再输入 a，输出结果 123 1 a 代码示例 21234567891011121314151617181920class Hello&#123; static void Main() &#123; int readValueFirst,readValueSecond,readValueThird; char character; readValueFirst = System.Console.Read(); character = (char) readValueFirst; System.Console.WriteLine(character); readValueSecond = System.Console.Read(); character = (char) readValueSecond; System.Console.WriteLine(character); readValueThird = System.Console.Read(); character = (char) readValueThird; System.Console.WriteLine(character); System.Console.ReadKey(); &#125;&#125; System.Console.Read() 从标准输入流读取下一个字符。 System.Console.ReadKey() 获取用户按下的下一个字符或功能键。 按下的键显示在控制台窗口中。 按回车键之前，System.Console.Read()方法不会返回输入，即使用户输入了多个字符。 输入 123，按回车，再输入 a，输出结果 123 1 2 3 a 上面两个示例，输入信息相同，由于代码不同因而输出结果不同。 输出到控制台 System.Console.Write() 输出后不添加换行符（当前行终止符）。System.Console.WriteLine() 将参数内容（后跟当前行终止符）写入标准输出流，输出后，光标切换到下一行。 123456789101112131415161718class Hello&#123; static void Main() &#123; string firstName; string lastName; System.Console.Write("Enter your first name: "); firstName = System.Console.ReadLine(); System.Console.Write("Enter your last name: "); lastName = System.Console.ReadLine(); System.Console.WriteLine( "Hello &#123;0&#125; &#123;1&#125;.", firstName, lastName); System.Console.ReadKey(); &#125;&#125; 示例代码中”Hello {0} {1}.”，标识了两个索引占位符，用于在字符串中插入数据。 输出结果 Enter your first name: Jon Enter your last name: Snow Hello Jon Snow. 交换索引占位符和对应变量 12System.Console.WriteLine( "Hello &#123;1&#125;, &#123;0&#125;.", firstName, lastName); 输出结果 Enter your first name: Jon Enter your last name: Snow Hello Snow, Jon. 代码注释1234567891011121314151617181920212223242526class Hello&#123; static void Main() &#123; string firstName; //存储名字的变量【单行注释】 string lastName; //存储姓氏的变量【单行注释】 System.Console.Write/*不换行输出【语句内部带分隔符注释】*/( "Enter your first name: "); firstName = System.Console.ReadLine(); System.Console.Write/*不换行输出【语句内部带分隔符注释】*/( "Enter your last name: "); lastName = System.Console.ReadLine(); /* 使用复合格式化在控制台显示问候语。 */ System.Console.WriteLine( "Hello &#123;1&#125;, &#123;0&#125;.", firstName, lastName); System.Console.ReadKey(); //这是程序列表的结尾 &#125;&#125; 目前观点 不要使用注释，除非代码本身“一言难尽”。 要尽量编写清晰的代码，而不是通过注释澄清复杂算法。 CIL和ILDAASM (公共中间语言和IL反汇编)C#编译器将C#代码转换成CIL代码而不是机器码。对于一个程序集(DLL文件或可执行文件)，可以使用CIL反汇编程序将其析构成对应的CIL表示，从而查看其CIL代码。微软的反汇编程序文件：ILDASM（IL Disassembler）,可以对程序或者类库执行反汇编，显示由C#编译器生成的CIL代码。 ildasm.exe存在与C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1 Tools类似位置 例子 ildasm /text hello.exe 输出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566D:\WaProj\Essential C#5.0, 4th Edition\第一章&gt;ildasm /text hello.exe// Microsoft (R) .NET Framework IL Disassembler. Version 4.6.1055.0// Metadata version: v4.0.30319.assembly extern mscorlib&#123; .publickeytoken = (B7 7A 5C 56 19 34 E0 89 ) // .z\V.4.. .ver 4:0:0:0&#125;.assembly Hello&#123; .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78 // ....T..WrapNonEx 63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 ) // ceptionThrows. .hash algorithm 0x00008004 .ver 0:0:0:0&#125;.module Hello.exe// MVID: &#123;BDAC1292-8393-4BEB-9AD7-40DC171B0BF9&#125;.imagebase 0x00400000.file alignment 0x00000200.stackreserve 0x00100000.subsystem 0x0003 // WINDOWS_CUI.corflags 0x00000001 // ILONLY// Image base: 0x02CF0000// =============== CLASS MEMBERS DECLARATION ===================.class private auto ansi beforefieldinit Hello extends [mscorlib]System.Object&#123; .method private hidebysig static void Main(string[] args) cil managed &#123; .entrypoint // 代码大小 19 (0x13) .maxstack 8 IL_0000: nop IL_0001: ldstr &quot;Hello World!&quot; IL_0006: call void [mscorlib]System.Console::WriteLine(string) IL_000b: nop IL_000c: call valuetype [mscorlib]System.ConsoleKeyInfo [mscorlib]System.Console::ReadKey() IL_0011: pop IL_0012: ret &#125; // end of method Hello::Main .method public hidebysig specialname rtspecialname instance void .ctor() cil managed &#123; // 代码大小 7 (0x7) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [mscorlib]System.Object::.ctor() IL_0006: ret &#125; // end of method Hello::.ctor&#125; // end of class Hello// =============================================================// *********** 反汇编完成 *********************** /text 选项制定输出到命令控制台，而不是在ildasm的图形界面程序中显示。 常见.NET反汇编工具 dnSpy (免费) 具备调试功能 ILSpy (免费) dotPeek (免费) 生成代码质量较高，Visual Studio风格界面 .Net Reflector (收费) 为了减少程序被别人轻松反编译，可以考虑使用混淆器(obfuscator)产品。这些混淆器会打开IL代码，将代码加密成一种功能不变但更难于理解的形式。 结尾]]></content>
      <tags>
        <tag>C#</tag>
        <tag>C#本质论</tag>
        <tag>Essential C#</tag>
      </tags>
  </entry>
</search>
