<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C#本质论笔记 第5章 类]]></title>
    <url>%2F2017%2F12%2F22%2FCSharp%E6%9C%AC%E8%B4%A8%E8%AE%BA%E7%AC%94%E8%AE%B0-%E7%AC%AC5%E7%AB%A0-%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[类的定义和实例化使用类，可以通过组合其他类型的变量、方法和事件创建自己的自定义类型。A class is a construct that enables you to create your own custom types by grouping together variables of other types, methods and events. 类好比是蓝图。A class is like a blueprint. 它定义类型的数据和行为。It defines the data and behavior of a type. 如果类未声明为静态，客户端代码就可以通过创建分配给变量的对象或实例来使用该类。If the class is not declared as static, client code can use it by creating objects or instances which are assigned to a variable. 变量会一直保留在内存中，直至对变量的所有引用超出范围为止。The variable remains in memory until all references to it go out of scope. 超出范围时，CLR 将对其进行标记，以便用于垃圾回收。At that time, the CLR marks it as eligible for garbage collection. 如果类声明为静态，则内存中只有一个副本，且客户端代码只能通过类本身，而不是实例变量来访问它。If the class is declared as static, then only one copy exists in memory and client code can only access it through the class itself, not an instance variable. 有关详细信息，请参阅静态类和静态类成员。For more information, see Static Classes and Static Class Members. 与结构不同，类支持继承，这是面向对象的编程的一个基本特点。Unlike structs, classes support inheritance, a fundamental characteristic of object-oriented programming. 有关详细信息，请参阅继承。 例子，包含类的定义、实例化、字段声明、字段访问和方法： 1234567891011121314151617181920212223242526272829using System;public class Program &#123; public static void Main () &#123; Employee employee1 = new Employee (); Employee employee2; employee2 = new Employee (); employee1.FirstName = "Inigo"; employee1.LastName = "Montoya"; employee1.Salary = "Too Little"; IncreaseSalary (employee1); Console.WriteLine ("&#123;0&#125;: &#123;1&#125;", employee1.GetName (), employee1.Salary); &#125; static void IncreaseSalary (Employee employee) &#123; employee.Salary = "Enough to survive on"; &#125;&#125;class Employee &#123; public string FirstName; public string LastName; public string Salary = "Not enough"; public string GetName () &#123; return FirstName + " " + LastName; &#125;&#125; &lt;&gt; this 关键字this 关键字指代类的当前实例。在此示例中，this 用于限定类似名称隐藏的 Employee 类成员、name 和 alias。In this example, this is used to qualify the Employee class members, name and alias, which are hidden by similar names. 它还用于将某个对象传递给属于其他类的方法 CalcTax。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System;class Employee &#123; private string name; private string alias; private decimal salary = 3000.00m; // Constructor: public Employee (string name, string alias) &#123; // Use this to qualify the fields, name and alias: // 如果不用 this 指定类成员 name，那么 name = name; 只是自己给自己赋值， // 最终，类成员 name 未被赋值，为 null this.name = name; this.alias = alias; &#125; // Printing method: public void printEmployee () &#123; Console.WriteLine ("Name: &#123;0&#125;\nAlias: &#123;1&#125;", name, alias); // Passing the object to the CalcTax method by using this: Console.WriteLine ("Taxes: &#123;0:C&#125;", Tax.CalcTax (this)); &#125; public decimal Salary &#123; get &#123; return salary; &#125; &#125;&#125;class Tax &#123; public static decimal CalcTax (Employee E) &#123; return 0.08m * E.Salary; &#125;&#125;class MainClass &#123; static void Main () &#123; // Create objects: Employee E1 = new Employee ("Mingda Pan", "mpan"); // Display results: E1.printEmployee (); &#125;&#125;/*Output: Name: Mingda Pan Alias: mpan Taxes: $240.00 */ 高级主题：存储和载入文件将数据持久化存储到文件 示例：首先，实例化一个FileStream对象，将它与一个以员工的全名命名的文件对应起来。FileMode.Create参数指明，如果对应的文件不存在就创建一个；如果文件存在，就覆盖它。接着创建一个StreamWriter类。StreamWriter类负责将文本写入FileStream。数据是用WriterLine()方法写入的，就像向控制台写入一样。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;// IO namespaceusing System.IO;class Employee &#123; public string FirstName; public string LastName; public string Salary; public void Save () &#123; DataStorage.Store (this); &#125;&#125;class DataStorage &#123; // Save an employee object to a file // named with the Employee name. // Error handling not shown. public static void Store (Employee employee) &#123; // Instantiate a FileStream using FirstNameLastName.dat // for the filename. FileMode.Create will force // a new file to be created or override an // existing file. FileStream stream = new FileStream ( employee.FirstName + employee.LastName + ".dat", FileMode.Create); // Create a StreamWriter object for writing text // into the FileStream StreamWriter writer = new StreamWriter (stream); // Write all the data associated with the employee. writer.WriteLine (employee.FirstName); writer.WriteLine (employee.LastName); writer.WriteLine (employee.Salary); // Close the StreamWriter and its Stream. writer.Close (); // Automatically closes the stream stream.Close(); &#125;&#125;class SaveDataToFile &#123; static void Main (string[] args) &#123; Employee employee = new Employee (); employee.FirstName = "Jon"; employee.LastName = "Snow"; employee.Salary = "$6000.00"; employee.Save (); &#125;&#125; 写入操作完成后，FileStream和StreamWriter都需要关闭，避免它们在等待垃圾回收器运行期间，处于“不确定性打开”的状态。上述代码没有任何错误处理机制，如果引发异常，两个Close()方法都不会执行。 从文件中获取数据读取数据与存储数据相反，它使用StreamReader而不是StreamWriter。同样的，一旦数据读取完毕，就要在FileStream和StreamReader上调用Close()方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101using System;using System.IO;public class Program &#123; public static void Main () &#123; Employee employee1; Employee employee2 = new Employee (); employee2.SetName ("Inigo", "Montoya"); employee2.Save (); // Modify employee2 after saving. IncreaseSalary (employee2); // Load employee1 from the saved version of employee2 employee1 = DataStorage.Load ("Inigo", "Montoya"); Console.WriteLine ( "&#123;0&#125;: &#123;1&#125;", employee1.GetName (), employee1.Salary); &#125; static void IncreaseSalary (Employee employee) &#123; employee.Salary = "Enough to survive on"; &#125;&#125;class Employee &#123; public string FirstName; public string LastName; public string Salary; public string GetName () &#123; return FirstName + " " + LastName; &#125; public void SetName (string newFirstName, string newLastName) &#123; this.FirstName = newFirstName; this.LastName = newLastName; Console.WriteLine ("Name changed to '&#123;0&#125;'", this.GetName ()); &#125; public void Save () &#123; DataStorage.Store (this); &#125;&#125;class DataStorage &#123; // Save an employee object to a file // named with the Employee name. // Error handling not shown. public static void Store (Employee employee) &#123; // Instantiate a FileStream using FirstNameLastName.dat // for the filename. FileMode.Create will force // a new file to be created or override an // existing file. FileStream stream = new FileStream ( employee.FirstName + employee.LastName + ".dat", FileMode.Create); // Create a StreamWriter object for writing text // into the FileStream StreamWriter writer = new StreamWriter (stream); // Write all the data associated with the employee. writer.WriteLine (employee.FirstName); writer.WriteLine (employee.LastName); writer.WriteLine (employee.Salary); // Close the StreamWriter and its Stream. writer.Close (); // Automatically closes the stream stream.Close (); &#125; public static Employee Load (string firstName, string lastName) &#123; Employee employee = new Employee (); // Instantiate a FileStream using FirstNameLastName.dat // for the filename. FileMode.Open will open // an existing file or else report an error. FileStream stream = new FileStream ( firstName + lastName + ".dat", FileMode.Open); // Create a SteamReader for reading text from the file. StreamReader reader = new StreamReader (stream); // Read each line from the file and place it into // the associated property. employee.FirstName = reader.ReadLine (); employee.LastName = reader.ReadLine (); employee.Salary = reader.ReadLine (); // Close the StreamReader and its Stream. reader.Close (); // Automatically closes the stream stream.Close (); return employee; &#125;&#125; 访问修饰符 Access Modifiers访问修饰符是关键字，用于指定成员或类型已声明的可访问性。Access modifiers are keywords used to specify the declared accessibility of a member or a type. 本部分介绍四个访问修饰符：This section introduces the four access modifiers: 公用 public 受保护 protected 内部 internal 专用 private 可以使用访问修饰符指定以下六个可访问性级别：The following six accessibility levels can be specified using the access modifiers: public：访问不受限制。public: Access is not restricted. protected：访问限于包含类或派生自包含类的类型。protected: Access is limited to the containing class or types derived from the containing class. internal：访问限于当前程序集。internal: Access is limited to the current assembly. protected internal： 访问仅限于当前程序集或从包含类派生的类型。protected internal: Access is limited to the current assembly or types derived from the containing class. private：访问限于包含类。private: Access is limited to the containing type. private protected： 访问被限制为包含的类或从包含当前程序集中的类派生的类型。 示例：使用private访问修饰符。下例为了隐藏Password字段，禁止从它包容类的外部访问，使用private访问修饰符替代public，这样就无法从Program类中访问Password字段了。 12345678910111213141516171819202122232425262728293031323334public class Program &#123; public static void Main () &#123; Employee employee = new Employee (); employee.FirstName = "Inigo"; employee.LastName = "Montoya"; // Password is private, so it cannot be // accessed from outside the class. // Console.WriteLine( // ("Password = &#123;0&#125;", employee.Password); &#125; // ...&#125;class Employee &#123; public string FirstName; public string LastName; public string Salary; private string Password; private bool IsAuthenticated; public bool Logon (string password) &#123; if (Password == password) &#123; IsAuthenticated = true; &#125; return IsAuthenticated; &#125; public bool GetIsAuthenticated () &#123; return IsAuthenticated; &#125; // ...&#125; 属性属性是一种成员，它提供灵活的机制来读取、写入或计算私有字段的值。A property is a member that provides a flexible mechanism to read, write, or compute the value of a private field. 属性可用作公共数据成员，但它们实际上是称为访问器的特殊方法。Properties can be used as if they are public data members, but they are actually special methods called accessors. 这使得可以轻松访问数据，还有助于提高方法的安全性和灵活性。 属性结合了字段和方法的多个方面。Properties combine aspects of both fields and methods. 对于对象的用户来说，属性似乎是一个字段，访问属性需要相同的语法。To the user of an object, a property appears to be a field, accessing the property requires the same syntax. 对于类的实现者来说，属性是一两个代码块，表示 get 访问器和/或 set 访问器。To the implementer of a class, a property is one or two code blocks, representing a get accessor and/or a set accessor. 读取属性时，执行 get 访问器的代码块；向属性赋予新值时，执行 set 访问器的代码块。The code block for the get accessor is executed when the property is read; the code block for the set accessor is executed when the property is assigned a new value. 将不带 set 访问器的属性视为只读。A property without a set accessor is considered read-only. 将不带 get 访问器的属性视为只写。A property without a get accessor is considered write-only. 将具有以上两个访问器的属性视为读写。A property that has both accessors is read-write. 与字段不同，属性不会被归类为变量。Unlike fields, properties are not classified as variables. 因此，不能将属性作为 ref 或 out 参数传递。 示例Example此示例演示实例、静态和只读属性。This example demonstrates instance, static, and read-only properties. 它接收通过键盘键入的员工姓名，按 1 递增 NumberOfEmployees，并显示员工姓名和编号。 12345678910111213141516171819202122232425262728293031323334353637public class Employee &#123; public static int NumberOfEmployees; private static int counter; private string name; // A read-write instance property: public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; // A read-only static property: public static int Counter &#123; get &#123; return counter; &#125; &#125; // A Constructor: public Employee () &#123; // Calculate the employee's number: counter = ++counter + NumberOfEmployees; &#125;&#125;class TestEmployee &#123; static void Main () &#123; Employee.NumberOfEmployees = 107; Employee e1 = new Employee (); e1.Name = "Claude Vige"; System.Console.WriteLine ("Employee number: &#123;0&#125;", Employee.Counter); System.Console.WriteLine ("Employee name: &#123;0&#125;", e1.Name); &#125;&#125;/* Output: Employee number: 108 Employee name: Claude Vige*/ 属性的声明1234567891011121314151617181920212223242526272829303132333435363738using System;using System.IO;public class Program &#123; public static void Main () &#123; Employee employee = new Employee (); // Call the FirstName property's setter. employee.FirstName = "Inigo"; // Call the FirstName property's getter. System.Console.WriteLine (employee.FirstName); &#125;&#125;class Employee &#123; // FirstName property public string FirstName &#123; get &#123; return _FirstName; &#125; set &#123; _FirstName = value; &#125; &#125; private string _FirstName; // LastName property public string LastName &#123; get &#123; return _LastName; &#125; set &#123; _LastName = value; &#125; &#125; private string _LastName;&#125; 自动实现的属性从C# 3.0开始，属性语法有了简化版本，允许在声明属性时，不添加取值或赋值方法，也不声明任何支持地段。一切都将自动实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System.IO;using System;public class Program &#123; public static void Main () &#123; Employee employee1 = new Employee (); Employee employee2 = new Employee (); // Call the FirstName property's setter. employee1.FirstName = "Inigo"; // Call the FirstName property's getter. System.Console.WriteLine (employee1.FirstName); // Assign an auto-implemented property employee2.Title = "Computer Nerd"; employee1.Manager = employee2; // Print employee1's manager's title. System.Console.WriteLine (employee1.Manager.Title); &#125;&#125;class Employee &#123; // FirstName property public string FirstName &#123; get &#123; return _FirstName; &#125; set &#123; _FirstName = value; &#125; &#125; private string _FirstName; // LastName property public string LastName &#123; get &#123; return _LastName; &#125; set &#123; _LastName = value; &#125; &#125; private string _LastName; // Title property public string Title &#123; get; set; &#125; // Manager property public Employee Manager &#123; get; set; &#125;&#125; 具有支持字段的属性 Properties with backing fields有一个实现属性的基本模式，该模式使用私有支持字段来设置和检索属性值。One basic pattern for implementing a property involves using a private backing field for setting and retrieving the property value. get 访问器返回私有字段的值，set 访问器在向私有字段赋值之前可能会执行一些数据验证。The get accessor returns the value of the private field, and the set accessor may perform some data validation before assigning a value to the private field. 这两个访问器还可以在存储或返回数据之前对其执行某些转换或计算。Both accessors may also perform some conversion or computation on the data before it is stored or returned. 下面的示例阐释了此模式。The following example illustrates this pattern. 在此示例中，TimePeriod 类表示时间间隔。In this example, the TimePeriod class represents an interval of time. 在内部，该类将时间间隔以秒为单位存储在名为 seconds 的私有字段中。Internally, the class stores the time interval in seconds in a private field named seconds. 名为 Hours 的读-写属性允许客户以小时为单位指定时间间隔。A read-write property named Hours allows the customer to specify the time interval in hours. get 和 set 访问器都会执行小时与秒之间的必要转换。Both the get and the set accessors perform the necessary conversion between hours and seconds. 此外，set 访问器还会验证数据，如果小时数无效，则引发 ArgumentOutOfRangeException。 1234567891011121314151617181920212223242526272829using System;class TimePeriod &#123; private double seconds; public double Hours &#123; get &#123; return seconds / 3600; &#125; set &#123; if (value &lt; 0 || value &gt; 24) throw new ArgumentOutOfRangeException ( $"&#123;nameof(value)&#125; must be between 0 and 24."); seconds = value * 3600; &#125; &#125;&#125;class Program &#123; static void Main () &#123; TimePeriod t = new TimePeriod (); // The property assignment causes the 'set' accessor to be called. t.Hours = 24; // Retrieving the property causes the 'get' accessor to be called. Console.WriteLine ($"Time in hours: &#123;t.Hours&#125;"); &#125;&#125;// The example displays the following output:// Time in hours: 24 表达式主体定义 Expression body definitions属性访问器通常由单行语句组成，这些语句只分配或只返回表达式的结果。Property accessors often consist of single-line statements that just assign or return the result of an expression. 可以将这些属性作为 expression-bodied 成员来实现。You can implement these properties as expression-bodied members. =&gt; 符号后跟用于为属性赋值或从属性中检索值的表达式，即组成了表达式主体定义。Expression body definitions consist of the =&gt; symbol followed by the expression to assign to or retrieve from the property. 从 C# 6 开始，只读属性可以将 get 访问器作为 expression-bodied 成员实现。Starting with C# 6, read-only properties can implement the get accessor as an expression-bodied member. 在这种情况下，既不使用 get 访问器关键字，也不使用 return 关键字。In this case, neither the get accessor keyword nor the return keyword is used. 下面的示例将只读 Name 属性作为 expression-bodied 成员实现。The following example implements the read-only Name property as an expression-bodied member. 12345678910111213141516171819202122using System;public class Person &#123; private string firstName; private string lastName; public Person (string first, string last) &#123; firstName = first; lastName = last; &#125; public string Name =&gt; $"&#123;firstName&#125; &#123;lastName&#125;";&#125;public class Example &#123; public static void Main () &#123; var person = new Person ("Isabelle", "Butts"); Console.WriteLine (person.Name); &#125;&#125;// The example displays the following output:// Isabelle Butts 从 C# 7 开始，get 和 set 访问器都可以作为 expression-bodied 成员实现。Starting with C# 7, both the get and the set accessor can be implemented as expression-bodied members. 在这种情况下，必须使用 get 和 set 关键字。In this case, the get and set keywords must be present. 下面的示例阐释如何为这两个访问器使用表达式主体定义。The following example illustrates the use of expression body definitions for both accessors. 请注意，return 关键字不与 get 访问器搭配使用。Note that the return keyword is not used with the get accessor. 123456789101112131415161718192021222324252627282930using System;public class SaleItem &#123; string name; decimal cost; public SaleItem (string name, decimal cost) &#123; this.name = name; this.cost = cost; &#125; public string Name &#123; get =&gt; name; set =&gt; name = value; &#125; public decimal Price &#123; get =&gt; cost; set =&gt; cost = value; &#125;&#125;class Program &#123; static void Main (string[] args) &#123; var item = new SaleItem ("Shoes", 19.95m); Console.WriteLine ($"&#123;item.Name&#125;: sells for &#123;item.Price:C2&#125;"); &#125;&#125;// The example displays output like the following:// Shoes: sells for $19.95 只读和只写属性省略 set 访问器可使属性为只读，省略 get 访问器可使属性为只写。只读属性对于任何赋值气度都会造成编译错误。例如，下例中是Id为只读： 12345678910111213141516171819202122232425262728class Program &#123; static void Main () &#123; Employee employee1 = new Employee (); employee1.Initialize (42); // ERROR: Property or indexer 'Employee.Id' // cannot be assigned to -- it is read-only //employee1.Id = "490"; //will not compile if you uncomment this line &#125;&#125;class Employee &#123; public void Initialize (int id) &#123; // Use field because Id property has no setter, // it is read-only. _Id = id.ToString (); &#125; // ... // Id property declaration public string Id &#123; get &#123; return _Id; &#125; // No setter provided. &#125; private string _Id;&#125; 上例中采用Employee构造函数(而不是属性)对字段进行赋值（_Id = id）。如果通过属性来赋值，会造成编译错误。 限制访问器可访问性（C# 编程指南）Restricting Accessor Accessibility (C# Programming Guide)属性或索引器的 get 和 set 部分称为访问器。The get and set portions of a property or indexer are called accessors. 默认情况下，这些访问器具有相同的可见性或访问级别：其所属属性或索引器的可见性或访问级别。By default these accessors have the same visibility, or access level: that of the property or indexer to which they belong. 有关详细信息，请参阅可访问性级别。For more information, see accessibility levels. 不过，有时限制对其中某个访问器的访问是有益的。However, it is sometimes useful to restrict access to one of these accessors. 通常是在保持 get 访问器可公开访问的情况下，限制 set 访问器的可访问性。Typically, this involves restricting the accessibility of the set accessor, while keeping the get accessor publicly accessible. 可以为get或set部分指定访问修饰符（但不能为两者都指定），从而覆盖为属性声明指定的访问修饰符。例如: 12345678910111213141516171819202122232425262728293031class Program &#123; static void Main () &#123; Employee employee1 = new Employee (); employee1.Initialize (42); // ERROR: The property or indexer 'Employee.Id' // cannot be used in this context because the set // accessor is inaccessible //employee1.Id = "490"; //will not compile if you uncomment this line &#125;&#125;class Employee &#123; public void Initialize (int id) &#123; // Set Id property Id = id.ToString (); &#125; // ... // Id property declaration public string Id &#123; get &#123; return _Id; &#125; // Providing an access modifier is in C# 2.0 // and higher only private set &#123; _Id = value; &#125; &#125; private string _Id;&#125; 为赋值方法指定private修饰符后，属性对于处Employee之外的其他类来说是只读的。在Employee类内部，属性是可读/可写的，所以可在构造器中对属性进行赋值。为取值方法或赋值方法指定访问修饰符时，注意该访问修饰符的“限制性”必须比应用于整个属相的访问修饰符更“严格”。例如，属性声明为较为严格的private，但将它的赋值方法声明为较宽松的public，就会发生编译错误。 属性作为虚字段使用下例中，Name属性的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using System;using System.IO;public class Program &#123; public static void Main () &#123; Employee employee1 = new Employee (); employee1.Name = "Inigo Montoya"; System.Console.WriteLine (employee1.Name); // ... &#125;&#125;class Employee &#123; // FirstName property public string FirstName &#123; get &#123; return _FirstName; &#125; set &#123; _FirstName = value; &#125; &#125; private string _FirstName; // LastName property public string LastName &#123; get &#123; return _LastName; &#125; set &#123; _LastName = value; &#125; &#125; private string _LastName; // ... // Name property public string Name &#123; get &#123; return FirstName + " " + LastName; &#125; set &#123; // Split the assigned value into // first and last names. string[] names; names = value.Split (new char[] &#123; ' ' &#125;); if (names.Length == 2) &#123; FirstName = names[0]; LastName = names[1]; &#125; else &#123; // Throw an exception if the full // name was not assigned. throw new System.ArgumentException ( string.Format ( "Assigned value '&#123;0&#125;' is invalid", value)); &#125; &#125; &#125; // Title property public string Title &#123; get; set; &#125; // Manager property public Employee Manager &#123; get; set; &#125;&#125; 构造器 Constructors (构造函数)每当创建类或结构时，将会调用其构造函数。Whenever a class or struct is created, its constructor is called. 类或结构可能具有采用不同参数的多个构造函数。A class or struct may have multiple constructors that take different arguments. 使用构造函数，程序员能够设置默认值、限制实例化，并编写灵活易读的代码。Constructors enable the programmer to set default values, limit instantiation, and write code that is flexible and easy to read. 有关详细信息和示例，请参阅使用构造函数和实例构造函数。 构造函数声明与调用1234567891011121314class Employee&#123; // Employee constructor public Employee(string firstName, string lastName) &#123; FirstName = firstName; LastName = lastName; &#125; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; public string Salary &#123; get; set; &#125; //...｝ 构造函数是一种方法，其名称与其类名``完全相同。 其方法签名仅包含方法名称和其参数列表；它没有返回类型。构造函数是“运行时”用来初始化对象实例的方法。在此例中，构造函数以员工的名字和姓氏作为参数，允许程序员在实例化Employee对象时制定这些参数的值。如下例： 123456789101112131415public class Program&#123; public static void Main() &#123; Employee employee; employee = new Employee("Inigo", "Montoya"); employee.Salary = "Too Little"; System.Console.WriteLine( "&#123;0&#125; &#123;1&#125;: &#123;2&#125;", employee.FirstName, employee.LastName, employee.Salary); &#125;&#125; 如果某个构造函数可以作为单个语句实现，则可以使用表达式主体定义。If a constructor can be implemented as a single statement, you can use an expression body definition. 以下示例定义 Location 类，其构造函数具有一个名为“name”的字符串参数。The following example defines a Location class whose constructor has a single string parameter named name. 表达式主体定义给 locationName 字段分配参数。The expression body definition assigns the argument to the locationName field. 123456789101112public class Location&#123; private string locationName; public Location(string name) =&gt; locationName = name; public string Name &#123; get =&gt; locationName; set =&gt; locationName = value; &#125;&#125; 默认构造器 Default constructors如果没有为类提供构造函数，默认情况下，C# 将创建一个会实例化对象并将成员变量设置为默认值的构造函数，如默认值表中所列。If you don’t provide a constructor for your class, C# creates one by default that instantiates the object and sets member variables to the default values as listed in the Default Values Table. 如果没有为结构提供构造函数，C# 将依赖于隐式默认构造函数，自动将值类型的每个字段初始化为其默认值，如默认值表中所列。If you don’t provide a constructor for your struct, C# relies on an implicit default constructor to automatically initialize each field of a value type to its default value as listed in the Default Values Table. 有关详细信息和示例，请参阅实例构造函数。 对象初始化器 Object Initializer可以使用对象初始值设定项(对象初始化器)以声明方式初始化类型对象，而无需显式调用类型的构造函数。You can use object initializers to initialize type objects in a declarative manner without explicitly invoking a constructor for the type. 以下示例演示如何将对象初始化器用于命名对象。The following examples show how to use object initializers with named objects. 编译器通过首先访问默认实例构造函数，然后处理成员初始化来处理对象初始值设定项。The compiler processes object initializers by first accessing the default instance constructor and then processing the member initializations. 因此，如果默认构造函数在类中声明为 private，则需要公共访问的对象初始值设定项将失败。Therefore, if the default constructor is declared as private in the class, object initializers that require public access will fail. 如果要定义匿名类型，则必须使用对象初始化器。You must use an object initializer if you’re defining an anonymous type. 有关详细信息，请参阅如何：在查询中返回元素属性的子集。For more information, see How to: Return Subsets of Element Properties in a Query. 下面的示例演示如何使用对象初始化器初始化新的 StudentName 类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Program &#123; public static void Main () &#123; // Declare a StudentName by using the constructor that has two parameters. StudentName student1 = new StudentName ("Craig", "Playstead"); // Make the same declaration by using an object initializer and sending // arguments for the first and last names. The default constructor is // invoked in processing this declaration, not the constructor that has // two parameters. StudentName student2 = new StudentName &#123; FirstName = "Craig", LastName = "Playstead", &#125;; // Declare a StudentName by using an object initializer and sending // an argument for only the ID property. No corresponding constructor is // necessary. Only the default constructor is used to process object // initializers. StudentName student3 = new StudentName &#123; ID = 183 &#125;; // Declare a StudentName by using an object initializer and sending // arguments for all three properties. No corresponding constructor is // defined in the class. StudentName student4 = new StudentName &#123; FirstName = "Craig", LastName = "Playstead", ID = 116 &#125;; System.Console.WriteLine (student1.ToString ()); System.Console.WriteLine (student2.ToString ()); System.Console.WriteLine (student3.ToString ()); System.Console.WriteLine (student4.ToString ()); &#125; // Output: // Craig 0 // Craig 0 // 183 // Craig 116&#125;public class StudentName &#123; // The default constructor has no parameters. The default constructor // is invoked in the processing of object initializers. // You can test this by changing the access modifier from public to // private. The declarations in Main that use object initializers will // fail. public StudentName () &#123; &#125; // The following constructor has parameters for two of the three // properties. public StudentName (string first, string last) &#123; FirstName = first; LastName = last; &#125; // Properties. public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; public int ID &#123; get; set; &#125; public override string ToString () &#123; return FirstName + " " + ID; &#125;&#125; 下面的示例演示如何使用集合初始化器来初始化 StudentName 类型的集合。The following example shows how to initialize a collection of StudentName types by using a collection initializer. 请注意，集合初始值设定项是一系列由逗号分隔的对象初始值设定项。Note that a collection initializer is a series of comma-separated object initializers. 1234567List&lt;StudentName&gt; students = new List&lt;StudentName&gt;()&#123; new StudentName &#123;FirstName="Craig", LastName="Playstead", ID=116&#125;, new StudentName &#123;FirstName="Shu", LastName="Ito", ID=112&#125;, new StudentName &#123;FirstName="Gretchen", LastName="Rivas", ID=113&#125;, new StudentName &#123;FirstName="Rajesh", LastName="Rotti", ID=114&#125;&#125;; 终结器 Finalizers终结器用于析构类的实例。Finalizers are used to destruct instances of classes. 备注 Remarks 无法在结构中定义终结器。Finalizers cannot be defined in structs. 它们仅用于类。They are only used with classes. 一个类只能有一个终结器。A class can only have one finalizer. 不能继承或重载终结器。Finalizers cannot be inherited or overloaded. 不能手动调用终结器。Finalizers cannot be called. 可以自动调用它们。They are invoked automatically. 终结器不使用修饰符或参数。 例如，以下是类 Car 的终结器声明。For example, the following is a declaration of a finalizer for the Car class. 1234567class Car&#123; ~Car() // destructor &#123; // cleanup statements... &#125;&#125; 终结器也可以作为表达式主体定义实现，如下面的示例所示。A finalizer can also be implemented as an expression body definition, as the following example shows. 12345678using System;public class Destroyer&#123; public override string ToString() =&gt; GetType().Name; ~Destroyer() =&gt; Console.WriteLine($"The &#123;ToString()&#125; destructor is executing.");&#125; 程序员无法控制何时调用终结器，因为这由垃圾回收器决定。The programmer has no control over when the finalizer is called because this is determined by the garbage collector. 垃圾回收器检查应用程序不再使用的对象。The garbage collector checks for objects that are no longer being used by the application. 如果它认为某个对象符合终止条件，则调用终结器（如果有），并回收用来存储此对象的内存。If it considers an object eligible for finalization, it calls the finalizer (if any) and reclaims the memory used to store the object. 还可在程序退出后调用终结器。Finalizers are also called when the program exits. 可以通过调用 Collect 强制进行垃圾回收，但多数情况下应避免此操作，因为它可能会造成性能问题。 构造器的重载123456789101112131415161718192021222324252627class Employee &#123; public Employee (string firstName, string lastName) &#123; FirstName = firstName; LastName = lastName; &#125; public Employee ( int id, string firstName, string lastName) &#123; Id = id; FirstName = firstName; LastName = lastName; &#125; public Employee (int id) &#123; Id = id; // Look up employee name... // ... &#125; public int Id &#123; get; set; &#125; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; public string Salary &#123; get; set; &#125; // ...&#125; 应优先使用可选参数而不是重载，以便在API中清楚地看出“默认”属性的默认值。例如，Person的一个构造器签名Person（string firstName, string lastName, int? age = null）就清楚地指明如果Person的Age未指定，就将它默认为null。 构造器链：使用this调用另一个构造器上例中，对Employee对象进行初始化的代码多处重复，可以从一个构造器中调用另一个构造器，避免重复输入代码。这称为构造器链，它是用构造器初始化器来实现的。C#采用的语法格式是在一个冒号后面添加this关键字，再添加被调用构造器的参数列表。构造器初始化器在自行当前的构造器实现之前，判断要调用另外哪一个构造器，实例如下： 1234567891011121314151617181920212223242526272829class Employee &#123; public Employee (string firstName, string lastName) &#123; FirstName = firstName; LastName = lastName; &#125; public Employee ( int id, string firstName, string lastName) : this (firstName, lastName) &#123; Id = id; &#125; public Employee (int id) &#123; Id = id; // Look up employee name... // ... // NOTE: Member constructors cannot be // called explicitly inline // this(id, firstName, lastName); &#125; public int Id &#123; get; set; &#125; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125; public string Salary &#123; get; set; &#125; // ...&#125; 上例中，3个参数的构造器调用2个参数的构造器。通常情况下，用参数最少的构造器调用参数最多的构造器，为未知的参数传递默认值。如下例： 12345678910111213public Employee(int id):this(id,"","")&#123; string firstName; string lastName; Id = id; // 检索、组合Employee数据 firstName = string.Empty; lastName = string.Empty; // ... Initialize(id, firstName, lastName);&#125; 构造器链完整例子参考： 1234567891011121314151617181920212223242526272829303132333435363738394041using System;public class Person &#123; public string personName; //定义年龄为可空类型,这样就可以赋予其null值 public int? personAge; //下面前三个构造函数都是去调用参数最多的第四个构造函数,只取它们所需要的部分参数即可 //这样的做法就是this串联构造函数 public Person () : this ("", 0) &#123; &#125; public Person (string name) : this (name, null) &#123; &#125; public Person (int age) : this ("", age) &#123; &#125; public Person (string name, int? age) &#123; this.personName = name; //通过 ?? 判断传入的age是否null值 //如果属于null值,则赋值100 this.personAge = age ?? 100; &#125; public void Display () &#123; Console.WriteLine ("Name:&#123;0&#125;,Age:&#123;1&#125;", personName, personAge); &#125;&#125;class Hello &#123; static void Main (string[] args) &#123; Person per1 = new Person (); per1.Display (); Person per2 = new Person (20); per2.Display (); Person per3 = new Person ("evan"); per3.Display (); Person per4 = new Person ("evan", 20); per4.Display (); Console.ReadKey (); &#125;&#125; 初学者主题：集中初始化创建单独的方法，将所有初始化代码集中在一起，如下例中，创建名为Initialize()方法，它同时获取员工的名字、姓氏和ID。示例如下： 1234567891011121314151617181920212223242526272829303132333435363738class Employee &#123; public Employee (string firstName, string lastName) &#123; int id; // Generate an employee ID... id = 0; // id needs to be initialized for this example // ... Initialize (id, firstName, lastName); &#125; public Employee (int id, string firstName, string lastName) &#123; Initialize (id, firstName, lastName); &#125; public Employee (int id) &#123; string firstName; string lastName; Id = id; // Look up employee data firstName = string.Empty; lastName = string.Empty; // ... Initialize (id, firstName, lastName); &#125; private void Initialize ( int id, string firstName, string lastName) &#123; Id = id; FirstName = firstName; LastName = lastName; &#125; // ... private int Id &#123; get; set; &#125; public string FirstName &#123; get; set; &#125; public string LastName &#123; get; set; &#125;&#125; 匿名类型C# 3.0引入了对匿名类型的支持，匿名类型提供了一种方便的方法，可用来将一组只读属性封装到单个对象中，而无需首先显式定义一个类型。 类型名由编译器生成，并且不能在源代码级使用。 每个属性的类型由编译器推断。 123456789101112131415161718192021222324252627282930313233343536373839404142using System;public class Program &#123; public static void Main () &#123; var patent1 = new &#123; Title = "Bifocals", YearOfPublication = "1784" &#125;; var patent2 = new &#123; Title = "Phonograph", YearOfPublication = "1877" &#125;; var patent3 = new &#123; patent1.Title, Year = patent1.YearOfPublication &#125;; System.Console.WriteLine ("&#123;0&#125; (&#123;1&#125;)", patent1.Title, patent1.YearOfPublication); System.Console.WriteLine ("&#123;0&#125; (&#123;1&#125;)", patent2.Title, patent1.YearOfPublication); Console.WriteLine (); Console.WriteLine (patent1); Console.WriteLine (patent2); Console.WriteLine (); Console.WriteLine (patent3); &#125;&#125;/* 输出ifocals (1784)Phonograph (1784)&#123; Title = Bifocals, YearOfPublication = 1784 &#125;&#123; Title = Phonograph, YearOfPublication = 1877 &#125;&#123; Title = Bifocals, Year = 1784 &#125;*/ 匿名类型通常用在查询表达式的 select 子句中，以便返回源序列中每个对象的属性子集。Anonymous types typically are used in the select clause of a query expression to return a subset of the properties from each object in the source sequence. 有关查询的详细信息，请参阅 LINQ 查询表达式。 静态成员使用 static 修饰符可声明属于类型本身而不是属于特定对象的静态成员。Use the static modifier to declare a static member, which belongs to the type itself rather than to a specific object. static 修饰符可用于类、字段、方法、属性、运算符、事件和构造函数，但不能用于索引器、终结器或类以外的类型。The static modifier can be used with classes, fields, methods, properties, operators, events, and constructors, but it cannot be used with indexers, finalizers, or types other than classes. 有关详细信息，请参阅静态类和静态类成员。For more information, see Static Classes and Static Class Members. 示例 下面的类声明为 static 并且只含 static 方法：The following class is declared as static and contains only static methods: 12345static class CompanyEmployee&#123; public static void DoSomething() &#123; /*...*/ &#125; public static void DoSomethingElse() &#123; /*...*/ &#125;&#125; 常量或类型声明是隐式的静态成员。A constant or type declaration is implicitly a static member. 不能通过实例引用静态成员。A static member cannot be referenced through an instance. 然而，可以通过类型名称引用它。Instead, it is referenced through the type name. 例如，请考虑以下类：For example, consider the following class: 1234567public class MyBaseC&#123; public struct MyStruct &#123; public static int x = 100; &#125;&#125; 若要引用静态成员 x，除非可从相同范围访问该成员，否则请使用完全限定的名称 MyBaseC.MyStruct.x：To refer to the static member x, use the fully qualified name, MyBaseC.MyStruct.x, unless the member is accessible from the same scope: 1Console.WriteLine(MyBaseC.MyStruct.x); 尽管类的实例包含该类的所有实例字段的单独副本，但每个静态字段只有一个副本。 示例 此示例显示，尽管可以使用尚未声明的其他静态字段来初始化某个静态字段，但除非向该静态字段显式分配值，否则不会定义该结果。This example shows that although you can initialize a static field by using another static field not yet declared, the results will be undefined until you explicitly assign a value to the static field. 1234567891011121314151617181920using System;class Test &#123; static int x = y; static int y = 5; static void Main () &#123; Console.WriteLine (x); Console.WriteLine (y); x = 99; Console.WriteLine (x); &#125;&#125;/*Output: 0 5 99*/ 未完成]]></content>
      <tags>
        <tag>C#</tag>
        <tag>C#本质论</tag>
        <tag>Essential C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 系统常用工具软件]]></title>
    <url>%2F2017%2F12%2F19%2FWindows-%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[截图 Snipaste 大概是最犀利的截图工具了，稍微有点专业，适合重度截图使用者。 FastStone Capture 一款出色的屏幕捕捉（截图）软件，它集图像捕捉、浏览、编辑、视频录制等功能于一身，功能完善、使用方便，值得推荐！软件提供多种捕捉方式（如：活动窗口、窗口/对象、矩形区域、手绘区域、整个屏幕、滚动窗口等），还具备屏幕录像机、放大镜、颜色拾取、屏幕标尺等附加功能，支持快捷键操作。 网盘密码：7n6e PicPick 一款很不错的截图工具，小巧/实用/干净/免费/无广告，适合大多数用户使用。 录屏 ScreenToGif 录屏为Gif文件，小巧易用，功能强大。 网盘密码：wlww oCam 录屏为视频文件，同类软件中体积算是最小的了，功能足够。网盘密码：v7bk 图片 浏览查看 XnView 免费/干净。 iSee图片专家 图片浏览和编辑特效功能。 照片 排版打印 光影魔术手 照片排版打印，免费/无广告。 浏览器 QQ 浏览器 与Chrome浏览器一样，基于Chromium，所以chrome浏览器的插件都可以用，在应用中心也可以搜索到插件，具备chrome浏览器没有的侧边栏。 Chrome 浏览器 多数浏览器的标准参照。 视频音频播放器 PotPlayer 干净/简洁/流畅/易操作。 音乐播放器 网易云音乐 Windows/Mac/iPhone/iPad/安卓/Linux 全平台支持，CD音质。 视频音频格式转换 格式工厂 免费多功能的多媒体文件转换工具。支持各种类型视频、音频、图片等多种格式，轻松转换到你想要的格式。 系统安全 杀毒防护 Windows Defender 内置在 Windows Vista 以及以后的版本中，不用安装各种卫士了。 火绒安全软件 干净/靠谱/轻巧的安全软件，还具备清理和拦截弹窗等功能。 笔记 有道云笔记 提供了PC端、移动端、网页端等多端应用，用户可以随时随地对线上资料进行编辑、分享以及协同。 文本/代码 编辑器 Sublime Text 一款流行的代码编辑器软件，支持多种编程语言和文件格式，可运行在Linux，Windows和Mac OS X。也是许多程序员喜欢使用的一款文本编辑器软件。 EmEditor 快速，轻巧，可扩展，使用方便的 Windows 文本编辑器，支持多种编程语言和文件格式。 Markdown文件编辑 Visual Studio Code Sublime 也是一款很好的 Markdown 编辑工具，并且相对轻量，但是 VSCode 添加了 Markdown All in One 和 markdownlint 等插件后，功能上相比 Sublime 更为强大，可以在编辑器内实时预览，同样可以保存为 HTML 格式。VSCode 相关插件参见Visual Studio Code VSCode 常用 插件 扩展。VSCode 是全功能的编辑/编码/调试工具，开源/免费/插件丰富/功能强大。 Markdown 相关浏览器插件 （Chrome/QQ浏览器） Markdown Cheatsheet Markdown 语法备忘表 Convert Medium Posts to Markdown 将网页文章转换为 Markdown 拷贝为 Markdown 将你在页面中选中的HTML格式转化为Markdown格式。 Copy as Markdown Quotation 拷贝Web页面为Markdown引用格式，与上面插件区别为多了引用标记。 文件管理 Total Commander 著名的文件管理软件，其功能类似于资源管理器。它具有两个并排的文件窗口，方便用户对文件及文件夹进行复制、移动、删除等操作和管理。 Q-Dir 一款非常独特的资源管理器，Q-Dir 特别适用于频繁在各个目录间跳跃复制、粘贴和移动的情况。功能类似于 Total Commander，相比较更小巧/简单易用。 TreeSize 一个磁盘空间管理器，用树形、饼图等图形描述出来，能够显示文件大小和实际占用空间数及浪费的空间等信息，比较磁盘空间变化情况，让你做出相应的删除决定。 网盘密码：bbx2 FileTypesMan 一个用来查看系统中已注册文件类型的小工具。可以给没有图标的文件指定图标或者修改图标，比如 Markdown 文件。 网盘密码：fqzc 下载 迅雷5 迅雷7/9版本似乎主要是限速和广告，之前的迅雷才是真正的下载工具。 网盘密码：s8lq qBittorrent 一个新的轻量级BitTorrent客户端，它简单易用，功能强大，被视为一个良好的替代其他BitTorrent软件的客户端。软件界面自动支持中文。 PDF 阅读器 Foxit Reader 福昕阅读器，这里提供的是早期版本，体积小巧（5M），启动迅速，单文件免安装，干净/无广告，对PDF文件需要的功能，都具备了。 网盘密码：v9c8 SumatraPDF 一款开源的pdf阅读器。它的功能极度精简，速度很快，支持 PDF, ePub, MOBI, CHM, XPS, DjVu, CBZ, CBR 多种格式，支持中文界面。 PdgCntEditor 一个图形化文件目录编辑器，支持PDF 、DjVu 和PDG三种格式，可以快速编辑 PDF 文件标签、目录并保存文件。 网盘密码：wji8 电子邮件 eMail 客户端 YoMail 优秀的邮件客户端，还支持 Gmail，具备协作沟通功能。 网易邮箱大师 同样是不错的邮件客户端，同样支持 Gmail。 压缩软件 7-Zip 一款完全免费而且开源的压缩软件，相比其他软件有更高的压缩比但同时耗费的资源也相对更多，如果你需要一款能够提供强大压缩性能的软件，那么它是你最好的选择。 输入法 QQ输入法 简洁、干净、字库云同步，多平台支持。 微软拼音 Windows 10 自带的拼音输入法挺好，干净，也可以云存储个人输入习惯和词库。 网络优化 DNS Jumper 用于一键切换DNS的免费应用程序，里面已经包含18组DNS ，当然也包含了Google DNS，或者可以自定义添加。 网盘密码：cfiq Shell MobaXterm 开源/免费/干净/功能强大的全能终端软件。 Windows 系统重装 微PE工具箱 PE工具全功能集合，最干净的PE工具，用于制作系统启动 U 盘和系统启动维护。 欢迎推荐 持续更新]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>工具软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#本质论笔记 第4章 方法和参数]]></title>
    <url>%2F2017%2F12%2F19%2FCSharp%E6%9C%AC%E8%B4%A8%E8%AE%BA%E7%AC%94%E8%AE%B0-%E7%AC%AC4%E7%AB%A0-%E6%96%B9%E6%B3%95%E5%92%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[方法方法是包含一系列语句的代码块。 程序通过调用该方法并指定任何所需的方法参数使语句得以执行。 在 C# 中，每个执行的指令均在方法的上下文中执行。 Main 方法是每个 C# 应用程序的入口点，并在启动程序时由公共语言运行时 (CLR) 调用。 规范 要为方法名使用动词或动词短语。 1System.Console.Write("Enter Your first name: ") 解析 System 命名空间 Console 类型名称 Write 方法名称 &quot;Enter Your first name: &quot; 实参 命名空间命名空间是一种分类机制，用于组合功能相关的所有类型。System 命名空间包含了用于执行大量基本变成活动的类型。 常见命名空间 命名空间 描述 System 主命名空间 System.Collections.Generic 泛型集合接口和类 System.Collections 使用Arraylist System.Linq 语言集成查询 System.Text 编码方式 System.Text.RegularExpressions 正则表达式 System.Threading 多线程 System.Windows.Forms winform窗体 System.Windows.Forms.Control winform控件 System.IO 操作文件、文件夹 System.Data 操作ado.net System.Data.SqlClient 操作ado.net System.Net 操作网络 System.Net.Sockets 操作网络套接字 System.Management 获取硬件信息(需要添加引用) System.Drawing 绘制系统 System.Xml 操作xml System.Media 播放wav和系统wav文件 Microsoft.Win32 操作注册表 System.Runtime.InteropServices 引用dll System.Security.Cryptography 加密解密 System.Text.RegularExpressions 正则表达式 Microsoft.VisualBasic 简繁体转换(需要添加引用) System.Diagnostics 调试输出 System.Web.UI web页面 System.Web.UI.Control web控件 System.Configuration 配置信息 System.DateTime 操作时间 System.Math 操作数字类 Microsoft.Win32.Registry 操作注册表 方法的声明和调用在类或者结构中声明方法。 例子 123456789101112131415161718192021222324252627282930class IntroducingMethods &#123; static void Main (string[] args) &#123; string firstName; string lastName; string fullName; System.Console.WriteLine ("Hey you!"); firstName = GetUserInput ("Enter your first name: "); lastName = GetUserInput ("Enter you last name: "); fullName = GetFullName (firstName, lastName); DisplayGreeting (fullName); &#125; static string GetUserInput (string prompt) &#123; System.Console.Write (prompt); return System.Console.ReadLine (); &#125; static string GetFullName (string firstName, string lastName) &#123; return firstName + " " + lastName; &#125; static void DisplayGreeting (string name) &#123; System.Console.WriteLine ("Your full name is &#123;0&#125;.", name); return; &#125;&#125; 初学者主题：用方法进行重构将一组相关语句转移到一个方法中，而不是把它们留在一个较大的方法中，这是重构 refactoring 的一种形式。 重构有助于减少重复代码，因为可以从多个位置调用方法，而不必在每个位置都重复这个方法的代码。 重构还有助于增强代码的可读性。 方法的返回类型和返回值方法可以将值返回给调用方。 如果列在方法名之前的返回类型 不是 void，则该方法可通过使用 return 关键字返回值。 带 return 关键字，后跟与返回类型匹配的值的语句将该值返回到方法调用方。 return 语句并非只能在方法末尾出现，例如，if 或 switch 语句中可以包含 return 语句，举例如下： 123456789101112131415class Program&#123; static bool MyMethod() &#123; string command = ObtainCommand(); switch(command) &#123; case "quit": return false; // ... omitted, other cases default: return true; &#125; &#125;&#125; 如果 return 之后有“不可达”的语句，编译器会发出警告，指出有永远执行不到的语句。 指定 void 作为返回类型，表示没有返回值，所以，return 可有可无。 using 指令C# 允许简写类的全名，为此，要在文件的顶部列出类的命名空间（名称空间），前面加上 using 关键字。在文件的其他地方，就可以使用其类型名称来引用空间中的类型了。 例子 12345678910111213// The using directive imports all types from the// specified namespace into the entire file.using System;class HelloWorld&#123; static void Main() &#123; // No need to qualify Console with System // because of the using directive above. Console.WriteLine("Hello, my name is Inigo Montoya"); &#125;&#125; 如果要引用某个命名空间的子命名空间中的类型，同样需要在文件顶部用 using 语句明确指定子命名空间引用。例如，要访问 System.Text 中的 StringBuilder 类型，必须增加一个 using System.Text; 指令，或者使用 Syste.Text.StringBuilder 对类型进行完全限定，而不能仅仅写成 Text.StringBuilder。 使用别名可以利用 using 指令为命名空间或类型取一个别名。别名alias是在using指令起作用范围内可以使用的替代名称。别名的两个最常见的用途是消除两个同名类型的歧义和缩写长名称。 例如，System.Timers 中存在 Timer 类型，System.Threading 中也存在一个 Timer 类型，当这两个命名空间同时存在并同时需要被引用时，需要用别名来加以区分： 123456789101112using System;using System.Threading;using CountDownTimer = System.Timers.Timer;class HelloWorld&#123; static void Main() &#123; CountDownTimer timer; // ... &#125;&#125; 如果别名跟要区别的类型名相同，或者说别名占用了类型名的名字，那么如果要引用另外一个类型，就必须完全限定或者定义新的不同的别名，如下例： 123456789101112131415using System;using System.Threading;// Declare alias Timer to refer to System.Timers.Timer to// avoid code ambiguity with System.Threading.Timerusing Timer = System.Timers.Timer;class HelloWorld&#123; static void Main() &#123; Timer timer; // ... &#125;&#125; 上例中，Timer 时别名，如果要引用 System.Threading.Timer类型，必须完全限定或者定义不同的别名。这又是要搞么？😥 高级主题：嵌套的 using 指令也可以在命名空间内部使用 using 指令，有效范围限于命名空间内部。不过，很少这样使用。 1234567891011121314namespace EssentialCSharp&#123; using System; class HelloWorld &#123; static void Main() &#123; // No need to qualify Console with System // because of the using directive above. Console.WriteLine("Hello, my name is Inigo Montoya"); &#125; &#125;&#125; Main() 和命令行参数Main 方法是 C# 应用程序的入口点。 （库和服务不要求使用 Main 方法作为入口点）。Main 方法是应用程序启动后调用的第一个方法。 C# 程序中只能有一个入口点。 如果多个类包含 Main 方法，必须使用 /main 编译器选项来编译程序，以指定将哪个 Main 方法用作入口点。 有关详细信息，请参阅 /main（C# 编译器选项）。 概述 Main 方法是可执行程序的入口点，也是程序控制开始和结束的位置。 Main 在类或结构中声明。 Main 必须是静态方法，不得为公共方法。 （在前面的示例中，它获得的是私有成员的默认访问权限）。封闭类或结构不一定要是静态的。 Main 可以具有 void、int，或者以 C# 7.1、Task 或 Task 返回类型开头。 当且仅当 Main 返回 Task 或 Task 时，Main 的声明可包括 async 修饰符。 请注意，该操作可明确排除 async void Main 方法。 使用或不使用包含命令行自变量的 string[] 参数声明 Main 方法都行。 使用 Visual Studio 创建 Windows 应用程序时，可以手动添加此形参，也可以使用 Environment 类来获取命令行实参。 参数被读取为从零开始编制索引的命令行自变量。 与 C 和 C++ 不同，程序的名称不被视为第一个命令行自变量。 命令行参数 可以通过以下方式之一定义方法来将自变量发送到 Main 方法： 1static int Main(string[] args) 1static void Main(string[] args) 程序运行时，通过 string 数组参数将命令行参数传递给 Main()。要获取参数，操作数组就可以了。 示例 命令行输入 传递给 Main 的字符串数组 executable.exe a b c “a”“b”“c” executable.exe one two “one”“two” executable.exe “one two” three “one two”“three” 实例说明 123456789101112131415161718192021class CommandLine &#123; static void Main (string[] args) &#123; // The Length property provides the number of array elements System.Console.WriteLine ("parameter count = &#123;0&#125;", args.Length); for (int i = 0; i &lt; args.Length; i++) &#123; System.Console.WriteLine ("Arg[&#123;0&#125;] = [&#123;1&#125;]", i, args[i]); &#125; &#125;&#125;/* 执行 CommandLine.exe a b c 输出: parameter count = 3 Arg[0] = [a] Arg[1] = [b] Arg[2] = [c]*//* 执行 commandline.exe "a b" c 输出: parameter count = 2 Arg[0] = [a b] Arg[1] = [c]*/ 高级主题：多个 Main() 方法如果多个类包含 Main 方法，对 csc.exe 使用 /main:class 选项将指定包含程序入口点的类。 示例 编译 t2.cs 和 t3.cs，指出 Main 方法可在 Test2 中找到： csc t2.cs t3.cs /main:Test2 方法的参数按引用传递和按值传递参数默认情况下，值类型传递给方法时，传递的是副本而不是对象本身。 因此，对参数的更改不会影响调用方法中的原始副本。 可以使用 ref 关键字按引用传递值类型。 有关详细信息，请参阅传递值类型参数。 有关内置值类型的列表，请参阅值类型表。 引用类型的对象传递到方法中时，将传递对对象的引用。 也就是说，该方法接收的不是对象本身，而是指示该对象位置的参数。 如果通过使用此引用更改对象的成员，即使是按值传递该对象，此更改也会反映在调用方法的参数中。 例子 123456789101112131415161718using System;public class SampleRefType &#123; public int value;&#125;public class Test &#123; public static void Main () &#123; SampleRefType rt = new SampleRefType (); rt.value = 11; ModifyObject (rt); Console.WriteLine (rt.value); &#125; static void ModifyObject (SampleRefType obj) &#123; obj.value = 66; &#125;&#125;/* 输出66*/ 在 C# 中，实参可以按值或按引用传递给形参。 按引用传递使函数成员、方法、属性、索引器、运算符和构造函数可以更改参数的值，并让该更改在调用环境中保持。 若要按引用传递参数，请使用 ref 或 out 关键字。 例子 1234567891011121314151617181920212223242526272829using System;class Program &#123; static void Main (string[] args) &#123; int arg; // Passing by value. // The value of arg in Main is not changed. arg = 4; squareVal (arg); Console.WriteLine (arg); // Output: 4 // Passing by reference. // The value of arg in Main is changed. arg = 4; squareRef (ref arg); Console.WriteLine (arg); // Output: 16 &#125; static void squareVal (int valParameter) &#123; valParameter *= valParameter; &#125; // Passing by reference static void squareRef (ref int refParameter) &#123; refParameter *= refParameter; &#125;&#125; 引用参数 ref在方法的参数列表中使用 ref 关键字时，它指示参数按引用传递，而非按值传递。 按引用传递的效果是，对所调用方法中参数进行的任何更改都反映在调用方法中。 例如，如果调用方传递本地变量表达式或数组元素访问表达式，所调用方法会替换 ref 参数引用的对象，然后，当该方法返回时，调用方的本地变量或数组元素将开始引用新对象。 若要使用 ref 参数，方法定义和调用方法均必须显式使用 ref 关键字，如下面的示例所示。 12345678910111213using System;class RefExample &#123; static void Method (ref int i) &#123; i = i + 44; &#125; static void Main () &#123; int val = 1; Method (ref val); Console.WriteLine (val); // Output: 45 &#125;&#125; 输出参数 outout 关键字通过引用传递参数。 它与 ref 关键字相似，只不过 ref 要求在传递之前初始化变量。 若要使用 out 参数，方法定义和调用方法均必须显式使用 out 关键字。 例如: 12345678910111213using System;class OutExample &#123; static void Method (out int i) &#123; i = 44; &#125; static void Main () &#123; int value; Method (out value); Console.WriteLine (value); // value is now 44 &#125;&#125; 调用具有 out 参数的方法在 C# 6 及更早版本中，必须先在单独的语句中声明变量，然后才能将其作为 out 参数传递。 下面的示例先声明了变量 number，然后再将它传递给将字符串转换为数字的 Int32.TryParse 方法。 123456789101112131415using System;public class Example &#123; public static void Main () &#123; string value = "1640"; int number; if (Int32.TryParse (value, out number)) Console.WriteLine ($"Converted '&#123;value&#125;' to &#123;number&#125;"); else Console.WriteLine ($"Unable to convert '&#123;value&#125;'"); &#125;&#125;// The example displays the following output:// Converted '1640' to 1640 从 C# 7 开始，可以在方法调用的参数列表而不是单独的变量声明中声明 out 变量。 这使得代码更简洁可读，还能防止在方法调用之前无意中向该变量赋值。 下面的示例与上一个示例基本相同，不同之处在于它在对 Int32.TryParse 方法的调用中定义了 number 变量。 1234567891011121314using System;public class Example &#123; public static void Main () &#123; string value = "1640"; if (Int32.TryParse (value, out int number)) Console.WriteLine ($"Converted '&#123;value&#125;' to &#123;number&#125;"); else Console.WriteLine ($"Unable to convert '&#123;value&#125;'"); &#125;&#125;// The example displays the following output:// Converted '1640' to 1640 数组参数参数以数组形式体现，即数组参数。数组可以作为实参传递给方法形参。由于数组是引用类型，因此方法可以更改元素的值。 将一维数组作为参数传递 可将初始化的一维数组传递给方法。 例如，下列语句将一个数组发送给了 Print 方法。 12int[] theArray = &#123; 1, 3, 5, 7, 9 &#125;;PrintArray(theArray); 可在同一步骤中初始化并传递新数组，如下例所示。 1PrintArray(new int[] &#123; 1, 3, 5, 7, 9 &#125;); 将多维数组作为参数传递 通过与传递一维数组相同的方式，向方法传递初始化的多维数组。 12int[,] theArray = &#123; &#123; 1, 2 &#125;, &#123; 2, 3 &#125;, &#123; 3, 4 &#125; &#125;;Print2DArray(theArray); 可在同一步骤中初始化并传递新数组，如下例所示。 1Print2DArray(new int[,] &#123; &#123; 1, 2 &#125;, &#123; 3, 4 &#125;, &#123; 5, 6 &#125;, &#123; 7, 8 &#125; &#125;); 示例 在下列示例中，初始化一个整数的二维数组，并将其传递至 Print2DArray 方法。 该方法将显示数组的元素。 12345678910111213141516171819202122232425262728class ArrayClass2D &#123; static void Print2DArray (int[, ] arr) &#123; // Display the array elements. for (int i = 0; i &lt; arr.GetLength (0); i++) &#123; for (int j = 0; j &lt; arr.GetLength (1); j++) &#123; System.Console.WriteLine ("Element(&#123;0&#125;,&#123;1&#125;)=&#123;2&#125;", i, j, arr[i, j]); &#125; &#125; &#125; static void Main () &#123; // Pass the array as an argument. Print2DArray (new int[, ] &#123; &#123; 1, 2 &#125;, &#123; 3, 4 &#125;, &#123; 5, 6 &#125;, &#123; 7, 8 &#125; &#125;); // Keep the console window open in debug mode. System.Console.WriteLine ("Press any key to exit."); System.Console.ReadKey (); &#125;&#125;/* Output: Element(0,0)=1 Element(0,1)=2 Element(1,0)=3 Element(1,1)=4 Element(2,0)=5 Element(2,1)=6 Element(3,0)=7 Element(3,1)=8*/ 示例 传递一个长度可变的参数列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System;using System.IO;class PathEx &#123; static void Main () &#123; string fullName; // Call Combine() with four arguments fullName = Combine ( Directory.GetCurrentDirectory (), "bin", "config", "index.html"); Console.WriteLine (fullName); // Call Combine() with only three arguments fullName = Combine ( Environment.SystemDirectory, "Temp", "index.html"); Console.WriteLine (fullName); // Call Combine() with an array fullName = Combine ( new string[] &#123; "C:\\", "Data", "HomeDir", "index.html" &#125;); Console.WriteLine (fullName); // ... &#125; static string Combine (params string[] paths) &#123; string result = string.Empty; foreach (string path in paths) &#123; result = System.IO.Path.Combine (result, path); &#125; return result; &#125;&#125;/* 输出d:\WaProj\CSharpGuide\bin\config\index.htmlC:\Windows\system32\Temp\index.htmlC:\Data\HomeDir\index.html*/ 数组参数需要注意的地方 参数不一定是方法的唯一参数，但必须时方法声明中的最后一个参数。所以，只能有一个数组参数； 调用者可以显式地使用数组，而不必是以都好分隔的参数列表。最终生成的CIL代码是一样的。 递归递归是一项非常重要的编程技巧，它使函数调用其本身。 示例 返回目录中所有 .cs文件代码行总数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using System;using System.IO;public static class LineCounter &#123; // Use the first argument as the directory // to search, or default to the current directory. public static void Main (string[] args) &#123; int totalLineCount = 0; string directory; if (args.Length &gt; 0) &#123; directory = args[0]; &#125; else &#123; directory = Directory.GetCurrentDirectory (); &#125; totalLineCount = DirectoryCountLines (directory); System.Console.WriteLine (totalLineCount); &#125; static int DirectoryCountLines (string directory) &#123; int lineCount = 0; foreach (string file in Directory.GetFiles (directory, "*.cs")) &#123; lineCount += CountLines (file); &#125; foreach (string subdirectory in Directory.GetDirectories (directory)) &#123; lineCount += DirectoryCountLines (subdirectory); &#125; return lineCount; &#125; private static int CountLines (string file) &#123; string line; int lineCount = 0; FileStream stream = new FileStream (file, FileMode.Open); StreamReader reader = new StreamReader (stream); line = reader.ReadLine (); while (line != null) &#123; if (line.Trim () != "") &#123; lineCount++; &#125; line = reader.ReadLine (); &#125; reader.Close (); // Automatically closes the stream return lineCount; &#125;&#125; 示例 遍历目录中所有目录和文件，在终端中格式化输出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using System;using System.IO;namespace DirectoryFileList &#123; class Program &#123; static void Main (string[] args) &#123; string directory; if (args.Length &gt; 0) &#123; directory = args[0]; &#125; else &#123; directory = Directory.GetCurrentDirectory (); &#125; Console.WriteLine (directory); DirectoryFileList (directory, directory); Console.ReadKey (); &#125; static void DirectoryFileList (string beginDirectory, string currentDirectory) &#123; int level = currentDirectory.Split ('\\').Length - beginDirectory.Split ('\\').Length; string formatPrefix = "|--"; for (int currentLevel = 0; currentLevel &lt; level; currentLevel++) &#123; formatPrefix += "|--"; &#125; foreach (string subdirectory in Directory.GetDirectories (currentDirectory)) &#123; Console.WriteLine (formatPrefix + subdirectory.Substring (subdirectory.LastIndexOf ('\\'))); DirectoryFileList (beginDirectory, subdirectory); &#125; foreach (string file in Directory.GetFiles (currentDirectory)) &#123; Console.ForegroundColor = ConsoleColor.DarkGreen; Console.WriteLine (formatPrefix + Path.GetFileName (file)); Console.ForegroundColor = ConsoleColor.White; &#125; &#125; &#125;&#125;/* 输出d:\WaProj\CSharpGuide|--\.vscode|--|--launch.json|--|--tasks.json|--\bin|--|--\Debug|--|--|--\netcoreapp2.0|--|--|--|--CSharpGuide.deps.json|--|--|--|--CSharpGuide.dll|--|--|--|--CSharpGuide.pdb|--|--|--|--CSharpGuide.runtimeconfig.dev.json|--|--|--|--CSharpGuide.runtimeconfig.json|--\obj|--|--\Debug|--|--|--\netcoreapp2.0|--|--|--|--CSharpGuide.AssemblyInfo.cs|--|--|--|--CSharpGuide.AssemblyInfoInputs.cache|--|--|--|--CSharpGuide.csproj.CoreCompileInputs.cache|--|--|--|--CSharpGuide.csproj.FileListAbsolute.txt|--|--|--|--CSharpGuide.dll|--|--|--|--CSharpGuide.pdb|--|--CSharpGuide.csproj.nuget.cache|--|--CSharpGuide.csproj.nuget.g.props|--|--CSharpGuide.csproj.nuget.g.targets|--|--project.assets.json|--CSharpGuide.csproj|--Program.cs*/ 递归很容易陷入无限递归调用，编码/调试时多注意。 方法重载 Mathod Overloading一个类包含两个或者更多同名的方法，就会发生方法重载。以WriteLine()方法为例，可向它传递一个格式字符串和其他一些参数，也可以只传递一个整数。两者的实现肯定不同，但在逻辑上，对于调用者，这个方法就是负责输出数据，至于方法内部如恶化实现，调用者并不关心。 使用重载统计.cs文件中的行数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970using System.IO;public static class LineCounter &#123; public static void Main (string[] args) &#123; int totalLineCount; if (args.Length &gt; 1) &#123; totalLineCount = DirectoryCountLines (args[0], args[1]); &#125; if (args.Length &gt; 0) &#123; totalLineCount = DirectoryCountLines (args[0]); &#125; else &#123; totalLineCount = DirectoryCountLines (); &#125; System.Console.WriteLine (totalLineCount); &#125; static int DirectoryCountLines () &#123; return DirectoryCountLines ( Directory.GetCurrentDirectory ()); &#125; static int DirectoryCountLines (string directory) &#123; return DirectoryCountLines (directory, "*.cs"); &#125; static int DirectoryCountLines ( string directory, string extension) &#123; int lineCount = 0; foreach (string file in Directory.GetFiles (directory, extension)) &#123; lineCount += CountLines (file); &#125; foreach (string subdirectory in Directory.GetDirectories (directory)) &#123; lineCount += DirectoryCountLines (subdirectory); &#125; return lineCount; &#125; private static int CountLines (string file) &#123; int lineCount = 0; string line; FileStream stream = new FileStream (file, FileMode.Open); StreamReader reader = new StreamReader (stream); line = reader.ReadLine (); while (line != null) &#123; if (line.Trim () != "") &#123; lineCount++; &#125; line = reader.ReadLine (); &#125; reader.Close (); // Automatically closes the stream return lineCount; &#125;&#125; 可选参数(可选实参)方法、构造函数、索引器或委托的定义可以指定其形参为必需还是可选。 任何调用都必须为所有必需的形参提供实参，但可以为可选的形参省略实参。 每个可选形参都有一个默认值作为其定义的一部分。 如果没有为该形参发送实参，则使用默认值。 默认值必须是以下类型的表达式之一： 常量表达式； new ValType() 形式的表达式，其中 ValType 是值类型，例如 enum 或 struct； default(ValType) 形式的表达式，其中 ValType 是值类型。 可选参数定义于参数列表的末尾和必需参数之后。 如果调用方为一系列可选形参中的任意一个形参提供了实参，则它必须为前面的所有可选形参提供实参。例如，在以下代码中，使用一个必选形参和两个可选形参定义实例方法 ExampleMethod。 1public void ExampleMethod(int required, string optionalstr = "default string", int optionalint = 10) 下面对 ExampleMethod 的调用会导致编译器错误，原因是为第三个形参而不是为第二个形参提供了实参。 //anExample.ExampleMethod(3, ,4); 但是，如果知道第三个形参的名称，则可以使用命名实参来完成此任务。 anExample.ExampleMethod(3, optionalint: 4); 命名参数(命名实参)命名参数 是 C# 4.0 新增的方法调用功能。有了命名实参，你将不再需要记住或查找形参在所调用方法的形参列表中的顺序。 每个实参的形参都可按形参名称进行指定。 如果你不记得参数的顺序，但知道其名称，你可以按任何顺序发送自变量。 PrintOrderDetails(orderNum: 31, productName: &quot;Red Mug&quot;, sellerName: &quot;Gift Shop&quot;); PrintOrderDetails(productName: &quot;Red Mug&quot;, sellerName: &quot;Gift Shop&quot;, orderNum: 31); 高级主题：方法解析当编译器必须从一系列“适用”的方法中训责一个最适合某个特定调用的方法时，会选择拥有最据提的参数类型的那个方法。 如果有多个适用的方法，但无法从中挑选出最具唯一性的，编译器就会宝座，指明调用存在的歧义。 例如，给定以下的方法： 1234static void Method(object thing)&#123;&#125;static void Method(double thing)&#123;&#125;static void Method(long thing)&#123;&#125;static void Method(int thing)&#123;&#125; 调用 Method(42) 会被解析成 Method(int thing)，因为存在着一个从实参类型到形参类型的完全匹配的方法。如果删除该方法，那么重载解析会选择 long 版本，因为 long 比 double 和 object 更具体。 异常处理语句C# 提供用于处理反常情况（称为异常，可能会在执行程序的过程中发生）的内置支持。 这些异常由正常控制流之外的代码进行处理。 try-catchTry 块之后必须紧跟着一个或多个 catch 块（或/和一个 Finally 块），这些子句指定不同异常的处理程序。只要数据类型与异常类型匹配，对应的 catch 块就会执行。 在前面例子“遍历目录中所有目录和文件，在终端中格式化输出”中，如果权限不够，就会引发异常，下面例子加入异常处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using System;using System.IO;namespace DirectoryFileList &#123; class Program &#123; static void Main (string[] args) &#123; string directory; if (args.Length &gt; 0) &#123; directory = args[0]; &#125; else &#123; directory = Directory.GetCurrentDirectory (); &#125; Console.WriteLine (directory); DirectoryFileList (directory, directory); Console.ReadKey (); &#125; static void DirectoryFileList (string beginDirectory, string currentDirectory) &#123; int level = currentDirectory.Split ('\\').Length - beginDirectory.Split ('\\').Length; level = ((beginDirectory.Split ('\\') [1] == "") &amp;&amp; (currentDirectory.Split ('\\') [1] != "")) ? level + 1 : level; string formatPrefix = "|--"; for (int currentLevel = 0; currentLevel &lt; level; currentLevel++) &#123; formatPrefix += "|--"; &#125; try &#123; foreach (string subdirectory in Directory.GetDirectories (currentDirectory)) &#123; Console.WriteLine (formatPrefix + subdirectory.Substring (subdirectory.LastIndexOf ('\\'))); DirectoryFileList (beginDirectory, subdirectory); &#125; foreach (string file in Directory.GetFiles (currentDirectory)) &#123; Console.ForegroundColor = ConsoleColor.DarkGreen; Console.WriteLine (formatPrefix + Path.GetFileName (file)); Console.ForegroundColor = ConsoleColor.White; &#125; &#125; catch (UnauthorizedAccessException) &#123; System.Console.WriteLine ("发现受保护文件目录，禁止访问。"); &#125; catch (Exception exception) &#123; System.Console.WriteLine ("程序运行异常:" + exception); &#125; &#125; &#125;&#125; throwThrow会抛出/传递程序执行期间出现异常的信号,通过在catch块里使用throw语句.可以改变产生的异常,比如我们可以抛出一个新的异常。 C#允许开发人员从代码中引发异常，如下例所示： 123456789101112131415161718192021222324252627282930using System;public class ThrowingExceptions &#123; public static void Main () &#123; try &#123; Console.WriteLine ("Begin executing"); Console.WriteLine ("Throw exception"); throw new Exception ("自定义异常"); Console.WriteLine ("End executing"); //永远不会执行 &#125; catch (FormatException exception) &#123; Console.WriteLine ( "A FormateException was thrown"); &#125; catch (Exception exception) &#123; Console.WriteLine ( "Unexpected error: &#123;0&#125;", exception.Message); &#125; catch //永远不会执行 &#123; Console.WriteLine ("Unexpected error!"); &#125; Console.WriteLine ( "Shutting down..."); &#125;&#125;/* 输出Begin executingThrow exceptionUnexpected error: 自定义异常Shutting down...*/ 有时catch块能捕捉到异常，但不能正确或者完整处理它。这种情况下，可以让这个catch块重新抛出异常，据提办法时使用一个单独的throw语句，不要在它后面指定任何异常。 throw; 和 throw exception;的区别：throw; 保持了异常中的“调用栈”信息，而throw exception;将那些信息替换成当前调用栈信息。如下例所示： 12345678910111213141516171819202122232425262728293031323334353637using System;class Program &#123; static void Main () &#123; try &#123; X (); &#125; catch (Exception ex) &#123; Console.WriteLine ("X throw：" + ex.TargetSite); &#125; try &#123; Y (); &#125; catch (Exception ex) &#123; Console.WriteLine ("Y throw：" + ex.TargetSite); &#125; &#125; static void X () &#123; try &#123; int.Parse ("?"); &#125; catch (Exception) &#123; throw; // Rethrow 构造 &#125; &#125; static void Y () &#123; try &#123; int.Parse ("?"); &#125; catch (Exception ex) &#123; throw ex; // Throw 捕获的ex变量 &#125; &#125;&#125;/*X throw：Void StringToNumber(System.String, System.Globalization.NumberStyles, NumberBuffer ByRef, System.Globalization.NumberFormatInfo, Boolean)Y throw：Void Y()*/ throw; | throw exception; | throw new exception; 区别示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091using System;class hello &#123; public static void Main () &#123; ExceptionClass ec = new ExceptionClass (); try &#123; ec.ExceptionThrow1 (); &#125; catch (Exception ex) &#123; Console.WriteLine (ex.ToString ()); &#125; try &#123; ec.ExceptionThrow2 (); &#125; catch (Exception ex) &#123; Console.WriteLine (ex.ToString ()); &#125; try &#123; ec.ExceptionThrow3 (); &#125; catch (Exception ex) &#123; Console.WriteLine (ex.ToString ()); &#125; try &#123; ec.ExceptionThrow4 (); &#125; catch (Exception ex) &#123; Console.WriteLine (ex.ToString ()); &#125; Console.ReadKey (); &#125;&#125;public class ExceptionClass &#123; public void ExceptionThrow1 () &#123; try &#123; // 调用原始异常抛出方法来抛出异常 this.ExceptionMethod (); &#125; catch (Exception ex) &#123; throw ex; &#125; &#125; public void ExceptionThrow2 () &#123; try &#123; this.ExceptionMethod (); &#125; catch (Exception ex) &#123; throw; &#125; &#125; public void ExceptionThrow3 () &#123; try &#123; this.ExceptionMethod (); &#125; catch &#123; throw; &#125; &#125; public void ExceptionThrow4 () &#123; try &#123; this.ExceptionMethod (); &#125; catch (Exception ex) &#123; throw new Exception ("经过进一步包装的异常", ex); &#125; &#125; private void ExceptionMethod () &#123; throw new DivideByZeroException (); &#125;&#125;/* 输出System.DivideByZeroException: Attempted to divide by zero. at ExceptionClass.ExceptionThrow1() in d:\WaProj\CSharpGuide\Program.cs:line 47 at hello.Main() in d:\WaProj\CSharpGuide\Program.cs:line 8System.DivideByZeroException: Attempted to divide by zero. at ExceptionClass.ExceptionMethod() in d:\WaProj\CSharpGuide\Program.cs:line 88 at ExceptionClass.ExceptionThrow2() in d:\WaProj\CSharpGuide\Program.cs:line 58 at hello.Main() in d:\WaProj\CSharpGuide\Program.cs:line 14System.DivideByZeroException: Attempted to divide by zero. at ExceptionClass.ExceptionMethod() in d:\WaProj\CSharpGuide\Program.cs:line 88 at ExceptionClass.ExceptionThrow3() in d:\WaProj\CSharpGuide\Program.cs:line 69 at hello.Main() in d:\WaProj\CSharpGuide\Program.cs:line 20System.Exception: 经过进一步包装的异常 ---&gt; System.DivideByZeroException: Attempted to divide by zero. at ExceptionClass.ExceptionMethod() in d:\WaProj\CSharpGuide\Program.cs:line 88 at ExceptionClass.ExceptionThrow4() in d:\WaProj\CSharpGuide\Program.cs:line 78 --- End of inner exception stack trace --- at ExceptionClass.ExceptionThrow4() in d:\WaProj\CSharpGuide\Program.cs:line 80 at hello.Main() in d:\WaProj\CSharpGuide\Program.cs:line 26*/ 结尾]]></content>
      <tags>
        <tag>C#</tag>
        <tag>C#本质论</tag>
        <tag>Essential C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 使用配置]]></title>
    <url>%2F2017%2F12%2F18%2FHexo-Next-%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Pisces子主题页面留白太多问题修改 next/source/css/_schemes/Pisces/_layout.styl 文件中下面的字段内容： 123.header&#123; width: 80%; &#125; /* 80% */.container .main-inner &#123; width: 80%; &#125; /* 80% */.content-wrap &#123; width: calc(100% - 260px); &#125; 完整文件参见 这个地址。 文章中嵌入html页面在文章中插入 iframe。 直接使用 Hexo 标签插件 在 Markdown 文件中，可以直接使用 Hexo 标签插件来实现，在文章中插入 iframe。 {% iframe url [width] [height] %} 直接使用 HTML 语句 1&lt;iframe src="http://example.com" width="700px" height="500px" frameborder="0" scrolling="no"&gt;&lt;/iframe&gt; 指定在新窗口打开文章中的链接 使用 Hexo 标签插件 在 Markdown 文件中，可以直接使用 Hexo 标签插件来实现，在文章中插入链接，并自动给外部链接添加 target=&quot;_blank&quot; 属性。方法如下： {% link text url [external] [title] %} 使用 HTML 语句 可以在 Markdown 文件或者 HTML 文件中采用下面的写法： 1&lt;a href="http://example.com/" target="_blank"&gt;Hello, world!&lt;/a&gt; 让 Hexo 忽略编译指定文件或目录 写在前面 编辑保存后，一定要执行 Hexo clean 命令，然后再执行 hexo g -d 命令，否则不生效，这个有点坑。😥 Hexo 编译 站点目录 下的 source 目录下的文件。skip_render 参数设置的路径是相对于 source 目录的路径。 编辑 站点配置文件 \blog\_config.yml 的 skip_render: 位置，比如 GitHub 的 reaadme.md、404文件、搜索引擎验证文件等，都不需要 Hexo 进行编译，示例如下： 12345skip_render:- readme.md //排除 readme.md- 404.html //排除 404.html- demo/** //排除 /source/demo目录中所有文件- demo/*.html //排除 /source/demo目录中所有后缀为 html 的文件 修改文章内链接文本样式将链接文本设置为 蓝色，鼠标划过时文字 颜色加亮，并显示下划线。 修改文件 themes\next\source\css\_common\components\post\post.styl，添加如下 css 样式： 12345678910111213141516171819202122// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;.post-body li a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 修改字体编辑主题文件 themes\next\source\css\_variables\custom.styl，增加以下内容： // 标题，修改成你期望的字体族 $font-family-headings = Georgia, sans // 修改成你期望的字体族 $font-family-base = &quot;Microsoft YaHei&quot;, Verdana, sans-serif // 代码字体 $code-font-family = &quot;Input Mono&quot;, &quot;PT Mono&quot;, Consolas, Georgia, Monaco, Menlo, monospace // 正文字体的大小 $font-size-base = 16px // 代码字体的大小 $code-font-size = 14px 修改代码块自定义样式 修改 CSS 样式文件后，基本都要执行 hexo clean 再编译/发布，才能生效。 打开自定义CSS： \themes\next\source\css\_custom\custom.styl 加入以下内容，可根据自己的情况进行调整： 123456789101112// 代码块自定义样式``内的code &#123; color: #fc6423; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 2px 0; padding: 2px; border-radius: 3px;&#125; 侧边栏嵌入网易云音乐修改 \themes\next\layout_custom\sidebar.swig，加入下面代码： 1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&amp;id=网易云音乐歌单ID&amp;auto=0&amp;height=90"&gt;&lt;/iframe&gt; 上面的网易云音乐歌单ID改成网易云音乐某个歌单的ID，不是用户ID，参考链接。另外，专辑中一定不要有存在版权问题的歌曲，否则不能播放，也即是说，允许用户无条件下载的歌曲才可以。 部分内容参考以下博客： Moorez 二次元の技术宅]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next 主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#本质论笔记 第3章 操作符和控制流]]></title>
    <url>%2F2017%2F12%2F17%2FCSharp%E6%9C%AC%E8%B4%A8%E8%AE%BA%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E6%8E%A7%E5%88%B6%E6%B5%81%2F</url>
    <content type="text"><![CDATA[操作符 Operators操作符，也叫运算符，英文：Operrators，见 Microsoft Docs C# 运算符。 名称 含义 例子 一元运算符 接受一个操作数的运算符 ++ 或 new 二元运算符 接受两个操作数的运算符 + - * / 三元运算符 接受三个操作数，C#中唯一的条件运算符 ?: 一元操作符 表达式 描述 说明 +x 标识 +5 ，正号，无意义，出于对 - 操作符的对称才加进来的 -x 求反 -5 ，负号，等价于从零减去操作数 ! 逻辑求反 它针对 bool 定义，当且仅当其操作数为 false 时返回 true。 ~x 按位求反 影响操作数的每一个位(bit) ++x 前递增 操作的结果是操作数递增后的值。 x++ 后递增 操作的结果是操作数递增前的值。 --x 前递减 操作的结果是操作数递减后的值。 x-- 后递减 操作的结果是操作数递减前的值。 (T)x 将 x 显式转换为类型 T 指定强制转换或类型转换。 递增和递减操作符 ++ --递增运算符（Post-Increment）++ 按 1 递增其操作数。 递增运算符可以在其操作数之前或之后出现： ++variable 和 variable++。第一种形式是前缀递增操作。 操作的结果是操作数递增后的值。 第二种形式是后缀递增操作。 操作的结果是操作数递增前的值。 递减运算符 (Post-Decrement） -- 按 1 递减其操作数。 减量运算符可以在其操作数之前或之后出现：–variable 和 variable–。 第一种形式是前缀递减操作。 操作的结果是操作数递减后的值。 第二种形式是后缀递减操作。 操作的结果是操作数递减前的值。 123456int x = 123;int y = 123;// 输出 123,124,125System.Console.WriteLine ("&#123;0&#125;,&#123;1&#125;,&#123;2&#125;", x++, x++, x);// 输出 124,125,125System.Console.WriteLine ("&#123;0&#125;,&#123;1&#125;,&#123;2&#125;", ++y, ++y, y); 选择语句if-else 下列中，如果 m &gt; 10 不成立，后面代码全部不执行 12345678910111213// Try with m = 12 and then with m = 8.int m = 12;int n = 18;if (m &gt; 10) if (n &gt; 20) &#123; Console.WriteLine("Result1"); &#125; else &#123; Console.WriteLine("Result2"); &#125; 下列中，如果 m &gt; 10 不成立，则执行 else 部分代码 1234567891011121314// Try with m = 12 and then with m = 8.int m = 12;int n = 18;// Try with m = 12 and then with m = 8.if (m &gt; 10)&#123; if (n &gt; 20) Console.WriteLine("Result1");&#125;else&#123; Console.WriteLine("Result2");&#125; 可以将 if 语句嵌套到 else 块中，如以下部分代码所示。 1234567891011121314151617181920212223242526272829// Change the values of these variables to test the results.bool Condition1 = true;bool Condition2 = true;bool Condition3 = true;bool Condition4 = true;if (Condition1)&#123; // Condition1 is true.&#125;else if (Condition2)&#123; // Condition1 is false and Condition2 is true.&#125;else if (Condition3)&#123; if (Condition4) &#123; // Condition1 and Condition2 are false. Condition3 and Condition4 are true. &#125; else &#123; // Condition1, Condition2, and Condition4 are false. Condition3 is true. &#125;&#125;else&#123; // Condition1, Condition2, and Condition3 are false.&#125; switch针对 3 个或更多条件测试单个表达式，switch 语句通常用作 if-else 结构的替代项。 示例 123456789101112131415161718192021222324using System;public class Example&#123; public static void Main() &#123; int caseSwitch = 1; switch (caseSwitch) &#123; case 1: Console.WriteLine("Case 1"); break; case 2: Console.WriteLine("Case 2"); break; default: Console.WriteLine("Default case"); break; &#125; &#125;&#125;// The example displays the following output:// Case 1 开关部分C# 不允许从一个开关部分继续执行到下一个开关部分。 因此，以下代码将生成编译器错误。 error CS0163: 控制不能从一个 case 标签(“case 1:”)贯穿到另一个 case 标签 12345678910switch (caseSwitch)&#123; // The following switch section causes an error. case 1: Console.WriteLine("Case 1..."); // Add a break or other jump statement here. case 2: Console.WriteLine("... and/or Case 2"); break;&#125; default casedefault case 可以在 switch 语句中以任何顺序显示。 无论其在源代码中的顺序如何，都将在对所有 case 标签进行计算之后，最后对其进行计算。 匹配表达式匹配表达式提供与 case 标签中的模式相匹配的值。 语法为： switch (expr) 在 C# 6 中，匹配表达式必须是返回以下类型值的表达式： 字符型。 字符串。 bool。 整数值，例如 int 或 long。 枚举值。 从 C# 7 开始，匹配表达式可以是任何非 null 表达式。 switch 语句的 模式匹配每个 case 语句定义一个模式，如果它与匹配表达式相匹配，则会导致执行其包含的开关部分。 所有版本的 C# 都支持常量模式。 其余模式从 C# 7 开始支持。 常量模式常量模式测试匹配表达式是否等于指定常量。 语法为： case constant: 其中 constant 是要测试的值。 constant 可以是以下任何常数表达式： bool 文本，为 true 或 false。 任何整数常量，例如 int、long 或字节。 已声明 const 变量的名称。 一个枚举常量。 字符型文本。 字符串文本。 示例 使用常量模式来确定特定日期是否为周末、工作周的第一天、工作周的最后一天或工作周的中间日期。 它根据 DayOfWeek 枚举的成员计算当前日期的 DateTime.DayOfWeek 属性。 1234567891011121314151617181920212223242526using System;class Program&#123; static void Main() &#123; switch (DateTime.Now.DayOfWeek) &#123; case DayOfWeek.Sunday: case DayOfWeek.Saturday: Console.WriteLine("The weekend"); break; case DayOfWeek.Monday: Console.WriteLine("The first day of the work week."); break; case DayOfWeek.Friday: Console.WriteLine("The last day of the work week."); break; default: Console.WriteLine("The middle of the work week."); break; &#125; &#125;&#125;// The example displays output like the following:// The middle of the work week. 类型模式类型模式可启用简洁类型计算和转换。 使用 switch 语句执行模式匹配时，会测试表达式是否可转换为指定类型，如果可以，则将其转换为该类型的一个变量。 语法为： case type varname 示例 使用类型模式来提供有关各种集合类型的信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;using System.Collections;using System.Collections.Generic;using System.Linq;class Example&#123; static void Main(string[] args) &#123; int[] values = &#123; 2, 4, 6, 8, 10 &#125;; ShowCollectionInformation(values); var names = new List&lt;string&gt;(); names.AddRange( new string[] &#123; "Adam", "Abigail", "Bertrand", "Bridgette" &#125; ); ShowCollectionInformation(names); List&lt;int&gt; numbers = null; ShowCollectionInformation(numbers); &#125; private static void ShowCollectionInformation(object coll) &#123; switch (coll) &#123; case Array arr: Console.WriteLine($"An array with &#123;arr.Length&#125; elements."); break; case IEnumerable&lt;int&gt; ieInt: Console.WriteLine($"Average: &#123;ieInt.Average(s =&gt; s)&#125;"); break; case IList list: Console.WriteLine($"&#123;list.Count&#125; items"); break; case IEnumerable ie: string result = ""; foreach (var item in ie) result += "$&#123;e&#125; "; Console.WriteLine(result); break; case null: // Do nothing for a null. break; default: Console.WriteLine($"A instance of type &#123;coll.GetType().Name&#125;"); break; &#125; &#125;&#125;// The example displays the following output:// An array with 5 elements.// 4 items case 语句和 when 子句从 C# 7 开始，因为 case 语句不需要互相排斥，因此可以添加 when 子句来指定必须满足的附加条件使 case 语句计算为 true。 when 子句可以是返回布尔值的任何表达式。 when 子句的更常见用法之一是防止在匹配表达式的值为 null 时执行开关部分。 据提参见 Microsoft Docs : swittch 关键字 -&gt; case 语句和 when 子句 高级主题：switch case 和 枚举值 直接利用枚举值例子 123456789101112131415161718192021222324252627282930using System;public class EnumSwitchCase&#123; enum Days &#123; Sunday = 6, Monday = 3, Tuesday, Wednesday, Thursday, Friday, Saturday &#125;; static void Main() &#123; Days Day = Days.Tuesday; switch (Day) &#123; case Days.Sunday: Console.WriteLine(Days.Sunday); break; case Days.Monday: Console.WriteLine(Days.Monday); break; case Days.Tuesday: Console.WriteLine(Days.Tuesday); break; default: break; &#125; Console.ReadKey(); &#125;&#125;/* 输出Tuesday*/ 枚举值显式显式转换例子 12345678910111213141516171819202122232425262728293031using System;public class EnumTest&#123; enum Day &#123; Sunday = 6, Monday = 3, Tuesday, Wednesday, Thursday, Friday, Saturday &#125;; static void Main() &#123; int ienum = 4; switch (ienum) &#123; case (int)Day.Sunday: Console.WriteLine(Day.Sunday); break; case (int)Day.Monday: Console.WriteLine(Day.Monday); break; case (int)Day.Tuesday: Console.WriteLine(Day.Tuesday); break; default: break; &#125; Console.ReadKey(); &#125;&#125;/* 输出Tuesday*/ 迭代语句dodo 语句重复执行一个语句或语句块，直到指定的表达式计算为 false 值。 循环体必须括在大括号 {} 内，除非它由单个语句组成。 在这种情况下，大括号是可选的。 在下面的示例中，只要变量 x 小于 5，do-while 循环语句就开始执行。 1234567891011121314151617181920public class TestDoWhile&#123; public static void Main () &#123; int x = 0; do &#123; Console.WriteLine(x); x++; &#125; while (x &lt; 5); &#125;&#125;/* Output: 0 1 2 3 4*/ 与 while 语句不同的是，do-while 循环会在计算条件表达式之前执行一次。 在 do-while 块中的任何点，都可使用 ==break== 语句跳出循环。 可通过使用 ==continue== 语句直接步入 while 表达式计算语句。 如果 while 表达式计算结果为 true，则继续执行循环中的第一个语句。 如果表达式的计算结果为 false，则继续执行 do-while 循环后的第一个语句。 do-while 循环还可以通过 goto、return 或 throw 语句退出。 whilewhile 语句执行一条语句或一个语句块，直到指定的表达式的计算结果为 false 为止。 示例 1234567891011121314151617181920class WhileTest&#123; static void Main() &#123; int n = 1; while (n &lt; 6) &#123; Console.WriteLine("Current value of n is &#123;0&#125;", n); n++; &#125; &#125;&#125;/* Output: Current value of n is 1 Current value of n is 2 Current value of n is 3 Current value of n is 4 Current value of n is 5 */ 因为 while 表达式的测试在每次执行循环之前开始，所以 while 循环执行零次或多次。 这不同于 do 循环，该循环执行一次或多次。 break、goto、return 或 throw 语句将控制转移到循环外时，while 循环可能终止。 若要将控制传递到下一个迭代，而不退出循环，则使用 continue 语句。 for使用 for 循环，可以重复运行一个语句或语句块，直到指定的表达式的计算结果为 false 为止。 这种类型的循环可用于循环==访问数组==，以及==事先知道==循环要在其中进行==循环访问的次数==的其他应用程序。 在下面的示例中，i 的值被写入控制台，并在循环的每次迭代过程中递增 1。 123456789101112131415161718class ForLoopTest&#123; static void Main() &#123; for (int i = 1; i &lt;= 5; i++) &#123; Console.WriteLine(i); &#125; &#125;&#125;/*Output:12345*/ 因为 while 表达式的测试在每次执行循环之前开始，所以 while 循环执行零次或多次。 这不同于 do 循环，该循环执行一次或多次。 break、goto、return 或 throw 语句将控制转移到循环外时，while 循环可能终止。 若要将控制传递到下一个迭代，而不退出循环，则使用 continue 语句。 下面的示例阐释了几种不太常见的选择：为初始化表达式部分中的外部循环变量赋值、同时在初始化表达式部分和迭代器部分中调用 Console.WriteLine 方法，以及更改迭代器部分中的两个变量的值。 12345678910111213141516static void Main() &#123; int i; int j = 10; for (i = 0, Console.WriteLine("Start: &#123;0&#125;",i); i &lt; j; i++, j--, Console.WriteLine("i=&#123;0&#125;, j=&#123;1&#125;", i, j)) &#123; // Body of the loop. &#125; &#125; // Output: // Start: 0 // i=1, j=9 // i=2, j=8 // i=3, j=7 // i=4, j=6 // i=5, j=5 定义 for 语句的所有表达式都是可选的。 例如，以下语句创建一个无限循环。 1234for (; ; )&#123; // ...&#125; foreach inforeach 语句针对实现 System.Collections.IEnumerable 或 System.Collections.Generic.IEnumerable 接口的数组或集合中的每个元素重复一组嵌入语句。 在 foreach 块中的任何点上，可以使用 break 中断关键字中断该循环，或者可以使用 continue 继续关键字单步执行到循环中的下一次迭代。 显示整数数组内容的典型 foreach 循环 123456789101112131415int[] fibarray = new int[] &#123; 0, 1, 1, 2, 3, 5, 8, 13 &#125;;foreach (int element in fibarray)&#123; System.Console.WriteLine(element);&#125;System.Console.WriteLine();// Output:// 0// 1// 1// 2// 3// 5// 8// 13 执行相同操作的 for 循环 12345678910111213141516int[] fibarray = new int[] &#123; 0, 1, 1, 2, 3, 5, 8, 13 &#125;;// Compare the previous loop to a similar for loop.for (int i = 0; i &lt; fibarray.Length; i++)&#123; System.Console.WriteLine(fibarray[i]);&#125;System.Console.WriteLine();// Output:// 0// 1// 1// 2// 3// 5// 8// 13 维护数组中元素数计数的 foreach 循环 12345678910111213141516171819int[] fibarray = new int[] &#123; 0, 1, 1, 2, 3, 5, 8, 13 &#125;;// You can maintain a count of the elements in the collection.int count = 0;foreach (int element in fibarray)&#123; count += 1; System.Console.WriteLine("Element #&#123;0&#125;: &#123;1&#125;", count, element);&#125;System.Console.WriteLine("Number of elements in the array: &#123;0&#125;", count);// Output:// Element #1: 0// Element #2: 1// Element #3: 1// Element #4: 2// Element #5: 3// Element #6: 5// Element #7: 8// Element #8: 13// Number of elements in the array: 8 因为 while 表达式的测试在每次执行循环之前开始，所以 while 循环执行零次或多次。 这不同于 do 循环，该循环执行一次或多次。 跳转语句使用跳转语句执行分支，这将立即转移程序控制。 事实上，可以用跳转语句退出循环，或者跳过以此循环的剩余部分并开始下一次循环–即使当前循环条件仍然为true。跳转语句中使用下列关键字： break continue goto return breakC#使用brek语句退出循环或者switch语句。任何时候遇到break语句，控制都会立即离开循环或者switch。 break 语句将终止其所在位置的最接近封闭循环或 switch 语句。 控制权将传递给已终止语句后面的语句（若有）。 示例 在此示例中，条件语句包含一个应从 1 计数到 100 的计数器；但 break 语句在计数器计数到 4 后终止了循环。 12345678910111213141516171819202122232425class BreakTest&#123; static void Main() &#123; for (int i = 1; i &lt;= 100; i++) &#123; if (i == 5) &#123; break; &#125; Console.WriteLine(i); &#125; // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;/* Output: 1 2 3 4*/ 示例 在此示例中，break 语句用于中断内层嵌套循环，并将控制权返回给外层循环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class BreakInNestedLoops&#123; static void Main(string[] args) &#123; int[] numbers = &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; char[] letters = &#123; 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j' &#125;; // Outer loop for (int x = 0; x &lt; numbers.Length; x++) &#123; Console.WriteLine("num = &#123;0&#125;", numbers[x]); // Inner loop for (int y = 0; y &lt; letters.Length; y++) &#123; if (y == x) &#123; // Return control to outer loop break; &#125; Console.Write(" &#123;0&#125; ", letters[y]); &#125; Console.WriteLine(); &#125; // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;/* * Output: num = 0 num = 1 a num = 2 a b num = 3 a b c num = 4 a b c d num = 5 a b c d e num = 6 a b c d e f num = 7 a b c d e f g num = 8 a b c d e f g h num = 9 a b c d e f g h i */ continuecontinue 语句将控制传递到其中出现的封闭 while、do、for 或 foreach 语句的下一次迭代。如果循环条件仍然为 true，循环将继续执行。 示例 在本示例中，计数器最初是从 1 到 10 进行计数。 通过结合使用 continue 语句和表达式 (i &lt; 9)，跳过 continue 和 for 主体末尾之间的语句。 1234567891011121314151617181920212223class ContinueTest&#123; static void Main() &#123; for (int i = 1; i &lt;= 10; i++) &#123; if (i &lt; 9) &#123; continue; &#125; Console.WriteLine(i); &#125; // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;/*Output:910*/ gotoC# 确实支持 goto ，并且，不仅仅可以用在 switch 语句中。 goto 语句将程序控制直接传递给标记语句。 goto 的一个通常用法是将控制传递给特定的 switch-case 标签或 switch 语句中的默认标签。 goto 语句还用于跳出深嵌套循环。 示例 下面的示例演示了 goto 在 switch 语句中的使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class SwitchTest&#123; static void Main() &#123; Console.WriteLine("Coffee sizes: 1=Small 2=Medium 3=Large"); Console.Write("Please enter your selection: "); string s = Console.ReadLine(); int n = int.Parse(s); int cost = 0; switch (n) &#123; case 1: cost += 25; break; case 2: cost += 25; goto case 1; case 3: cost += 50; goto case 1; default: Console.WriteLine("Invalid selection."); break; &#125; if (cost != 0) &#123; Console.WriteLine("Please insert &#123;0&#125; cents.", cost); &#125; Console.WriteLine("Thank you for your business."); // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;/*Sample Input: 2Sample Output:Coffee sizes: 1=Small 2=Medium 3=LargePlease enter your selection: 2Please insert 50 cents.Thank you for your business.*/ 示例 下面的示例演示了使用 goto 跳出嵌套循环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class GotoTest1&#123; static void Main() &#123; int x = 200, y = 4; int count = 0; string[,] array = new string[x, y]; // Initialize the array: for (int i = 0; i &lt; x; i++) for (int j = 0; j &lt; y; j++) array[i, j] = (++count).ToString(); // Read input: Console.Write("Enter the number to search for: "); // Input a string: string myNumber = Console.ReadLine(); // Search: for (int i = 0; i &lt; x; i++) &#123; for (int j = 0; j &lt; y; j++) &#123; if (array[i, j].Equals(myNumber)) &#123; goto Found; &#125; &#125; &#125; Console.WriteLine("The number &#123;0&#125; was not found.", myNumber); goto Finish; Found: Console.WriteLine("The number &#123;0&#125; is found.", myNumber); Finish: Console.WriteLine("End of search."); // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;/*Sample Input: 44Sample OutputEnter the number to search for: 44The number 44 is found.End of search.*/ returnreturn 语句可终止它所在的方法的执行，并将控制权返回给调用方法。 它还可以返回可选值。 如果方法是 void 类型，则 return 语句可以省略。 示例 在下面的示例中，该方法CalculateArea()返回局部变量area作为double值 1234567891011121314151617181920class ReturnTest&#123; static double CalculateArea(int r) &#123; double area = r * r * Math.PI; return area; &#125; static void Main() &#123; int radius = 5; double result = CalculateArea(radius); Console.WriteLine("The area is &#123;0:0.00&#125;", result); // Keep the console open in debug mode. Console.WriteLine("Press any key to exit."); Console.ReadKey(); &#125;&#125;// Output: The area is 78.54 C# 预处理指令控制流语句中的表达式是在运行时求值。相反，C#预处理器在编译时调用。 #define 和 #undef使用 #define 来定义符号。 将符号用作传递给 #if 指令的表达式时，该表达式的计算结果为 true，如以下示例所示： #define DEBUG 还可以通过 /define 编译器选项来定义符号。 可以通过 #undef 取消定义符号。 #undef 允许你定义一个符号，这样一来，通过将该符号用作 #if 指令中的表达式，表达式将计算为 false。 #if, #elif, #else, 和 #endif以 #if 指令开头的条件指令必须以 #endif 指令显式终止 12345678910111213141516171819// preprocessor_if.cs#define DEBUG#define MYTESTusing System;public class MyClass&#123; static void Main() &#123;#if (DEBUG &amp;&amp; !MYTEST) Console.WriteLine("DEBUG is defined");#elif (!DEBUG &amp;&amp; MYTEST) Console.WriteLine("MYTEST is defined");#elif (DEBUG &amp;&amp; MYTEST) Console.WriteLine("DEBUG and MYTEST are defined");#else Console.WriteLine("DEBUG and MYTEST are not defined");#endif &#125;&#125; #warning 和 #error #warning 可从代码中的特定位置生成一个级别的警告。 #error 可从代码中的特定位置生成错误。 编译器遇到 #warning 指令，会显示 #warning 指令后面的文本，然后继续编译。 编译器遇到 #error 指令，会显示后面的文本，然后立即退出编译，不会生成IL代码。 #region 和 #endregion利用 #region 和 #endregion，可以指定在使用 Visual Studio 编辑器的大纲功能时可展开或折叠的代码块。 #region 块必须通过 #endregion 指令终止。 #region 块不能与 #if 块重叠。 但是，可以将 #region 块嵌套在 #if 块内，或将 #if 块嵌套在 #region 块内。 #line #line 可修改编译器的行号及（可选）用于错误和警告的文件名输出。 此示例演示如何报告与行号相关联的两个警告。 #line 200 指令将行号强制设为 200（尽管默认值为 #7），直到下一个 #line 指令前，文件名都将报告为“特殊”。 #line 默认指令将行号返回至其默认行号，默认行号对由上个指令重新编号的行进行计数。 123456789101112131415class MainClass&#123; static void Main() &#123;#line 200 "Special" int i; // CS0168 on line 200 int j; // CS0168 on line 201#line default char c; // CS0168 on line 9 float f; // CS0168 on line 10#line hidden // numbering not affected string s; double d; // CS0168 on line 13 &#125;&#125; #line hidden 指令能对调试程序隐藏连续行，当开发者逐行执行代码时，介于 #line hidden 和下一 #line 指令（假设它不是其他 #line hidden 指令）间的任何行都将被跳过。 意思是，调试器会执行 #hidden 后面代码，只是不会在 #hidden 后面代码调试停留。即便设置了断点，也会被调试器忽略。 示例 下列示例演示调试程序如何忽略代码中的隐藏行。 运行示例时，它将显示三行文本。 但是，如果按照示例所示设置断点、并按 F10 逐行执行代码，可观察到调试程序忽略隐藏行。 另请注意，即使在隐藏行设置断点，调试程序仍将忽略它。C# 12345678910111213// preprocessor_linehidden.csusing System;class MainClass&#123; static void Main() &#123; Console.WriteLine("Normal line #1."); // Set break point here.#line hidden Console.WriteLine("Hidden line.");#line default Console.WriteLine("Normal line #2."); &#125;&#125; 运行时输出结果： Normal line #1. Hidden line. Normal line #2. #pragam #pragma 指令可以启用或者禁用特定的编译警告。 下面例子禁止“字段未使用”警告，然后在编译MyClass类后还原该警告。 123456#pragma warning disable 169public class MyClass&#123; int neverUsedField;&#125;#pragma warning restore 169 若要查找警告编号，请在 Visual Studio 中生成项目，然后在“输出”窗口中查找警告编号。这是要干嘛？😥 结尾]]></content>
      <tags>
        <tag>C#</tag>
        <tag>C#本质论</tag>
        <tag>Essential C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio Code VSCode 常用 插件 扩展]]></title>
    <url>%2F2017%2F12%2F14%2FVisual-Studio-Code-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[界面主题 Monokai : VSCcode 内置主题 Agila : 包含多个主题 Dark-Dracula Theme : Dracula 风格主题里面比较好的 Nosferatu : Dracula 风格主题 monokai light : 白色，背景色类色默认的vs亮色主题背景 FlatUI : 包含多个主题 Flatland Monokai Theme : theme-dark-monokai : Monokai Dark Soda : Monokai Light : 图标主题 vscode-icons：Icons : 主要推荐 material icon theme : 备选 功能插件 C# : VSCode 开发 C# 必备 C# FixFormat : 格式化代码，好用 C# Extensions : 提高开发效率的扩展工具 Bracket Pair Colorizer ：对括号对进行着色，再也不会眼晕了。 Markdown All in One : All in One ，好用 markdownlint : 编写 Markdown 文件时智能提示，有助于养成好习惯。 Markdown Table Prettifier : Markdown 文件中，对表格进行强制格式化，看起来更整齐，舒服。 XML Tools ：作者 Josh Johnson - XML 格式化/Tree View XML Tools （备选） : 作者 Qub - 格式化XML文档 Alt+Shift+F Output Colorizer : 可以终端日志输出着色，实用 vscode-fileheader: 添加头header comment Setting Sync: 同步你的设置和插件]]></content>
      <tags>
        <tag>VSCode</tag>
        <tag>插件</tag>
        <tag>Visual Studio</tag>
        <tag>Visual Studio Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐2个好看的linux发行版本]]></title>
    <url>%2F2017%2F12%2F14%2F%E6%8E%A8%E8%8D%902%E4%B8%AA%E5%A5%BD%E7%9C%8B%E7%9A%84linux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[feren OS官网地址：https://ferenos.weebly.com/ 界面截图 elementary OS官网地址：http://www.elementary.io/ 界面截图]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>elementary OS</tag>
        <tag>feren OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NumLock灯在多个linux版本中的不同设置方法]]></title>
    <url>%2F2017%2F12%2F14%2FNumLock%E7%81%AF%E5%9C%A8%E5%A4%9A%E4%B8%AAlinux%E7%89%88%E6%9C%AC%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[elementary OS第一步：安装numlockx，输入命令 sudo apt-get install numlockx 第二步：用 vim 打开 /etc/lightdm/pantheon-greeter.conf 文件，取消numlock行前面的 # # activate-numlock=true. 结果如下图： 最后：重启或者注销后。小键盘就可以自动启动了 Tips: vim怎么插入内容呢？ 快捷键 i 切换到插入模式 方向键调整光标到插入位置 复制粘贴代码 Esc键退出插入模式，回到默认的命令模式 输入命令 :wq 表示保存并退出 ferenOS，Linux Mint第一步：安装numlockx，输入命令 sudo apt-get install numlockx 第二步：用 vim 打开 /etc/lightdm/lightdm.conf文件，最后一行添加 greeter-setup-script=/usr/bin/numlockx on Tips: 敲入下面命令编辑文件 sudo vi /etc/lightdm/lightdm.conf 结果如下图： 同样的，重启或者注销后，生效。 CentOS ，Scientific Linux，Fedora and other rpm based 先安装numlockx,可以去opensuse的软件中心里找rpm包进行安装 下载地址：https://pkgs.org/download/numlockx/ 安装命令： sudo rpm -i numlockx-1.2-6.el7.nux.x86_64.rpm 或者：sudo yum install numlockx 先备份 cp /etc/gdm/Init/Default /etc/gdm/Init/Default_backup 再修改 vim /etc/gdm/Init/Default 在exit 0之前加上/usr/bin/numlockx on,重启就会发现小键盘已经打开了！ Ubuntu and other debian based基于 gdm安装 numlockx ,在终端中输入命令： sudo apt-get install numlockx 配置 numlockx sudo gedit /etc/gdm/Init/Default 在 exit 0 之前，添加如下内容： #set numlock on if [ -x /usr/bin/numlockx ]; then /usr/bin/numlockx on fi 结果如下图： 基于 lightdmsudo gedit /etc/lightdm/lightdm.conf 最后一行添加下面语句： greeter-setup-script=/usr/bin/numlockx on 结果如下图： 重启或者注销后，生效。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>NumLock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#本质论笔记 第2章 数据类型]]></title>
    <url>%2F2017%2F12%2F13%2FCSharp%E6%9C%AC%E8%B4%A8%E8%AE%BA%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型预定义类型(predefined type)/基元类型(primitive type)，也翻译为基本类型、基础类型或者原始类型。 类型 Size Range BCL name Signed 精度 后缀 例子 sbyte 8 bits -128 to 127 System.SByte 是 byte 8 bits 0 to 255 System.Byte 否 short 16 bits -32,768 to 32,767 System.Int16 是 ushort 16 bits 0 to 65,535 System.UInt16 否 int 32 bits -2,147,483,648 to 2,147,483,647 System.Int32 是 uint 32 bits 0 到 4,294,967,295 System.UInt32 否 U或u long 64 bits -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 System.Int64 是 L或l ulong 64 bits -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 System.UInt64 否 UL或ul float 32 bits ±1.5e−45 到 ±3.4e38 System.Single 7 F或f double 64 bits ±5.0e−324 到 ±1.7e308 System.Double 15-16 D或d decimal 128 bits ±1.0e−28 到 ±7.9e28 System.Decimal 28-29 M或m bool bits System.Boolean char 16 bits Unicode 字符 U+0000 到 U+ffff System.Char char test; test = ‘A’ string System.String string test; test = “A” object System.Object dynamic 无相应.NET类型 dynamic dyn = 1; 类型关键字和BCL name效果相同，规范建议指定数据类型时使用C#关键字，而不是BCL名称（例如，使用==string==而不是System.String或者==String==）。 后缀不区分大小写，一般建议采用大写。但对于long ，强烈建议使用大写字母Ｌ，因为小写字母ｌ和数字１不好区分。 关于指数记数法，需要使用 e 或者 E 中缀，在中缀字母后添加正整数或者负整数，并在字面量的最后添加恰当的数据类型后缀。例如将阿伏加德罗常熟作为float输出，代码如下： 1System.Console.WriteLine(6.023E23F); 输出结果 6.023E+23 经常用到的数字格式化输出例子1234567891011121314151617class hello &#123; static void Main () &#123; double dValue = 12345.6789; //几种格式转换输出方式 System.Console.WriteLine (dValue); //原值输出 输出 12345.6789 System.Console.WriteLine ("&#123;0&#125;", dValue); System.Console.WriteLine (string.Format ("&#123;0&#125;", dValue)); System.Console.WriteLine (dValue.ToString ()); System.Console.WriteLine ("以下几种方法在数据有效范围内效果相同："); System.Console.WriteLine ("WriteLine (dValue);"); System.Console.WriteLine ("WriteLine (\"&#123;0&#125;\", dValue);"); System.Console.WriteLine ("WriteLine (string.Format (\"&#123;0&#125;\", dValue));"); System.Console.WriteLine ("WriteLine (dValue.ToString ());"); &#125;&#125; 输出结果 12345.6789 12345.6789 12345.6789 12345.6789 以下几种方法在数据有效范围内效果相同： WriteLine (dValue); WriteLine (&quot;{0}&quot;, dValue); WriteLine (string.Format (&quot;{0}&quot;, dValue)); WriteLine (dValue.ToString ()); 基本数值类型C#基本数值类型包括整数类型、浮点类型以及decimal类型。 浮点数的精度是可变的。例如浮点数 0.1，可以表示成 0.0999999999 或者 0.100000001（或者任何非常接近0.1的数）。 decimal是一种特殊的浮点类型，是128位精度的10进制浮点类型，能够存书大数字而无表示错误，适合大而精确的计算。 与==二进制==浮点数不同，decimal类型保证范围内所有的==十进制==数都是精确的，0.1就是0.1。 ==关于浮点精度理解==，目前计算机是2进制（只有0，1状态）的运算机器，所有小于1的数，只能用除法计算得到结果，计算机中的除法就是移位。 例如0.1，表示成分数是1/10，分母10不是2的整数次幂，因此1/10不能用有限的二进制小数表示。 字面值或字面量(literal value) literal value 表示源代码中的固定值，就是数据值本身。Microsoft Docs 将 literal 翻译作 文本。 个人理解，字面量可以叫做常数，常数值，固定值等等，可以是用户自己定义的或者系统定义的常数、符号等（例如：==123==、==’A’==、==\n== 等）。 例如，下面代码中的数字值： 12System.Console.WriteLine(42);System.Console.WriteLine(1.618034); 输出结果 42 1.618034 用变量定义来实现上面的效果，定义int 类型变量 x 并赋值 42 ，定义 double 类型变量 y 并赋值 1.618034 。 1234int x = 42;double y = 1.618034;System.Console.WriteLine(x);System.Console.WriteLine(y); 输出结果 42 1.618034 初学者主题:使用硬编码要慎重直接将值放到源代码中成为硬编码（==hardcoding==），如果以后需要更改值，就必须重新编译代码。给予方便维护考虑，可以考虑从外部获取值，比如从一个配置文件中，这样以后修改值的时候，不需要重新编译代码。 带小数点的字面值，编译器自动解释成 double 类型。 整数值（没有小数点）通常默认为 int，前提是值在 int 类型存储范围内。如果值太大，编译器会把它解释成 long 。 C# 允许想非 int 类型赋值，前提是字面值对于目标数据类型来说是合法的。例如，short s = 42和byte b = 77都是允许的。但值一点进队字面值成立。如果不使用额外语法，b = s就是非法的。 数据精度相关代码示例12System.Console.WriteLine(1.234567890123456);System.Console.WriteLine(1.012345678901234); 输出结果 1.23456789012346 1.01234567890123 受限于 double 类型的精度，超过精度的遵循==四舍五入==原则截取。 要显示具有完整精度的数字，必须将字面值显示生命为 decimal 类型，知识通过追加一个M（或者m）后缀来实现的。 下面代码指定一个 decimal 字面值 12System.Console.WriteLine(1.234567890123456M);System.Console.WriteLine(1.012345678901234m); 输出结果 1.234567890123456 1.012345678901234 初学者主题:十六进制表示法 Hexadecimal NotationC#允许指定十六进制值，需要附加 0x 或者 0X 前缀（效果一样），如下示例： 12345//用16进制字面量显示数值10System.Console.WriteLine(0x000A);System.Console.WriteLine(0x000a);System.Console.WriteLine(0X000A);System.Console.WriteLine(0X000a); 输出结果 10 10 10 10 注意，代码输出结果是10，而不是0x000A 或者 0x000a 。 高级主题:将数格式化成十六进制要以十六进制形式格式化输出一个数值，必须使用==x==或者==X==数值格式说明符。==大小写==决定了十六进制字母的大小写，数值字面量可采用十进制或者十六进制形式，结果一样。如下示例： 1234567891011121314//显示数值 "0xA" 或者 “0xa”//字面量为十进制数值，格式化为十六进制，大写System.Console.WriteLine("0x&#123;0:X&#125;", 10);//字面量为十进制数值，格式化为十六进制，小写System.Console.WriteLine("0x&#123;0:x&#125;", 10);//字面量为十六进制大写数值，格式化为十六进制，小写System.Console.WriteLine("0x&#123;0:x&#125;", 0X000A);//字面量为十六进制小写数值，格式化为十六进制，大写System.Console.WriteLine("0x&#123;0:X&#125;", 0X000a);int value;value = 0X000a;System.Console.WriteLine(value.ToString("X"));System.Console.WriteLine("0x&#123;0&#125;", value.ToString("X")); 输出结果 0xA 0xa 0xa 0xA A 0xA 高级主题:round-trip （往返过程）格式化在格式化字符串时，使用round-trip格式说明符(R 或者 r)，用于确保转换为字符串的数值将再次分析为相同的数值。只有 Single、 Double 和 BigInteger 类型支持此格式。 例如，string.Format(“{0}”,0.1234567890123125) 结果是 0.123456789012313 而， string.Format(“{0:R}”,0.1234567890123125) 结果是 0.1234567890123125 。 123456789101112131415161718192021222324252627282930public class Program&#123; public static void Main() &#123; const double number = 0.1234567890123125; double result; string text; text = string.Format("&#123;0&#125;",number); //double.Parase 将数字的字符串表示形式转换为它的等效双精度浮点数。 result = double.Parse(text); System.Console.WriteLine(number); System.Console.WriteLine("text = &#123;0&#125;" , text); System.Console.WriteLine(result); //double.ToSring() 将此实例的数值转换为其等效的字符串表示形式。 System.Console.WriteLine(number.ToString()); System.Console.WriteLine("&#123;0&#125;: text = number", text == number.ToString()); System.Console.WriteLine("&#123;0&#125;: result = number", result != number); text = string.Format("&#123;0:R&#125;",number); System.Console.WriteLine("text = &#123;0&#125;" , text); result = double.Parse(text); System.Console.WriteLine("&#123;0&#125;: result = number", result == number); System.Console.ReadKey(); &#125;&#125; 输出结果 0.123456789012313 text = 0.123456789012313 0.123456789012313 0.123456789012313 True: text = number True: result = number text = 0.1234567890123125 True: result = number 标准数字格式字符串(Numeric Format Strings) 标准数字格式字符串用于格式化通用数值类型。 标准数字格式字符串采用 Axx 的形式，其中： A 是称为格式说明符的单个字母字符。任何包含一个以上字母字符（包括空白）的数字格式字符串都被解释为自定义数字格式字符串。 xx 是称为精度说明符的可选整数。 精度说明符的范围从 0 到 99，并且影响结果中的位数。请注意，精度说明符控制数字的字符串表示形式中的数字个数。 它不舍入该数字。若要执行舍入运算，请使用 Math.Ceiling、 Math.Floor 或 Math.Round 方法。 当精度说明符控制结果字符串中的小数位数时，结果字符串反映远离零的一侧舍入的数字（即，使用 MidpointRounding.AwayFromZero）。 所有数字类型的 ToString 方法的某些重载支持标准数字格式字符串。 例如，可将数字格式字符串提供给 ToString(String) 类型的 ToString(String, IFormatProvider) 方法和 Int32 方法。 .NET Framework 复合格式化功能也支持标准数字格式字符串，该功能由 Write 和 WriteLine 类的某些 Console 和 StreamWriter 方法、 String.Format 方法以及 StringBuilder.AppendFormat 方法使用。复合格式功能允许你将多个数据项的字符串表示形式包含在单个字符串中，以指定字段宽度，并在字段中对齐数字。 下表描述标准的数字格式说明符并显示由每个格式说明符产生的示例输出。 格式说明符 名称 描述 示例 “C”或“c” 货币 结果：货币值。受以下类型支持：所有数值类型。精度说明符：小数位数。默认值精度说明符：由 NumberFormatInfo.CurrencyDecimalDigits 定义。更多信息： 货币（“C”）格式说明符。 123.456 (“C”, en-US) -&gt; $123.46 123.456 (“C”, fr-FR) -&gt; 123,46 € 123.456 (“C”, ja-JP) -&gt; ¥123 -123.456 (“C3”, en-US) -&gt; ($123.456)-123.456 (“C3”, fr-FR) -&gt; -123,456 €-123.456 (“C3”, ja-JP) -&gt; -¥123.456 “D”或“d” Decimal 结果：整型数字，负号可选。受以下类型支持：==仅整型==。精度说明符：最小位数。默认值精度说明符：所需的最小位数。更多信息： 十进制（“D”）格式说明符。 1234 (“D”) -&gt; 1234 -1234 (“D6”) -&gt; -001234 “E”或“e” 指数(科学型) 结果：指数记数法。受以下类型支持：所有数值类型。精度说明符：小数位数。默认值精度说明符：6。更多信息： 指数（“E”）格式说明符。 1052.0329112756 (“E”, en-US) -&gt; 1.052033E+0031052.0329112756 (“e”, fr-FR) -&gt; 1,052033e+003-1052.0329112756 (“e2”, en-US) -&gt; -1.05e+003-1052.0329112756 (“E2”, fr_FR) -&gt; -1,05E+003 “F”或“f” 定点 结果：整数和小数，负号可选。受以下类型支持：所有数值类型。精度说明符：小数位数。默认值精度说明符：由 NumberFormatInfo.NumberDecimalDigits 定义。更多信息： 定点（“F”）格式说明符。 1234.567 (“F”, en-US) -&gt; 1234.571234.567 (“F”, de-DE) -&gt; 1234,571234 (“F1”, en-US) -&gt; 1234.01234 (“F1”, de-DE) -&gt; 1234,0-1234.56 (“F4”, en-US) -&gt; -1234.5600-1234.56 (“F4”, de-DE) -&gt; -1234,5600 “G”或“g” 常规 结果：最紧凑的定点表示法或科学记数法。受以下类型支持：所有数值类型。精度说明符：有效位数。默认值精度说明符：取决于数值类型。更多信息：常规（“G”）格式说明符。 -123.456 (“G”, en-US) -&gt; -123.456-123.456 (“G”, sv-SE) -&gt; -123,456123.4546 (“G4”, en-US) -&gt; 123.5123.4546 (“G4”, sv-SE) -&gt; 123,5-1.234567890e-25 (“G”, en-US) -&gt; -1.23456789E-25-1.234567890e-25 (“G”, sv-SE) -&gt; -1,23456789E-25 “N”或“n” 数字 结果：整数和小数、组分隔符和小数分隔符，负号可选。受以下类型支持：所有数值类型。精度说明符：所需的小数位数。默认值精度说明符：由 NumberFormatInfo.NumberDecimalDigits 定义。更多信息： 数字（“N”）格式说明符。 1234.567 (“N”, en-US) -&gt; 1,234.571234.567 (“N”, ru-RU) -&gt; 1 234,571234 (“N1”, en-US) -&gt; 1,234.01234 (“N1”, ru-RU) -&gt; 1 234,0-1234.56 (“N3”, en-US) -&gt; -1,234.560-1234.56 (“N3”, ru-RU) -&gt; -1 234,560 “P”或“p” 百分比 结果：乘以 100 并显示百分比符号的数字。受以下类型支持：所有数值类型。 精度说明符：所需的小数位数。默认值精度说明符：由 NumberFormatInfo.PercentDecimalDigits 定义。更多信息： 百分比（“P”）格式说明符。 1 (“P”, en-US) -&gt; 100.00 %1 (“P”, fr-FR) -&gt; 100,00 %-0.39678 (“P1”, en-US) -&gt; -39.7 %-0.39678 (“P1”, fr-FR) -&gt; -39,7 % “R”或“r” 往返过程 结果：可以往返至相同数字的字符串。受以下类型支持： Single、 Double 和 BigInteger。精度说明符：忽略。更多信息： 往返过程（“R”）格式说明符。 123456789.12345678 (“R”) -&gt; 123456789.12345678-1234567890.12345678 (“R”) -&gt; -1234567890.1234567 “X”或“x” 十六进制 结果：十六进制字符串。受以下类型支持：仅整型。精度说明符：结果字符串中的位数。更多信息： 十六进制（“X”）格式说明符。 255 (“X”) -&gt; FF-1 (“x”) -&gt; ff255 (“x4”) -&gt; 00ff-1 (“X4”) -&gt; 00FF 任何其他单个字符 未知说明符 结果：在运行时引发 FormatException。 其他 自定义数字格式字符串 你可以创建自定义数字格式字符串，这种字符串由一个或多个自定义数字说明符组成，用于定义设置数值数据格式的方式。 自定义数字格式字符串是任何不属于 ==标准数字格式字符串== 的格式字符串。 所有数字类型的 ToString 方法的某些重载支持自定义数字格式字符串。 例如，可将数字格式字符串提供给 Int32 类型的 ToString(String) 方法和 ToString(String, IFormatProvider) 方法。 .NET Framework 复合格式化功能也支持自定义数字格式字符串，该功能由 Console 和 StreamWriter 类的某些 Write 和 WriteLine 方法、 String.Format 方法以及 StringBuilder.AppendFormat 方法所使用。 下表描述自定义数字格式说明符并显示由每个格式说明符产生的示例输出。 格式说明符 名称 描述 示例 “0” 零占位符 用对应的数字（如果存在）替换零；否则，将在结果字符串中显示零。 1234.5678 (“00000”) -&gt;012350.45678 (“0.00”, en-US) -&gt; 0.460.45678 (“0.00”, fr-FR) -&gt; 0,46 “#” 数字占位符 用对应的数字（如果存在）替换“#”符号；否则，不会在结果字符串中显示任何数字。 1234.5678 (“#####”) -&gt; 12350.45678 (“#.##”, en-US) -&gt; .460.45678 (“#.##”, fr-FR) -&gt; ,46 “.” 小数点 确定小数点分隔符在结果字符串中的位置。 0.45678 (“0.00”, en-US) -&gt; 0.460.45678 (“0.00”, fr-FR) -&gt; 0,46 “,” 组分隔符和数字比例换算 用作组分隔符和数字比例换算说明符。作为组分隔符时，它在各个组之间插入本地化的组分隔符字符。作为数字比例换算说明符，对于每个指定的逗号，它将数字除以1000。 组分隔符说明符：2147483647 (“##,#”, en-US) -&gt; 2,147,483,6472147483647 (“##,#”, es-ES) -&gt; 2.147.483.647比例换算说明符：2147483647 (“#,#,,”, en-US) -&gt; 2,1472147483647 (“#,#,,”, es-ES) -&gt; 2.147 “%” 百分比占位符 将数字乘以 100，并在结果字符串中插入本地化的百分比符号。 0.3697 (“%#0.00”, en-US) -&gt; %36.970.3697 (“%#0.00”, el-GR) -&gt; %36,970.3697 (“##.0 %”, en-US) -&gt; 37.0 %0.3697 (“##.0 %”, el-GR) -&gt; 37,0 % “‰” 千分比占位符 将数字乘以 1000，并在结果字符串中插入本地化的千分比符号。 0.03697 (“#0.00‰”, en-US) -&gt; 36.97‰0.03697 (“#0.00‰”, ru-RU) -&gt; 36,97‰ “E0”“E+0”“E-0”“e0”“e+0”“e-0” 指数表示法 如果后跟至少一个0（零），则使用指数表示法设置结果格式。“E”或“e”指示指数符号在结果字符串中是大写还是小写。跟在“E”或“e”字符后面的零的数目确定指数中的最小位数。 加号 (+)指示符号字符总是置于指数前面。减号(-)指示符号字符仅置于负指数前面。 987654 (“#0.0e0”) -&gt; 98.8e41503.92311 (“0.0##e+00”) -&gt; 1.504e+031.8901385E-16 (“0.0e+00”) -&gt; 1.9e-16 \ 转义符 使下一个字符被解释为文本而不是自定义格式说明符。 987654 (“###00#“) -&gt; #987654# ‘string’“string” 文本字符串分隔符 指示应复制到未更改的结果字符串的封闭字符。 68 (“# ‘ degrees’”) -&gt; 68 degrees68 (“# ‘ degrees’”) -&gt; 68 degrees ; 部分分隔符 通过分隔格式字符串定义正数、负数和零各部分。 12.345 (“#0.0#;(#0.0#);-\0-“) -&gt; 12.350 (“#0.0#;(#0.0#);-\0-“) -&gt; -0--12.345 (“#0.0#;(#0.0#);-\0-“) -&gt; (12.35)12.345 (“#0.0#;(#0.0#)”) -&gt; 12.350 (“#0.0#;(#0.0#)”) -&gt; 0.0-12.345 (“#0.0#;(#0.0#)”) -&gt; (12.35) 其他 所有其他字符 字符将复制到未更改的结果字符串。 68 (“# °”) -&gt; 68 ° 标准数字格式化字符串 简单例子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using System;using System.Globalization;using System.Threading;public class NumericFormats &#123; public static void Main () &#123; // Display string representations of numbers for en-us culture CultureInfo ci = new CultureInfo ("en-us"); // Output floating point values double floating = 10761.937554; Console.WriteLine ("原始数字：10761.937554"); Console.WriteLine ("C: &#123;0&#125;", floating.ToString ("C", ci)); // Displays "C: $10,761.94" Console.WriteLine ("E: &#123;0&#125;", floating.ToString ("E03", ci)); // Displays "E: 1.076E+004" Console.WriteLine ("F: &#123;0&#125;", floating.ToString ("F04", ci)); // Displays "F: 10761.9376" Console.WriteLine ("G: &#123;0&#125;", floating.ToString ("G", ci)); // Displays "G: 10761.937554" Console.WriteLine ("N: &#123;0&#125;", floating.ToString ("N03", ci)); // Displays "N: 10,761.938" Console.WriteLine ("P: &#123;0&#125;", (floating / 10000).ToString ("P02", ci)); // Displays "P: 107.62 %" Console.WriteLine ("R: &#123;0&#125;", floating.ToString ("R", ci)); // Displays "R: 10761.937554" Console.WriteLine (); // Output integral values int integral = 8395; Console.WriteLine ("原始数字：8395"); Console.WriteLine ("C: &#123;0&#125;", integral.ToString ("C", ci)); // Displays "C: $8,395.00" Console.WriteLine ("D: &#123;0&#125;", integral.ToString ("D6", ci)); // Displays "D: 008395" Console.WriteLine ("E: &#123;0&#125;", integral.ToString ("E03", ci)); // Displays "E: 8.395E+003" Console.WriteLine ("F: &#123;0&#125;", integral.ToString ("F01", ci)); // Displays "F: 8395.0" Console.WriteLine ("G: &#123;0&#125;", integral.ToString ("G", ci)); // Displays "G: 8395" Console.WriteLine ("N: &#123;0&#125;", integral.ToString ("N01", ci)); // Displays "N: 8,395.0" Console.WriteLine ("P: &#123;0&#125;", (integral / 10000.0).ToString ("P02", ci)); // Displays "P: 83.95 %" Console.WriteLine ("X: 0x&#123;0&#125;", integral.ToString ("X", ci)); // Displays "X: 0x20CB" Console.WriteLine (); &#125;&#125; 输出结果 原始数字：10761.937554 C: $10,761.94 E: 1.076E+004 F: 10761.9376 G: 10761.937554 N: 10,761.938 P: 107.62% R: 10761.937554 原始数字：8395 C: $8,395.00 D: 008395 E: 8.395E+003 F: 8395.0 G: 8395 N: 8,395.0 P: 83.95% X: 0x20CB 标准数字格式化字符串 详细例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128using System;using System.Globalization;class hello &#123; static void Main () &#123; double dValue = 12345.6789; int iValue = 12345; //几种格式转换输出方式 System.Console.WriteLine (dValue); //原值输出 输出 12345.6789 System.Console.WriteLine ("&#123;0&#125;", dValue); System.Console.WriteLine (string.Format ("&#123;0&#125;", dValue)); System.Console.WriteLine (dValue.ToString ()); System.Console.WriteLine ("以下几种方法在数据有效范围内效果相同："); System.Console.WriteLine ("WriteLine (dValue);"); System.Console.WriteLine ("WriteLine (\"&#123;0&#125;\", dValue);"); System.Console.WriteLine ("WriteLine (string.Format (\"&#123;0&#125;\", dValue));"); System.Console.WriteLine ("WriteLine (dValue.ToString ());"); System.Console.WriteLine ("======================================"); //■■ 货币 "C" 格式说明符 ■■// Console.WriteLine ("&#123;0:c&#125;", dValue); //货币格式 默认两位小数 输出 ￥12,345.68 Console.WriteLine ("&#123;0:c2&#125;", dValue); //货币格式 输出 指定两位小数 ￥12,345.68 Console.WriteLine (dValue.ToString ("C")); //货币格式 输出 ￥12,345.68KT Console.WriteLine (dValue.ToString ("C2")); //货币格式 输出 ￥12,345.68 Console.WriteLine (dValue.ToString ("C3")); //货币格式 指定三位小数 输出 ￥12,345.679 //货币格式 当前国家 默认位小数 输出 ￥12,345.68 //System.Globalization. CultureInfo.CurrentCulture Console.WriteLine (dValue.ToString ("C", CultureInfo.CurrentCulture)); //货币格式 当前国家 指定两位小数 输出 ￥12,345.68 Console.WriteLine (dValue.ToString ("C2", CultureInfo.CurrentCulture)); //货币格式 中国货币 指定三位小数 输出 ￥12,345.679 Console.WriteLine (dValue.ToString ("C3", CultureInfo.CreateSpecificCulture ("zh-CN"))); //货币格式 丹麦货币 指定三位小数 输出 12.345,679 kr. Console.WriteLine (dValue.ToString ("C3", CultureInfo.CreateSpecificCulture ("da-DK"))); //■■ 十进制 "D" 格式例子 ■■// Console.WriteLine (iValue.ToString ("D")); //输出 12345 Console.WriteLine (iValue.ToString ("D8")); //输出 00012345 iValue = -12345; Console.WriteLine (iValue.ToString ("D")); //输出 -12345 Console.WriteLine (iValue.ToString ("D8")); //输出 -00012345 //错误示例 “D”只接受整型 其他编译不通过 //Console.WriteLine(dValue.ToString("D8")); //■■ 指数 "E" 格式说明符 ■■// Console.WriteLine (dValue.ToString ("E")); //输出 1.234568E+004 Console.WriteLine (dValue.ToString ("E10")); //输出 1.2345678900E+004 //■■ 定点 “F” 格式说明符 ■■// iValue = 12345; Console.WriteLine (iValue.ToString ("F")); //输出 12345.00 iValue = -12345; Console.WriteLine (iValue.ToString ("F3")); //输出 12345.000 dValue = 12345.6789; Console.WriteLine (dValue.ToString ("F")); //输出 12345.68 Console.WriteLine (dValue.ToString ("F0")); //输出 12345 //■■ 常规 “G” 格式说明符 ■■// dValue = 12345.6789; Console.WriteLine (dValue.ToString ("G")); // Displays 12345.6789 Console.WriteLine (dValue.ToString ("G", CultureInfo.CreateSpecificCulture ("fr-FR"))); // Displays 12345,6789 Console.WriteLine (dValue.ToString ("G7")); // Displays 12345.68 dValue = .0000023; Console.WriteLine (dValue.ToString ("G")); // Displays 2.3E-06 Console.WriteLine (dValue.ToString ("G", CultureInfo.CreateSpecificCulture ("fr-FR"))); // Displays 2,3E-06 dValue = .0023; Console.WriteLine (dValue.ToString ("G")); // Displays 0.0023 dValue = 1234; Console.WriteLine (dValue.ToString ("G2")); // Displays 1.2E+03 dValue = Math.PI; Console.WriteLine (dValue.ToString ("G5")); // Displays 3.1416 //■■ 数字 “N” 格式说明符 ■■// dValue = -12345.6789; Console.WriteLine (dValue.ToString ("G")); // Displays 12345.6789N Console.WriteLine (dValue.ToString ("N1", CultureInfo.CreateSpecificCulture ("sv-SE"))); // Displays -12 445,7 iValue = 123456789; Console.WriteLine (iValue.ToString ("N1", CultureInfo.InvariantCulture)); // Displays 123,456,789.0 //■■ 数字 “N” 格式说明符 ■■// dValue = -.2468013; Console.WriteLine (dValue.ToString ("P")); // Displays -24.68 % Console.WriteLine (dValue.ToString ("P1", CultureInfo.CreateSpecificCulture ("sv-SE"))); // Displays -24,68% Console.WriteLine (dValue.ToString ("P1", CultureInfo.InvariantCulture)); // Displays -24.7 % //■■ 数字 “R” 格式说明符 ■■// dValue = Math.PI; Console.WriteLine (dValue.ToString ("r")); // Displays 3.1415926535897931 Console.WriteLine (dValue.ToString ("r", CultureInfo.CreateSpecificCulture ("fr-FR"))); // Displays 3,1415926535897931 dValue = 1.623e-21; Console.WriteLine (dValue.ToString ("r")); // Displays 1.623E-21 //■■ 十六进制 “X” 格式说明符 ■■// iValue = 0x2045e; Console.WriteLine (iValue.ToString ("x")); // Displays 2045e Console.WriteLine (iValue.ToString ("X")); // Displays 2045E Console.WriteLine (iValue.ToString ("X8")); // Displays 0002045E iValue = 123456789; Console.WriteLine (iValue.ToString ("X")); // Displays 75BCD15 Console.WriteLine (iValue.ToString ("X2")); // Displays 75BCD15 Console.ReadKey (); &#125;&#125; 自定义数字格式化字符串例子 下面的示例演示两个自定义数字格式字符串。 在这两个示例中，数字占位符 (#) 显示数值数据，且所有其他字符被复制到结果字符串。 1234567891011121314151617using System;using System.Globalization;public class Example &#123; public static void Main () &#123; double number1 = 1234567890; string value1 = number1.ToString ("(###) ###-####"); Console.WriteLine (value1); int number2 = 42; string value2 = number2.ToString ("My Number = #"); Console.WriteLine (value2); // The example displays the following output: // (123) 456-7890 // My Number = 42 &#125;&#125; 更多基本类型char （字符）类型 char 关键字用于声明 System.Char 结构的实例，.NET Framework 使用该结构来表示 Unicode 字符。 Char 对象的值为 16 位的==数字（序号）值==（见Microsoft Docs C# 参考 char）。 Unicode 字符用于表示世界各地大多数的书面语言。 类型 范围 大小 .NET Framwork char U+0000 到 U+FFFF Unicode 16 位字符 System.char 后面经常用到的 \uxxxx 转义序列，XXXX是代表某个Unicode字符的16进制编码值。通过System.Text.Encoding.UTF8.GetBytes(char[])和System.Text.UnicodeEncoding.GetBytes(String)这些方法得到的值是10进制的，需要（通过 ==标准数字格式字符串== 中的 ==X2== ）转换成16进制，就是相应的Unicode编码了。 char 可以隐式转换为 ushort、 int、 uint、 long、 ulong、 float、 double 或 decimal。 但是，不存在从其他类型到 char 类型的隐式转换。 char 类型的常数可以写成==字符==（例如 ‘x’）、==十六进制换码序列==（例如 ‘\t’）或 ==Unicode== （例如 ‘\u02C0’）表示形式。 您也可以显式转换整数字符代码。 在下面的示例中，几个 char 变量使用同一字符 X 初始化： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System;using System.Text;class charType&#123; static void Main() &#123; char[] chars = new char[7]; chars[0] = 'X'; // Character literal chars[1] = '\x0058'; // Hexadecimal chars[2] = '\u0058'; // Unicode chars[3] = (char)88; // Cast from integral type chars[4] = (char)0x0058; // 转换自16进制整型 chars[5] = '\x5927'; //汉字 大 的Unicode编码 chars[6] = '大'; //汉字 大 foreach (char c in chars) &#123; Console.Write(c + " "); &#125; Console.WriteLine(); //获取汉字“大”的编码。保存为一个字节序列 byte[] bytes = Encoding.Unicode.GetBytes("大"); //得到编码的10进制字节数据 [39][89] Console.WriteLine("[&#123;0&#125;][&#123;1&#125;]", bytes[0], bytes[1]); //得到编码的16进制字节数据 [27][59] ,显示是litte-Endian方式 Console.WriteLine("[&#123;0:X2&#125;][&#123;1:X2&#125;]", bytes[0], bytes[1]); //判断 大端 Big-Endian 小端 Little-Endian if (BitConverter.IsLittleEndian) Array.Reverse(bytes); // 转换为 大端模式 结果为 [59][27] //输出 [59][27] Console.WriteLine("[&#123;0:X2&#125;][&#123;1:X2&#125;]", bytes[0], bytes[1]); Console.ReadKey(); &#125; //得到字符串中个字符(char)的Unicode编码 protected static string GetUnicode(string text) &#123; string result = ""; for (int i = 0; i &lt; text.Length; i++) &#123; if ((int)text[i] &gt; 32 &amp;&amp; (int)text[i] &lt; 127) &#123; result += text[i].ToString(); &#125; else result += string.Format("\\u&#123;0:x4&#125;", (int)text[i]); &#125; return result; &#125;&#125; 输出结果 X X X X X 大 大 [39][89] [27][59] [59][27] 高级主题：解析字符串中字符的16进制编码（Unicode）123456789101112131415using System;public class Program &#123; static void Main (string[] args) &#123; string input = "你好 大世界！Hello World!"; for (int i = 0; i &lt; input.Length; i++) &#123; // 占位符 方式 Console.Write ("&#123;0&#125; &#123;1&#125; ", input[i], ((int) input[i]).ToString ("X")); // 字符串内插 $ 方式 Console.Write ($"&#123;input[i]&#125; &#123;((int)input[i]).ToString("X")&#125; "); &#125; System.Console.WriteLine (); Console.ReadKey (); &#125;&#125; 输出结果 你 4F60 好 597D 20 大 5927 世 4E16 界 754C ！ FF01 H 48 e 65 l 6C l 6C o 6F 20 W 57 o 6F r 72 l 6C d 64 ! 21 高级主题：大端 Big-Endian 小端 Little-Endian不同的计算机结构采用不同的字节顺序存储数据。” Big-endian”表示最大的有效字节位于单词的左端。” Little-endian”表示最大的有效字节位于单词的右端。 另以一种解释 Little-Endian 就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。 Big-Endian 就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。 例子，比如数字0x12 34 56 78在内存中的表示形式为： 大端模式： 低地址 -----------------&gt; 高地址 0x12 | 0x34 | 0x56 | 0x78 小端模式： 低地址 ------------------&gt; 高地址 0x78 | 0x56 | 0x34 | 0x12 可见，大端模式和字符串的存储模式类似。 具体例子：汉字“大”（\u5927）的Unicode编码在 Little-endian 模式（以及 Big-endian 模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为： 内存地址 小端模式存放内容 大端模式存放内容 0x4000 0x27 0x59 0x4001 0x59 0x27 转义序列 escape sequence 由反斜杠 ( \ ) 后接字母或数字组合构成的字符组合称为“转义序列”。要在字符常量中表示换行符，单引号或某些其他字符，你必须使用转义序列。 转义序列被视为单个字符，因此，它是有效的字符常量。 转义序列通常用于指定操作，例如终端和打印机上的回车和制表符移动。它们还用于提供非打印字符的文本表现形式和通常具有特殊意义的字符，例如双引号 ( “ )。 下表列出 ANSI 转义序列以及它们所表示的内容。 请注意，在字符序列将被错误解释为三元组的情况下，前接反斜杠的问号 ( \?) 指定文本问号。 转义序列 含义（字符名称） Unicode Encoding（Unicode 编码） \’ 单引号 0x0027 \” 双引号 0x0022 \\ 反斜杠 0x005C \? 文本问号 \0 Null 0x0000 \a Alert 或 Bell 铃声(提醒) 0x0007 \b Backspace 退格 0x0008 \f 换页 0x000C \n 换行 0x000A \r 回车 0x000D \t 水平制表符 0x0009 \v 垂直制表符 0x000B \ ooo 在八进制表示法的 ASCII 字符 \uxxxx 16进制Unicode字符，Unicode 转义序列 \u0041 = “A” \x [h][h][h]h 16进制Unicode字符，（前三个占位符可选），\uxxxx的长度可变版本。除长度可变外，Unicode 转义序列与“\u”类似。 \u3A \x hh 以十六进制表示法的 ASCII 字符 \x hhhh 十六进制表示法的 Unicode 字符（如果此转义序列用于宽字符常量或 Unicode 字符串文本）。以十六进制表示法，则此转义序列用于常量宽字符或 Unicode 字符串的 Unicode 字符。例如，WCHAR f = L’\x4e00’ 或 WCHAR b[] = L”The Chinese character for one is \x4e00”。 \x0041 = “A” \Unnnnnnnn U代理项对的 Unicode 转义序列。 \Unnnnnnnn 字符串常规字符串 regular 常规字符串 123456789101112string columns = "Column 1\tColumn 2\tColumn 3";//Output: Column 1 Column 2 Column 3string rows = "Row 1\r\nRow 2\r\nRow 3";/* Output: Row 1 Row 2 Row 3*/string title = "\"The \u00C6olean Harp\", by Samuel Taylor Coleridge";//Output: "The Æolean Harp", by Samuel Taylor Coleridge @ 逐字字符串12345678910111213141516171819202122232425262728293031string filePath = @"C:\Users\scoleridge\Documents\";//Output: C:\Users\scoleridge\Documents\string text = @"My pensive SARA ! thy soft cheek reclined Thus on mine arm, most soothing sweet it is To sit beside our Cot,...";/* Output:My pensive SARA ! thy soft cheek reclined Thus on mine arm, most soothing sweet it is To sit beside our Cot,... */System.Console.Write (@"begin /\ / \ / \ / \ /________\end");/*输出begin /\ / \ / \ / \ /________\end */string quote = @"Her name was ""Sara.""";//Output: Her name was "Sara." $ 字符串内插 借助==字符串内插==，可以将字符串中的占位符替换成字符串变量的值。 在 C# 6 中，我们最终实现了这种样式的字符串内插。 可以在字符串前面使用 $，以指明应使用变量/表达式替换相应的值。 在低于 C# 6 的版本中，使用 System.String.Format 实现字符串内插。 虽然这样做是可行的，但由于要用到编号占位符，因此加大了读取难度且过程更为冗长。 先决条件 使用==字符串内插==，必须将计算机设置为运行 ==.Net Core==。 字符串内插简介 使用 System.String.Format在字符串中指定要被字符串后面的参数替换的“==占位符==”。 例如： 1234var firstName = "Matt";var lastName = "Groves";var str = String.Format("My name is &#123;0&#125; &#123;1&#125;", firstName, lastName);Console.WriteLine(str); 输出结果 “My name is Matt Groves” 在 C# 6 中，定义内插字符串的方式为，在内插字符串前面添加 ==$== 符号，然后直接在字符串中使用变量，而不使用 String.Format。 例如： 1234var firstName = "Matt";var lastName = "Groves";var str = $"My name is &#123;firstName&#125; &#123;lastName&#125;";Console.WriteLine(str); 输出结果 “My name is Matt Groves” 不必局限于变量。 ==可以在括号内使用任意表达式==。 例如： 123for(var i = 0; i &lt; 5; i++) &#123; Console.WriteLine($"This is line number &#123;i + 1&#125;");&#125; 输出结果 This is line number 1 This is line number 2 This is line number 3 This is line number 4 This is line number 5 字符串内插的工作方式 在后台，编译器将此类字符串内插语法转换成 String.Format。 因此，可以执行之前使用 String.Format 执行的相同操作。 例如，可以添加填充和数值格式： 123456var rand = new Random();for(var i = 998; i &lt; 1005; i++)&#123; var randomDecimal = rand.NextDouble() * 10000; Console.WriteLine($"&#123;i, -10&#125; &#123;randomDecimal, 6:N2&#125;");&#125; 输出结果 998 5,177.67 999 6,719.30 1000 9,910.61 1001 529.34 1002 1,349.86 1003 2,660.82 1004 6,227.77 字符串转字符数组123456789101112131415161718192021using System;class TestRef &#123; static void Main () &#123; string a = "Hello World! 你好 大世界"; char[] b = a.ToCharArray (); for (int i = 0; i &lt; b.Length; i++) &#123; Console.Write (b[i]); &#125; // 输出 Hello World! 你好 大世界 Console.WriteLine (); Array.Reverse (b); for (int i = 0; i &lt; b.Length; i++) &#123; Console.Write (b[i]); &#125; // 输出 界世大 好你 !dlroW olleH System.Console.ReadKey (); &#125;&#125; 字符串数组123456//只有在使用字符串数组初始化字符串时，才能使用 new 运算符串讲字符串对象string[] xx = new string[8];xx[0] = "aaaa";xx[1] = "bbbb";System.Console.WriteLine(xx[0]); //输出 aaaaSystem.Console.WriteLine(xx[1]); //输出 bbbb 字符串对象的不可变性123456789string text;System.Console.Write ("Enter text: ");text = System.Console.ReadLine ();// UNEXPECTED: Does not convert text to uppercasetext.ToUpper ();System.Console.WriteLine (text); 输出结果 Enter text: This is a test of the emergency broadcast system. This is a test of the emergency broadcast system. 字符串对象是“==不可变的==”：它们在创建后无法更改。 看起来是在修改字符串的所有 String 方法和 C# 运算符实际上都是在新的字符串对象中返回结果。 因此，text.ToUpper()不会改变 text 的内容为大写，而是返回了一个新的字符串，它需要保存到变量中，或者直接传给System.Console.WriteLine()。下面代码是改进后的： 12345string text, uppercase;System.Console.Write ("Enter text: ");text = System.Console.ReadLine (); // Return a new string in uppercaseuppercase = text.ToUpper ();System.Console.WriteLine (uppercase); 输出结果 Enter text: This is a test of the emergency broadcast system. THIS IS A TEST OF THE EMERGENCY BROADCAST SYSTEM. 访问单个字符 可以使用包含索引值的数组表示法来获取对单个字符的只读访问权限，如下面的示例中所示： 1234567string s5 = "Printing backwards";for (int i = 0; i &lt; s5.Length; i++)&#123; System.Console.Write(s5[s5.Length - i - 1]);&#125;// Output: "sdrawkcab gnitnirP" 如果 String 方法不提供修改字符串中的各个字符所需的功能，可以使用 ==StringBuilder== 对象“就地”修改各个字符，再新建字符串来使用 StringBuilder 方法存储结果。 在下面的示例中，假定必须以特定方式修改原始字符串，然后存储结果以供未来使用： 1234567891011121314string question = "hOW DOES mICROSOFT wORD DEAL WITH THE cAPS lOCK KEY?";System.Text.StringBuilder sb = new System.Text.StringBuilder(question);for (int j = 0; j &lt; sb.Length; j++)&#123; if (System.Char.IsLower(sb[j]) == true) sb[j] = System.Char.ToUpper(sb[j]); else if (System.Char.IsUpper(sb[j]) == true) sb[j] = System.Char.ToLower(sb[j]);&#125;// Store the new string.string corrected = sb.ToString();System.Console.WriteLine(corrected);// Output: How does Microsoft Word deal with the Caps Lock key? 使用 StringBuilder 快速创建字符串 .NET 中的字符串操作进行了高度的优化，在大多数情况下不会显著影响性能。 但是，在某些情况下（例如，执行数百次或数千次的紧密循环），字符串操作可能影响性能。 StringBuilder 类创建字符串缓冲区，用于在程序执行多个字符串操控时提升性能。 使用 StringBuilder 字符串，还可以重新分配各个字符，而内置字符串数据类型则不支持这样做。 例如，此代码更改字符串的内容，而无需创建新的字符串： 123456System.Text.StringBuilder sb = new System.Text.StringBuilder("Rat: the ideal pet");sb[0] = 'C';System.Console.WriteLine(sb.ToString());System.Console.ReadLine();//Outputs Cat: the ideal pet 在以下示例中，StringBuilder 对象用于通过一组数字类型创建字符串： 12345678910111213141516171819class TestStringBuilder&#123; static void Main() &#123; System.Text.StringBuilder sb = new System.Text.StringBuilder(); // Create a string composed of numbers 0 - 9 for (int i = 0; i &lt; 10; i++) &#123; sb.Append(i.ToString()); &#125; System.Console.WriteLine(sb); // displays 0123456789 // Copy one character of the string (not possible with a System.String) sb[0] = sb[9]; System.Console.WriteLine(sb); // displays 9123456789 &#125;&#125; Null 字符串和空字符串 空字符串是包含零个字符的 System.String 对象实例。 空字符串常用在各种编程方案中，表示空文本字段。 可以对空字符串调用方法，因为它们是有效的 System.String 对象。 对空字符串进行了初始化，如下所示： 1string s = String.Empty; 相比较而言，null 字符串并不指 System.String 对象实例，只要尝试对 null 字符串调用方法，都会引发 NullReferenceException。 但是，可以在串联和与其他字符串的比较操作中使用 null 字符串。 以下示例说明了对 null 字符串的引用会引发和不会引发意外的某些情况： 12345678910111213141516171819202122232425262728293031323334static void Main()&#123; string str = "hello"; string nullStr = null; string emptyStr = String.Empty; string tempStr = str + nullStr; // Output of the following line: hello Console.WriteLine(tempStr); bool b = (emptyStr == nullStr); // Output of the following line: False Console.WriteLine(b); // The following line creates a new empty string. string newStr = emptyStr + nullStr; // Null strings and empty strings behave differently. The following // two lines display 0. Console.WriteLine(emptyStr.Length); Console.WriteLine(newStr.Length); // The following line raises a NullReferenceException. //Console.WriteLine(nullStr.Length); // The null character can be displayed and counted, like other chars. string s1 = "\x0" + "abc"; string s2 = "abc" + "\x0"; // Output of the following line: * abc* Console.WriteLine("*" + s1 + "*"); // Output of the following line: *abc * Console.WriteLine("*" + s2 + "*"); // Output of the following line: 4 Console.WriteLine(s2.Length);&#125; 比较字符串1234567string sCompare = "h";int result = string.Compare (sCompare, "a");System.Console.WriteLine (result); //输出 1 "h" &gt; "a" result = string.Compare (sCompare, "h", true);System.Console.WriteLine (result); //输出 0 "h" = "h" result = string.Compare (sCompare, "x", true);System.Console.WriteLine (result); //输出 -1 "h" &lt; "x" 子字符串12345678string s3 = "Visual C# Express";System.Console.WriteLine (s3.Substring (7, 2)); // Output: "C#"System.Console.WriteLine (s3.Replace ("C#", "Basic")); // Output: "Visual Basic Express"// Index values are zero-basedint index = s3.IndexOf ("C"); // index = 7 null 和 void、 null 值表明变量不引用任何有效的对象。void 表示没有类型、或者没有任何值。 null null 可以作为字符串类型的字面量。null 值只能赋给引用类型、指针类型和可空类型。变量设为null，会显式地设置引用，使它不指向任何位置。 null 不等于 “” 。”” 意味变量有一个叫做“空字符串”的值。null 以为这变量无任何值。 void 指定为 void 类型就无需传递任何数据了。void 本质上并不是一个数据类型，知识用于指出没有数据类型这一事实。 高级主题：隐式类型的局部变量 C# 3.0增加了上下文关键字 var 来声明隐式类型的局部变量。该变量在编译时仍然会接收一个类型，但该类型是由编译器提供的。 虽然允许使用 var 取代显示的数据类型，但是在数据类型已知的情况下，最好不要使用 var。 C# 3.0添加 var 的目的是支持匿名类型。匿名类型是在方法内部动态声明数据类型，而不是通过显式的类定义来生命的，如下例： 12345678910111213141516171819202122232425262728using System;using System.Text;public class SamplesString &#123; public static void Main () &#123; var patent1 = new &#123; Title = "Bifocals", YearOfPublication = "1784" &#125;; var patent2 = new &#123; Title = "Phonograph", YearOfPublication = "1877" &#125;; System.Console.WriteLine ("&#123;0&#125; (&#123;1&#125;)", patent1.Title, patent1.YearOfPublication); System.Console.WriteLine ("&#123;0&#125; (&#123;1&#125;)", patent2.Title, patent2.YearOfPublication); Console.ReadKey (); &#125;&#125; 输出结果 Bifocals (1784) Phonograph (1877) var 声明局部变量的各种方式 123456789101112131415161718192021// i is compiled as an intvar i = 5;// s is compiled as a stringvar s = "Hello";// a is compiled as int[]var a = new[] &#123; 0, 1, 2 &#125;;// expr is compiled as IEnumerable&lt;Customer&gt;// or perhaps IQueryable&lt;Customer&gt;var expr = from c in customers where c.City == "London" select c;// anon is compiled as an anonymous typevar anon = new &#123; Name = "Terry", Age = 34 &#125;;// list is compiled as List&lt;int&gt;var list = new List&lt;int&gt;(); 在以下上下文中，使用 var 关键字 在 for 初始化语句中。 1for(var x = 1; x &lt; 10; x++) 在 foreach 初始化语句中。 1foreach(var item in list)&#123;...&#125; 在 using 域间中。 1using (var file = new StreamReader("C:\\myfile.txt")) &#123;...&#125; 可空修饰符 可以为null的类型 ?C# 2.0 开始引入的这个特性，没有值表示“未定义”的意思。 可通过以下两种方式之一声明可为 null 的类型： System.Nullable&lt;T&gt; variable T? variable T 是可以为 null 的类型的基础类型。 T 可以是包括 struct 在内的任意值类型；它不能是引用类型。 可为 null 的类型示例 int? 任何值类型都可用作 作为null的类型 的基础。例如： 12345int? i = 10;double? d1 = 3.14;bool? flag = null;char? letter = 'a';int?[] arr = new int?[10]; 可为 null 的类型的成员 可以为 null 的类型的每个实例都有两个公共只读属性： ==HasValue== 类型为 bool。 如果该变量包含非 null 值，则将其设置为 true。 ==Value== 与基础类型相同。 如果 HasValue 为 true，则 Value 包含有意义的值。 如果 HasValue 是 false，则访问 Value 将引发 InvalidOperationException。 将 null 赋给值类型，在数据库编程中尤其有用。在数据表中，经常出现值类型的列允许为空的情况。除非允许包含 null 值，否则在C#代码中检索这些列并将他们的值赋给对应的字段会出现问题。可控修饰符妥善地解决了这个问题。 高级主题：null 合并运算符 ?? ?? 运算符定义一个默认值，若将一个可为 null 的类型赋给不可为 null 的类型，则会返回该值。 ?? 运算符称作 null 合并运算符 (空接合操作符)。 如果此运算符的左操作数不为 null，则此运算符将返回左操作数；否则返回右操作数。 12345int? x = null;// Set y to the value of x if x is NOT null; otherwise,// if x == null, set y to -1.int y = x ?? -1; 空接合操作符可以“链接”。例如，对于表达式 x ?? y ?? z ,如果 x 不为 null 则返回 x ；否则，如果 y 不为 null 则返回 y；否则返回 z。 高级主题：NULL条件运算符 ?. ?[用于在执行成员访问 ==(?.)== 或索引 ==(?[)== ==操作之前==，测试是否存在 NULL。 这些运算符可帮助编写更少的代码来处理 null 检查，尤其是对于下降到数据结构。 12345678int? length = customers?.Length; // null if customers is null Customer first = customers?[0]; // null if customers is null // null if customers, the first customer, or Orders is nullint? count = customers?[0]?.Orders?.Count(); // ?. 结合 ??int? len = customers?.Length ?? 0; 高级主题：条件运算符 ?:条件运算符 ?: 根据 Boolean 表达式的值返回两个值之一。下面是条件运算符的语法。 condition ? first_expression : second_expression; condition 的计算结果必须为 true 或 false。 如果 condition 为 true，则将计算 first_expression 并使其成为结果。 如果 condition 为 false，则将计算 second_expression 并使其成为结果。 只计算两个表达式之一。first_expression 和 second_expression 的类型必须相同，或者必须存在从一种类型到另一种类型的隐式转换。 你可通过使用条件运算符表达可能更确切地要求 if-else 构造的计算。 例如，以下代码首先使用 if 语句，然后使用条件运算符将整数分类为正整数或负整数。 1234567891011int input = Convert.ToInt32(Console.ReadLine());string classify;// if-else construction.if (input &gt; 0) classify = "positive";else classify = "negative";// ?: conditional operator.classify = (input &gt; 0) ? "positive" : "negative"; 条件运算符为右联运算符。 表达式 a ? b : c ? d : e 作为 a ? b : (c ? d : e) 而非 (a ? b : c) ? d : e 进行计算。 无法重载条件运算符。 类型的分类值类型C# 中有两种类型：==引用类型==和==值类型==。 引用类型的变量存储对其数据（对象）的引用，而值类型的变量直接包含其数据。 对于引用类型，两种变量可引用同一对象；因此，对一个变量执行的操作会影响另一个变量所引用的对象。 对于值类型，每个变量都具有其自己的数据副本，对一个变量执行的操作不会影响另一个变量（ref 和 out 参数变量除外，请参阅 ref 和 out 参数修饰符）。 值类型直接包含值，变量引用的位置就是值在内存中的实际存储位置。 将一个变量的值赋给另一个变量会导致在新变量的位置创建原始变量值的一个内存副本。 类似的，将值类型的示例传给方法，如 Console.WriteLine(),也会产生一个内存副本。 由于值类型需要创建内存副本，因此定义时不要让它们占用太多内存（通常应该给小于16字节）。 引用类型 引用类型的变量存储的时对数据存储位置的引用，而不是直接存储数据。 数据类型 转换显式转换（explicit conversions | casts | 强制转换） 显式转换需要强制转换运算符。在==转换中可能丢失信息时或在出于其他原因转换可能不成功==时，必须进行强制转换。 典型的示例包括从数值到精度较低或范围较小的类型的转换和从基类实例到派生类的转换。 如果进行转换可能会导致信息丢失，则编译器会要求执行显式转换，显式转换也称为强制转换。 强制转换是显式告知编译器你打算进行转换且你知道可能会发生数据丢失的一种方式。 若要执行强制转换，请在要转换的值或变量前面的括号中指定要强制转换到的类型。下面的程序将 double 强制转换为 int。==如不强制转换则该程序不会进行编译==。 123456789101112class Test&#123; static void Main() &#123; double x = 1234.7; int a; // Cast double to int. a = (int)x; System.Console.WriteLine(a); &#125;&#125;// Output: 1234 有关支持的显式数值转换的列表，请参阅显式数值转换表。 高级主题：checked 和 unchecked 转换 在 cheecked 块内，如果在运行时发生一次溢出的赋值，就会引发异常。 123456789101112131415using System;using System.Text;public class Program &#123; public static void Main () &#123; checked &#123; // int.MaxValue equals 2147483647 int n = int.MaxValue; n = n + 1; System.Console.WriteLine (n); &#125; Console.ReadKey (); &#125;&#125; 输出结果 未经处理的异常: System.OverflowException: 算术运算导致溢出。 在 Program.Main() unchecked 块，强制不进行一处检查，不会为块中溢出的赋值引发异常。 123456789101112131415using System;using System.Text;public class Program &#123; public static void Main () &#123; unchecked &#123; // int.MaxValue equals 2147483647 int n = int.MaxValue; n = n + 1; System.Console.WriteLine (n); &#125; Console.ReadKey (); &#125;&#125; 输出结果 -2147483648 隐式转换（implicit conversions） 由于该转换是一种类型==安全的转换，不会导致数据丢失==，因此不需要任何特殊的语法。 对于内置数值类型，如果要存储的值==无需截断或四舍五入==即可适应变量，则可以进行隐式转换。 例如，long 类型的变量（8 字节整数）能够存储 int（在 32 位计算机上为 4 字节）可存储的任何值。 隐式转换无需使用转换操作符 12int intNumber = 31416;long longNumber = intNumber; 隐式转换 也可以强制添加转换操作符 12int intNumber = 31416;long longNumber = (long) intNumber; 不使用转型操作符的类型转换 ==字符串到数值类型== 转换，需要使用 Parse()/TryParse() 这样的方法。每个数值类型都包含 Parse()/TryParse() 方法，它允许将字符串还换成对应的数值类型。 例子 12string text = "9.11E-31";float kgElectronMass = float.Parse(text); 还可以利用 ==特殊类型System.Convert== 将一种类型转换成另一种类型。不过，System.Convert只支持预定义类型，而且是不可扩展的。它允许从任何==基元(基本)类型==（bool, char, sbyte, short, int, long, ushort, uint, ulong, float, double, decimal, DateTime, and string）转换到任何其它基元(基本)类型。参考 MSDN Convert.aspx) 类。 例子 123string middleCText = "261.626";double middleC = System.Convert.ToDouble(middleCText);bool boolean = System.Convert.ToBoolean(middleC); 除了以上方法，所有类型都支持==ToString()方法== 转换，可以用它得到一个类型的值的字符串表示。 例子 1234567bool boolean = true;string text = boolean.ToString();System.Console.WriteLine(text); // Display "True"double dVal = -1.123456;text=dVal.ToString();System.Console.WriteLine(dVal);// Display "-1.123456" 高级主题：TryParse()从 C# 2.0 开始，所有基元数据数据类型都包含静态 TryParse() 方法。该方法与 Parse() 非常相似，知识在缓缓失败的清康熙，它不引发异常，而是返回 false ，如下示例： 12345678910111213141516double number;string input;System.Console.Write("Enter a number: ");input = System.Console.ReadLine();if (double.TryParse(input, out number))&#123; // Converted correctly, now use number // ...&#125;else&#123; System.Console.WriteLine( "The text entered was not a valid number.");&#125; 高级主题：字符串转换为数字 字符串转数字的几种方法： Parse 转换对象必须是组成合适数值类型（int、long、ulong、float、decimal 等）的字符。(例如：Int32.Parse(“-15”)) TryParse 转换对象必须是组成合适数值类型（int、long、ulong、float、decimal 等）的字符。（例如：Int32.TryParse(“-15”, out j)） Convert.ToInt32 针对各种数值类型(int、long、float等，例如：Convert.ToInt32(“-15”)) 如果你具有字符串，则调用 TryParse 方法（例如 int.TryParse(“11”)）会稍微更加高效且简单。 使用 Convert 方法对于实现 IConvertible 的常规对象更有用。 可以对预期字符串会包含的数值类型（如 ==System.Int32== 类型）使用 Parse 或 TryParse 方法。 Convert.ToUInt32 方法在内部使用 Parse。 如果字符串的格式无效，则 Parse 会引发异常，而 TryParse 会返回 false。 示例 Parse 和 TryParse 例：System.Int32.Parse ==Parse 和 TryParse== 方法会忽略字符串开头和末尾的空格，但所有其他字符必须是组成合适数值类型（int、long、ulong、float、decimal 等）的字符。 组成数字的字符中的任何空格都会导致错误。 例如，可以使用 decimal.TryParse 分析“10”、“10.3”、“ 10 ”，但不能使用此方法分析从“10X”、“1 0”（注意空格）、“10 .3”（注意空格）、“10e1”（float.TryParse 在此处适用）等中分析出 10。 下面的示例演示了对 Parse 和 TryParse 的成功调用和不成功的调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections;using System.Collections.Generic;using System.Linq;public class Program &#123; public static void Main () &#123; int numVal = Int32.Parse ("-105"); Console.WriteLine (numVal); // Output: -105 double dVal = Double.Parse("105.12345"); Console.WriteLine(dVal); // 输出 105.12345 // TryParse returns true if the conversion succeeded // and stores the result in j. int j; if (Int32.TryParse ("-105", out j)) Console.WriteLine (j); else Console.WriteLine ("String could not be parsed."); // Output: -105 try &#123; int m = Int32.Parse ("abc"); &#125; catch (FormatException e) &#123; Console.WriteLine (e.Message); &#125; // Output: Input string was not in a correct format. string inputString = "abc"; int numValue; bool parsed = Int32.TryParse (inputString, out numValue); if (!parsed) Console.WriteLine ("Int32.TryParse could not parse '&#123;0&#125;' to an int.\n", inputString); // Output: Int32.TryParse could not parse 'abc' to an int. Console.ReadKey (); &#125;&#125; 示例 Convert 例：System.Convert.ToInt32 下表列出了 Convert 类中可使用的一些方法。 数值类型 方法 decimal ToDecimal(String) float ToSingle(String) double ToDouble(String) short ToInt16(String) int ToInt32(String) long ToInt64(String) ushort ToUInt16(String) uint ToUInt32(String) ulong ToUInt64(String) 此示例调用 Convert.ToInt32(String) 方法将输入的 string 转换为 int。 代码将捕获此方法可能引发的最常见的两个异常：FormatException 和 OverflowException。 如果该数字可以递增而不溢出整数存储位置，则程序使结果加上 1 并打印输出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960using System;using System.Collections;using System.Collections.Generic;using System.Linq;public class Program &#123; static void Main (string[] args) &#123; int numVal = -1; bool repeat = true; while (repeat) &#123; Console.WriteLine ("Enter a number between −2,147,483,648 and +2,147,483,647 (inclusive)."); string input = Console.ReadLine (); // ToInt32 can throw FormatException or OverflowException. try &#123; numVal = Convert.ToInt32 (input); &#125; catch (FormatException e) &#123; Console.WriteLine ("Input string is not a sequence of digits."); &#125; catch (OverflowException e) &#123; Console.WriteLine ("The number cannot fit in an Int32."); &#125; finally &#123; if (numVal &lt; Int32.MaxValue) &#123; Console.WriteLine ("The new value is &#123;0&#125;", numVal + 1); &#125; else &#123; Console.WriteLine ("numVal cannot be incremented beyond its current value"); &#125; &#125; Console.WriteLine ("Go again? Y/N"); string go = Console.ReadLine (); if (go == "Y" || go == "y") &#123; repeat = true; &#125; else &#123; repeat = false; &#125; &#125; // Keep the console open in debug mode. Console.WriteLine ("Press any key to exit."); Console.ReadKey (); &#125; // Sample Output: // Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive). // 473 // The new value is 474 // Go again? Y/N // y // Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive). // 2147483647 // numVal cannot be incremented beyond its current value // Go again? Y/N // Y // Enter a number between -2,147,483,648 and +2,147,483,647 (inclusive). // -1000 // The new value is -999 // Go again? Y/N // n // Press any key to exit.&#125; 高级主题：字节数组转换为数字 BitConverter 此示例演示如何使用 BitConverter 类将字节数组转换为 int 然后又转换回字节数组。 例如，在从网络读取字节之后，可能需要将字节转换为内置数据类型。 除了示例中的 ToInt32(Byte[],Int32) 方法之外，下表还列出了 BitConverter 类中将字节（来自字节数组）转换为其他内置类型的方法。 返回类型 方法 bool ToBoolean(Byte[],Int32) char ToChar(Byte[],Int32) double ToDouble(Byte[],Int32) short ToInt16(Byte[],Int32) int ToInt32(Byte[],Int32) long ToInt64(Byte[],Int32) float ToSingle(Byte[],Int32) ushort ToUInt16(Byte[],Int32) uint ToUInt32(Byte[],Int32) ulong ToUInt64(Byte[],Int32) Returns a 32-bit signed integer converted from four bytes at a specified position in a byte array. 1public static int ToInt32 (byte[] value, int startIndex); 示例 BitConverter.ToInt32 此示例初始化字节数组，并在计算机体系结构为 ==little-endian==（即首先存储最低有效字节）的情况下==反转数组==，然后调用 ToInt32(Byte[],Int32) 方法以将数组中的四个字节转换为 int。 ToInt32(Byte[],Int32) 的第二个参数指定字节数组的起始索引。 12345678910byte[] bytes = &#123; 0, 0, 0, 25 &#125;;// If the system architecture is little-endian (that is, little end first),// reverse the byte array.if (BitConverter.IsLittleEndian) Array.Reverse(bytes);int i = BitConverter.ToInt32(bytes, 0);Console.WriteLine("int: &#123;0&#125;", i);// Output: int: 25 示例 BitConverter.GetBytes 在本示例中，将调用 BitConverter 类的 GetBytes(Int32) 方法，将 int 转换为字节数组。 123byte[] bytes = BitConverter.GetBytes(201805978);Console.WriteLine("byte array: " + BitConverter.ToString(bytes));// Output: byte array: 9A-50-07-0C 高级主题：十六进制字符串与数值类型之间转换 以下示例演示如何执行下列任务： 获取字符串中每个字符的十六进制值。 获取与十六进制字符串中的每个值对应的 char。 将十六进制 string 转换为 int。 将十六进制 string 转换为 float。 将字节数组转换为十六进制 string。&gt; - 示例 解析字符得到16进制值此示例输出 string 中每个字符的十六进制值。 123456789101112131415using System;public class Program &#123; static void Main (string[] args) &#123; string input = "你好 大世界！Hello World!"; for (int i = 0; i &lt; input.Length; i++) &#123; // 占位符 方式 //Console.Write ("&#123;0&#125; &#123;1&#125; ", input[i], ((int) input[i]).ToString ("X")); // 字符串内插 $ 方式 Console.Write ($"&#123;input[i]&#125; &#123;((int)input[i]).ToString("X")&#125; "); &#125; System.Console.WriteLine (); Console.ReadKey (); &#125;&#125; 你 4F60 好 597D 20 大 5927 世 4E16 界 754C ！ FF01 H 48 e 65 l 6C l 6C o 6F 20 W 57 o 6F r 72 l 6C d 64 ! 21 示例 从16进制值得到对应字符此示例分析十六进制值的 string 并输出对应于每个十六进制值的字符。 首先，调用 Split(Char[]) 方法以获取每个十六进制值作为数组中的单个 string。 然后，调用 ToInt32(String, Int32)将十六进制值转换为表示为 int 的十进制值。示例中演示了 2 种不同方法，用于获取对应于该字符代码的字符。 第 1 种方法是使用 ConvertFromUtf32(Int32)，它将对应于整型参数的字符作为 string 返回。 第 2 种方法是将 int 显式转换为 char。 1234567891011121314151617181920212223using System;public class Program &#123; static void Main (string[] args) &#123; //将指定的 Unicode 码位转换为 UTF-16 编码字符串。 string hexValues = "5927 20 48 65 6C 6C 6F 20 57 6F 72 6C 64 21"; // 大 Hello World！ string[] hexValuesSplit = hexValues.Split(' '); for (int i = 0; i &lt; hexValuesSplit.Length; i++) &#123; // 将 16 进制数值 转换为 整型（10进制） int value = Convert.ToInt32(hexValuesSplit[i], 16); // 得到 编码值对应的 字符 | 将指定的 Unicode 码位转换为 UTF-16 编码字符串。 string stringValule = char.ConvertFromUtf32(value); System.Console.Write(stringValule); //一句话表示，有点难于解读 //System.Console.Write(char.ConvertFromUtf32(Convert.ToInt32(hexValuesSplit[i],16))); &#125; System.Console.WriteLine (); Console.ReadKey (); &#125;&#125; 输出结果 大 Hello World! 数组可以将同一类型的多个变量存储在一个数组数据结构中。 通过指定数组的元素类型来声明数组。 type[] arrayName; 数组具有以下属性： 数组可以是一维(==Single-Dimesional==)、多维(==Multidimesional==)或交错(==Jagged==)的。 创建数组实例时，将建立纬度数量和每个纬度的长度。这些值在实例的生存期内无法更改。 交错数组是数组的数组,因此其元素为引用类型且被初始化为null。 数组从零开始编制索引：包含 n 元素的数组从 0 索引到 n-1。 数组元素可以是任何类型，其中包括数组类型。 数组的维数使用 Rank 属性显示数组的维数。 1234// Declare and initialize an array:int[,] theArray = new int[5, 10];// 输出 这是一个 2 维数组。System.Console.WriteLine("这是一个 &#123;0&#125; 维数组。", theArray.Rank); 一维数组数组声明 一维 声明五个整数的一维数组，如以下示例所示： 1int[] array = new int[5]; 此数组包含从 array[0] 到 array[4] 的元素。 new 运算符用于创建数组并将数组元素初始化为其默认值。在此示例中，所有数组元素都将被==初始化为零==。 声明字符串数组 1string[] stringArray = new string[6]; 数组初始化 一维12int[] array1 = new int[] &#123; 1, 3, 5, 7, 9 &#125;;string[] weekDays = new string[] &#123; "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" &#125;; 声明初始化的缩写(快捷)方式 12int[] array1 = &#123; 1, 3, 5, 7, 9 &#125;;string[] weekDays = &#123; "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" &#125;; 可以在不初始化的情况下声明数组变量，但必须使用 new 运算符向此变量分配数组。 例如: 123int[] array3;array3 = new int[] &#123; 1, 3, 5, 7, 9 &#125;; // OK//array3 = &#123;1, 3, 5, 7, 9&#125;; // Error 多维数组 多为数组的每一维的大小都必须一致。而 ==交错数组== （jagged array）则不需要。 得到多维数组中某一维的长度，不是使用Length属性，而是使用数组的GetLength()示例方法。 123bool[,,] cells;cells = new bool[2,3,3];System.Console.WriteLine(cells.GetLength(0)); // Displays 2 数组声明 多维1234// 声明创建一个具有四行两列的二维数组。int[,] array = new int[4, 2];// 声明创建一个具有三个维度（4、2 和 3）的数组。int[, ,] array1 = new int[4, 2, 3]; 数组初始化 多维 声明后即可初始化数组，如以下示例所示。 12345678910111213141516171819202122232425262728293031323334353637383940414243// Two-dimensional array.int[,] array2D = new int[,] &#123; &#123; 1, 2 &#125;, &#123; 3, 4 &#125;, &#123; 5, 6 &#125;, &#123; 7, 8 &#125; &#125;;// The same array with dimensions specified.int[,] array2Da = new int[4, 2] &#123; &#123; 1, 2 &#125;, &#123; 3, 4 &#125;, &#123; 5, 6 &#125;, &#123; 7, 8 &#125; &#125;;// A similar array with string elements.string[,] array2Db = new string[3, 2] &#123; &#123; "one", "two" &#125;, &#123; "three", "four" &#125;, &#123; "five", "six" &#125; &#125;;// Three-dimensional array.int[, ,] array3D = new int[,,] &#123; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125; &#125;, &#123; &#123; 7, 8, 9 &#125;, &#123; 10, 11, 12 &#125; &#125; &#125;;// The same array with dimensions specified.int[, ,] array3Da = new int[2, 2, 3] &#123; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125; &#125;, &#123; &#123; 7, 8, 9 &#125;, &#123; 10, 11, 12 &#125; &#125; &#125;;// Accessing array elements.System.Console.WriteLine(array2D[0, 0]);System.Console.WriteLine(array2D[0, 1]);System.Console.WriteLine(array2D[1, 0]);System.Console.WriteLine(array2D[1, 1]);System.Console.WriteLine(array2D[3, 0]);System.Console.WriteLine(array2Db[1, 0]);System.Console.WriteLine(array3Da[1, 0, 1]);System.Console.WriteLine(array3D[1, 1, 2]);// Getting the total count of elements or the length of a given dimension.var allLength = array3D.Length;var total = 1;for (int i = 0; i &lt; array3D.Rank; i++) &#123; total *= array3D.GetLength(i);&#125;System.Console.WriteLine("&#123;0&#125; equals &#123;1&#125;", allLength, total);// Output:// 1// 2// 3// 4// 7// three// 8// 12// 12 equals 12 交错数组 jagged array 交错数组是元素为数组的数组。 交错数组元素的维度和大小可以不同。 交错数组有时称为“数组的数组”。 123456int[][] cells = &#123; new int[]&#123;1, 0, 2, 0&#125;, new int[]&#123;1, 2, 0&#125;, new int[]&#123;1, 2&#125;, new int[]&#123;1&#125;&#125;; 声明一个具有三个元素的一维数组，其中每个元素都是一维整数数组： 1int[][] jaggedArray = new int[3][]; 必须初始化 jaggedArray 的元素后才可使用它。 可按下方操作初始化元素： 123jaggedArray[0] = new int[5];jaggedArray[1] = new int[4];jaggedArray[2] = new int[2]; 每个元素都是一维整数数组。 第一个元素是由 5 个整数组成的数组，第二个是由 4 个整数组成的数组，而第三个是由 2 个整数组成的数组。 也可使用初始化表达式通过值来填充数组元素，这种情况下不需要数组大小。 例如: 123jaggedArray[0] = new int[] &#123; 1, 3, 5, 7, 9 &#125;;jaggedArray[1] = new int[] &#123; 0, 2, 4, 6 &#125;;jaggedArray[2] = new int[] &#123; 11, 22 &#125;; 还可在声明数组时将其初始化，如： 12345int[][] jaggedArray2 = new int[][] &#123; new int[] &#123; 1, 3, 5, 7, 9 &#125;, new int[] &#123; 0, 2, 4, 6 &#125;, new int[] &#123; 11, 22 &#125;&#125;; 可以使用下面的缩写形式。 请注意：不能从元素初始化中省略 new 运算符，因为不存在元素的默认初始化： 12345int[][] jaggedArray3 = &#123; new int[] &#123; 1, 3, 5, 7, 9 &#125;, new int[] &#123; 0, 2, 4, 6 &#125;, new int[] &#123; 11, 22 &#125;&#125;; 可以混合使用交错数组和多维数组。 下面声明和初始化一个包含大小不同的三个二维数组元素的一维交错数组。 123456int[][,] jaggedArray4 = new int[3][,] &#123; new int[,] &#123; &#123;1,3&#125;, &#123;5,7&#125; &#125;, new int[,] &#123; &#123;0,2&#125;, &#123;4,6&#125;, &#123;8,10&#125; &#125;, new int[,] &#123; &#123;11,22&#125;, &#123;99,88&#125;, &#123;0,9&#125; &#125; &#125;; 可以如本例所示访问个别元素，示例显示第一个数组的元素 [1,0] 的值（值为 5）： 1System.Console.Write("&#123;0&#125;", jaggedArray4[0][1, 0]); 方法 Length 返回包含在交错数组中的数组的数目。例如，假定已声明了前一个数组，则下行返回值 3。 1System.Console.WriteLine(jaggedArray4.Length); 隐式类型的数组 可以创建隐式类型化的数组，其中数组实例的类型通过数组初始值设定项中指定的元素来推断。 针对隐式类型化变量的任何规则也适用于隐式类型化数组。 12345678910111213141516171819202122class ImplicitlyTypedArraySample&#123; static void Main() &#123; var a = new[] &#123; 1, 10, 100, 1000 &#125;; // int[] var b = new[] &#123; "hello", null, "world" &#125;; // string[] // single-dimension jagged array var c = new[] &#123; new[]&#123;1,2,3,4&#125;, new[]&#123;5,6,7,8&#125; &#125;; // jagged array of strings var d = new[] &#123; new[]&#123;"Luca", "Mads", "Luke", "Dinesh"&#125;, new[]&#123;"Karen", "Suma", "Frances"&#125; &#125;; &#125;&#125; 在上个示例中，请注意对于隐式类型化数组，初始化语句的左侧没有使用方括号。 另请注意，和一维数组一样，通过使用 new [] 来初始化交错数组。 对数组使用循环 for foreach 一维数组 123456int[] numbers = &#123; 4, 5, 6, 1, 2, 3, -2, -1, 0 &#125;;foreach (int i in numbers)&#123; System.Console.Write("&#123;0&#125; ", i);&#125;// Output: 4 5 6 1 2 3 -2 -1 0 多维数组 123456789int[,] numbers2D = new int[3, 2] &#123; &#123; 9, 99 &#125;, &#123; 3, 33 &#125;, &#123; 5, 55 &#125; &#125;;// Or use the short form:// int[,] numbers2D = &#123; &#123; 9, 99 &#125;, &#123; 3, 33 &#125;, &#123; 5, 55 &#125; &#125;;foreach (int i in numbers2D)&#123; System.Console.Write("&#123;0&#125; ", i);&#125;// Output: 9 99 3 33 5 55 交错数组 123456789101112int[][] jaggedArray3 = &#123; new int[] &#123; 1, 3, 5, 7, 9 &#125;, new int[] &#123; 0, 2, 4, 6 &#125;, new int[] &#123; 11, 22 &#125;&#125;;foreach (var item in jaggedArray3) &#123; for (int i = 0; i &lt; item.Length; i++) &#123; System.Console.Write ("&#123;0&#125; ", item[i]); &#125;&#125;// 输出：1 3 5 7 9 0 2 4 6 11 22 常见数组编码错误代码中包含双重大括号，hexo无法编译，用转义的话Markdown文件不利阅读，所以采用图片替代。 枚举类型声明定义enum 关键字用于声明枚举，一种包含一组被称为枚举数列表的已命名常数的不同类型。通常最好是直接在命名空间内定义枚举，以便命名空间中的所有类都可以同样方便地访问它。 但是，也可能会在类或结构中嵌套枚举。默认情况下，枚举中每个元素的==基础类型都为 int==。默认情况下，==第一个枚举数具有值 0==，并且每个连续枚举数的值将增加 1。 例如，在以下枚举中， Sat 的值为 0， Sun 的值为 1， Mon 的值为 2，依次类推。 1enum Days &#123;Sat, Sun, Mon, Tue, Wed, Thu, Fri&#125;; 枚举数可以使用初始值设定项来替代默认值，如下面的示例中所示。 1enum Days &#123;Sat=1, Sun, Mon, Tue, Wed, Thu, Fri&#125;; 在此枚举中，强制元素的序列从 1 开始，而不是 0。 但建议包括一个值为 0 的常量。 有关详细信息，请参阅枚举类型。 每个枚举类型都有一个基础类型，该基础类型可以是除 char 外的任何整型类型。 枚举元素的默认基础类型是 int。若要声明另一整型的枚举（如 byte），则请在后跟该类型的标识符后使用冒号，如以下示例所示。 1enum Days : byte &#123;Sat=1, Sun, Mon, Tue, Wed, Thu, Fri&#125;; 枚举的已批准类型有 byte、 sbyte、 short、 ushort、 int、 uint、 long或 ulong。有关可能的类型的完整列表，请参阅 enum（C# 参考）。 基础类型指定为每个枚举数分配多少存储空间。 但要将 enum 类型转换为整型，==则必须使用显示转换==。 例如，以下语句通过使用转换将 Sun 转换为 ，从而将枚举数 赋值为 enum int int类型的变量。 1int x = (int)Days.Sun; 可以为枚举类型的枚举器列表中的元素分配任何值，也==可以使用计算值==，计算因子必须是已经有确定的值的枚举元素，不能包含后面的值未确定的元素： 12345678910111213141516171819202122232425262728293031using System;public class EnumTest&#123; enum Day &#123; Sunday=6, Monday=3, Tuesday = Sunday + Monday, Wednesday, Thursday, Friday, Saturday &#125;; static void Main() &#123; Console.WriteLine(Day.Sunday); Console.WriteLine(Day.Friday); Console.WriteLine((int)Day.Sunday); Console.WriteLine((int)Day.Monday); Console.WriteLine((int)Day.Tuesday); Console.WriteLine((int)Day.Wednesday); Console.WriteLine((int)Day.Thursday); Console.WriteLine((int)Day.Friday); Console.WriteLine((int)Day.Saturday); Console.ReadKey(); &#125;&#125;/* 输出SundayFriday63910111213*/ 使用 System.Enum 方法来发现和操作枚举值12345678910string s = Enum.GetName(typeof(Days), 16);Console.WriteLine(s);Console.WriteLine("The values of the Day Enum are:");foreach (int i in Enum.GetValues(typeof(Days))) Console.WriteLine(i);Console.WriteLine("The names of the Day Enum are:");foreach (string str in Enum.GetNames(typeof(Days))) Console.WriteLine(str); 输出结果 Thursday The values of the Day Enum are: 0 1 2 4 8 16 32 64 The names of the Day Enum are: None Sunday Monday Tuesday Wednesday Thursday Friday Saturday 高级主题：作为位标志的枚举类型创建==位标志枚举==的方法是，应用 FlagsAttribute 属性并适当定义一些值，以便可以对这些值执行 AND、OR、NOT 和 XOR 按位运算。 在位标志枚举中，包括一个值为零（表示“未设置任何标志”）的命名常量。 如果零值不表示“未设置任何标志”，请勿为标志指定零值。 在以下示例中，定义了名为 Days 枚举的另一个版本。 Days 具有 Flags 属性，且它的每个值都是 2 的若干次幂，指数依次递增。 这样，你就能够创建值为 Days.Tuesday | Days.Thursday 的 Days 变量。 12345678910111213141516[Flags]enum Days&#123; None = 0x0, Sunday = 0x1, Monday = 0x2, Tuesday = 0x4, Wednesday = 0x8, Thursday = 0x10, Friday = 0x20, Saturday = 0x40&#125;class MyClass&#123; Days meetingDays = Days.Tuesday | Days.Thursday;&#125; 若要在枚举上设置标志，请使用按位 OR 运算符，如以下示例所示： 12345678910111213// Initialize with two flags using bitwise OR.meetingDays = Days.Tuesday | Days.Thursday;// Set an additional flag using bitwise OR.meetingDays = meetingDays | Days.Friday;Console.WriteLine("Meeting days are &#123;0&#125;", meetingDays);// Output: Meeting days are Tuesday, Thursday, Friday// Remove a flag using bitwise XOR.meetingDays = meetingDays ^ Days.Tuesday;Console.WriteLine("Meeting days are &#123;0&#125;", meetingDays);// Output: Meeting days are Thursday, Friday 若要确定是否设置了特定标志，请使用按位 AND 运算，如以下示例所示： 1234// Test value of flags using bitwise AND.bool test = (meetingDays &amp; Days.Thursday) == Days.Thursday;Console.WriteLine("Thursday &#123;0&#125; a meeting day.", test == true ? "is" : "is not");// Output: Thursday is a meeting day. 结尾]]></content>
      <tags>
        <tag>C#</tag>
        <tag>C#本质论</tag>
        <tag>Essential C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#本质论笔记 第1章 C#概述]]></title>
    <url>%2F2017%2F12%2F13%2FCSharp%E6%9C%AC%E8%B4%A8%E8%AE%BA%E7%AC%94%E8%AE%B0-%E7%AC%AC1%E7%AB%A0-CSharp%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[HelloWorld本书中的例子1234567class HelloWorld&#123; static void Main() &#123; System.Console.WriteLine("Hello World!"); &#125;&#125; 其他例子123456789using System;class Hello&#123; static void Main() &#123; Console.WriteLine("Hello World!"); &#125;&#125; VS IDE自动生成例子12345678910111213141516using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace HelloWorld&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("Hello World!"); &#125; &#125;&#125; 语法基础标识符大小写风格Pacal风格 (PascalCase/Pascal case) 每个单词首字母大写，例如：ComponentModel, Configuration, and HttpFileCollection. 注意在 HttpFileCollection中，由于首字母缩写词HTTP的长度超过两个字母，所以仅首字母大写。 camel风格 (camelCase/camel Case) 除了第一个字母小写，其他约定与Pascal大小写放个一样，例如：quotient, firstName, httpFileCollection, ioStream, and theDreadPirateRoberts. 形参与实参12345678910111213141516namespace ConsoleApplication&#123; class Program &#123; static void Main(string[] args) &#123; int a = 5; abc(a); //a就是实参 &#125; static int abc(int c) //c就是形参 &#123; return 5; &#125; &#125;&#125; Main Main 方法是 C# 控制台应用程序或窗口应用程序的入口点。 （库和服务不要求将 Main 方法作为入口点。） 应用程序启动时，Main 方法是第一个调用的方法。 C# 程序中只能有一个入口点。 如果您有多个类都包含 Main 方法，则必须使用 /main 编译器选项编译您的程序，以指定用作入口点的 Main 方法。 不带参数的Main12345678class Hello&#123; static void Main() &#123; System.Console.WriteLine("Hello World!"); System.Console.ReadKey(); &#125;&#125; 带参数的Main12345678class Hello&#123; static void Main(string[] args) &#123; System.Console.WriteLine("Hello World!"); System.Console.ReadKey(); &#125;&#125; Main 概述 Main 方法是 .exe 程序的入口点，程序控制流在该处开始和结束。 Main 在类或结构内声明。 Main 必须是静态的，且不应该是 公用的。 （在前面的示例中，它接受默认访问级别 private。）但不要求封闭类或结构是静态的。 Main 的返回类型有两种：void 或 int。 所声明的 Main 方法可以具有包含命令行实参的 string[] 形参，也可以不具有这样的形参。 使用 Visual Studio 创建 Windows 窗体应用程序时，可以手动添加形参，也可以使用 Environment 类获取命令行实参。 形参读取为从零开始编制索引的命令行实参。 与 C 和 C++ 不同，不会将程序名称视为第一个命令行实参。 Main 例子12345678910111213class Hello&#123; static void Main(string[] args) &#123; System.Console.WriteLine("Hello World!"); System.Console.WriteLine(args.Length); System.Console.WriteLine(System.Environment.CommandLine); System.Console.WriteLine(System.Environment.CurrentDirectory); System.Console.WriteLine(System.Environment.MachineName); System.Console.WriteLine(System.Environment.UserName); System.Console.ReadKey(); &#125;&#125; 编译上面代码，在控制台输入 ==HelloWorld.exe== 输出结果 Hello World! 0 helloworld.exe D:\WaProj\Essential C#5.0, 4th Edition\第一章 DESKTOP-D10TF3C ihome 编译上面代码，在控制台输入 ==HelloWorld== 输出结果 Hello World! 0 helloworld D:\WaProj\Essential C#5.0, 4th Edition\第一章 DESKTOP-D10TF3C ihome 单行多行语句一行包含多条语句1System.Console.WriteLine("1");System.Console.WriteLine("2"); 输出结果 1 2 一条语句跨越多行12System.Console.WriteLine( "Hello World!"); 输出结果 Hello World! 错误示例12System.Console.WriteLine("Hello World!"); 错误提示 HelloWorld.cs(5,31): error CS1010: 常量中有换行符 HelloWorld.cs(6,12): error CS1010: 常量中有换行符 缩进和空白 例子1 12345678class Hello&#123; static void Main() &#123; System.Console.WriteLine("Hello World!"); System.Console.ReadKey(); &#125;&#125; 例子2 1class Hello&#123;static void Main()&#123;System.Console.WriteLine("Hello World!");System.Console.ReadKey();&#125;&#125; 上面两个例子输出结果相同，对编译器来说无差别。 变量声明与赋值1234567891011121314151617181920212223242526class Hello&#123; static void Main() &#123; string valerie; //定义变量并赋值 string max = "Have fun storming the castle!"; valerie = "Think it will work?"; System.Console.WriteLine(max); System.Console.WriteLine(valerie); //重新赋值 max = "It would take a miracle."; System.Console.WriteLine(max); string boys,girls; //多赋值操作 boys = girls = "We Are Young."; System.Console.WriteLine(boys); System.Console.WriteLine(girls); System.Console.ReadKey(); &#125;&#125; 输出结果 Have fun storming the castle! Think it will work? It would take a miracle. We Are Young. We Are Young. 高级主题：字符串不可变所有string类型数据，都是不可变的（或者说不可修改的），例如：不可能将字符串“We Are Yong.”修改为“We Are Old.”。也就是说，不能修改变量最初引用的数据，只能重新赋值，让它指向内存中的新位置。 控制台输入输出从控制台获取输入使用System.Console.ReadLine()1234567891011121314151617class Hello&#123; static void Main() &#123; string firstName; string lastName; System.Console.Write("Enter your first name: "); firstName = System.Console.ReadLine(); System.Console.Write("Enter your last name: "); lastName = System.Console.ReadLine(); System.Console.WriteLine("Hello " + firstName + " " + lastName); System.Console.ReadKey(); &#125;&#125; 输出结果 Enter your first name: Jon Enter your last name: Snow Hello Jon Snow 高级主题：System.Console.Read() System.Console.Read()方法返回的是与读取的字符值对应的证书，如果没有更多的字符可用，就返回-1。为了获取实际字符，需要先将证书转型为字符，代码如下： 代码示例 11234567891011121314class Hello&#123; static void Main() &#123; int readValue; char character; readValue = System.Console.Read(); character = (char) readValue; System.Console.WriteLine(character); System.Console.ReadKey(); &#125;&#125; System.Console.Read() 从标准输入流读取下一个字符。 System.Console.ReadKey() 获取用户按下的下一个字符或功能键。 按下的键显示在控制台窗口中。 按回车键之前，System.Console.Read()方法不会返回输入，即使用户输入了多个字符。 输入 123，按回车，再输入 a，输出结果 123 1 a 代码示例 21234567891011121314151617181920class Hello&#123; static void Main() &#123; int readValueFirst,readValueSecond,readValueThird; char character; readValueFirst = System.Console.Read(); character = (char) readValueFirst; System.Console.WriteLine(character); readValueSecond = System.Console.Read(); character = (char) readValueSecond; System.Console.WriteLine(character); readValueThird = System.Console.Read(); character = (char) readValueThird; System.Console.WriteLine(character); System.Console.ReadKey(); &#125;&#125; System.Console.Read() 从标准输入流读取下一个字符。 System.Console.ReadKey() 获取用户按下的下一个字符或功能键。 按下的键显示在控制台窗口中。 按回车键之前，System.Console.Read()方法不会返回输入，即使用户输入了多个字符。 输入 123，按回车，再输入 a，输出结果 123 1 2 3 a 上面两个示例，输入信息相同，由于代码不同因而输出结果不同。 输出到控制台 System.Console.Write() 输出后不添加换行符（当前行终止符）。System.Console.WriteLine() 将参数内容（后跟当前行终止符）写入标准输出流，输出后，光标切换到下一行。 123456789101112131415161718class Hello&#123; static void Main() &#123; string firstName; string lastName; System.Console.Write("Enter your first name: "); firstName = System.Console.ReadLine(); System.Console.Write("Enter your last name: "); lastName = System.Console.ReadLine(); System.Console.WriteLine( "Hello &#123;0&#125; &#123;1&#125;.", firstName, lastName); System.Console.ReadKey(); &#125;&#125; 示例代码中”Hello {0} {1}.”，标识了两个索引占位符，用于在字符串中插入数据。 输出结果 Enter your first name: Jon Enter your last name: Snow Hello Jon Snow. 交换索引占位符和对应变量 12System.Console.WriteLine( "Hello &#123;1&#125;, &#123;0&#125;.", firstName, lastName); 输出结果 Enter your first name: Jon Enter your last name: Snow Hello Snow, Jon. 代码注释1234567891011121314151617181920212223242526class Hello&#123; static void Main() &#123; string firstName; //存储名字的变量【单行注释】 string lastName; //存储姓氏的变量【单行注释】 System.Console.Write/*不换行输出【语句内部带分隔符注释】*/( "Enter your first name: "); firstName = System.Console.ReadLine(); System.Console.Write/*不换行输出【语句内部带分隔符注释】*/( "Enter your last name: "); lastName = System.Console.ReadLine(); /* 使用复合格式化在控制台显示问候语。 */ System.Console.WriteLine( "Hello &#123;1&#125;, &#123;0&#125;.", firstName, lastName); System.Console.ReadKey(); //这是程序列表的结尾 &#125;&#125; 目前观点 不要使用注释，除非代码本身“一言难尽”。 要尽量编写清晰的代码，而不是通过注释澄清复杂算法。 CIL和ILDAASM (公共中间语言和IL反汇编)C#编译器将C#代码转换成CIL代码而不是机器码。对于一个程序集(DLL文件或可执行文件)，可以使用CIL反汇编程序将其析构成对应的CIL表示，从而查看其CIL代码。微软的反汇编程序文件：ILDASM（IL Disassembler）,可以对程序或者类库执行反汇编，显示由C#编译器生成的CIL代码。 ildasm.exe存在与C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1 Tools类似位置 例子 ildasm /text hello.exe 输出结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566D:\WaProj\Essential C#5.0, 4th Edition\第一章&gt;ildasm /text hello.exe// Microsoft (R) .NET Framework IL Disassembler. Version 4.6.1055.0// Metadata version: v4.0.30319.assembly extern mscorlib&#123; .publickeytoken = (B7 7A 5C 56 19 34 E0 89 ) // .z\V.4.. .ver 4:0:0:0&#125;.assembly Hello&#123; .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78 // ....T..WrapNonEx 63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 ) // ceptionThrows. .hash algorithm 0x00008004 .ver 0:0:0:0&#125;.module Hello.exe// MVID: &#123;BDAC1292-8393-4BEB-9AD7-40DC171B0BF9&#125;.imagebase 0x00400000.file alignment 0x00000200.stackreserve 0x00100000.subsystem 0x0003 // WINDOWS_CUI.corflags 0x00000001 // ILONLY// Image base: 0x02CF0000// =============== CLASS MEMBERS DECLARATION ===================.class private auto ansi beforefieldinit Hello extends [mscorlib]System.Object&#123; .method private hidebysig static void Main(string[] args) cil managed &#123; .entrypoint // 代码大小 19 (0x13) .maxstack 8 IL_0000: nop IL_0001: ldstr &quot;Hello World!&quot; IL_0006: call void [mscorlib]System.Console::WriteLine(string) IL_000b: nop IL_000c: call valuetype [mscorlib]System.ConsoleKeyInfo [mscorlib]System.Console::ReadKey() IL_0011: pop IL_0012: ret &#125; // end of method Hello::Main .method public hidebysig specialname rtspecialname instance void .ctor() cil managed &#123; // 代码大小 7 (0x7) .maxstack 8 IL_0000: ldarg.0 IL_0001: call instance void [mscorlib]System.Object::.ctor() IL_0006: ret &#125; // end of method Hello::.ctor&#125; // end of class Hello// =============================================================// *********** 反汇编完成 *********************** /text 选项制定输出到命令控制台，而不是在ildasm的图形界面程序中显示。 常见.NET反汇编工具 dnSpy (免费) 具备调试功能 ILSpy (免费) dotPeek (免费) 生成代码质量较高，Visual Studio风格界面 .Net Reflector (收费) 为了减少程序被别人轻松反编译，可以考虑使用混淆器(obfuscator)产品。这些混淆器会打开IL代码，将代码加密成一种功能不变但更难于理解的形式。 结尾]]></content>
      <tags>
        <tag>C#</tag>
        <tag>C#本质论</tag>
        <tag>Essential C#</tag>
      </tags>
  </entry>
</search>
